##################################################
# file: VimService_types.py
#
# schema types generated by "ZSI.generate.wsdl2python.WriteServiceModule"
#    /home/msw/svn/zsi/zsi/scripts/wsdl2py -b --lazy /home/msw/vmware-sdk/SDK/wsdl/vim25/vimService.wsdl
#
##################################################

import ZSI
import ZSI.TCcompound
from ZSI.schema import LocalElementDeclaration, ElementDeclaration, TypeDefinition, GTD, GED
from ZSI.generate.pyclass import pyclass_type

##############################
# targetNamespace
# urn:vim25
##############################

class ns0:
    targetNamespace = "urn:vim25"

    class DynamicArray_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DynamicArray")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DynamicArray_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"dynamicType"), aname="_dynamicType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"val"), aname="_val", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._dynamicType = None
                    self._val = []
                    return
            Holder.__name__ = "DynamicArray_Holder"
            self.pyclass = Holder

    class DynamicData_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DynamicData")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DynamicData_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"dynamicType"), aname="_dynamicType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DynamicProperty",lazy=True)(pname=(ns,"dynamicProperty"), aname="_dynamicProperty", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._dynamicType = None
                    self._dynamicProperty = []
                    return
            Holder.__name__ = "DynamicData_Holder"
            self.pyclass = Holder

    class DynamicProperty_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DynamicProperty")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DynamicProperty_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"val"), aname="_val", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._name = None
                    self._val = None
                    return
            Holder.__name__ = "DynamicProperty_Holder"
            self.pyclass = Holder

    class ArrayOfDynamicProperty_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfDynamicProperty")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfDynamicProperty_Def.schema
            TClist = [GTD("urn:vim25","DynamicProperty",lazy=True)(pname=(ns,"DynamicProperty"), aname="_DynamicProperty", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._DynamicProperty = []
                    return
            Holder.__name__ = "ArrayOfDynamicProperty_Holder"
            self.pyclass = Holder

    class HostCommunication_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCommunication")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCommunication_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.HostCommunication_Def.__bases__:
                bases = list(ns0.HostCommunication_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.HostCommunication_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNotConnected_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNotConnected")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNotConnected_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostCommunication_Def not in ns0.HostNotConnected_Def.__bases__:
                bases = list(ns0.HostNotConnected_Def.__bases__)
                bases.insert(0, ns0.HostCommunication_Def)
                ns0.HostNotConnected_Def.__bases__ = tuple(bases)

            ns0.HostCommunication_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNotReachable_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNotReachable")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNotReachable_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostCommunication_Def not in ns0.HostNotReachable_Def.__bases__:
                bases = list(ns0.HostNotReachable_Def.__bases__)
                bases.insert(0, ns0.HostCommunication_Def)
                ns0.HostNotReachable_Def.__bases__ = tuple(bases)

            ns0.HostCommunication_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidArgument_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"invalidProperty"), aname="_invalidProperty", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.InvalidArgument_Def.__bases__:
                bases = list(ns0.InvalidArgument_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.InvalidArgument_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidRequest_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidRequest")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidRequest_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.InvalidRequest_Def.__bases__:
                bases = list(ns0.InvalidRequest_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.InvalidRequest_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidType_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidType")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidType_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"argument"), aname="_argument", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidRequest_Def not in ns0.InvalidType_Def.__bases__:
                bases = list(ns0.InvalidType_Def.__bases__)
                bases.insert(0, ns0.InvalidRequest_Def)
                ns0.InvalidType_Def.__bases__ = tuple(bases)

            ns0.InvalidRequest_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ManagedObjectNotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ManagedObjectNotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ManagedObjectNotFound_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.ManagedObjectNotFound_Def.__bases__:
                bases = list(ns0.ManagedObjectNotFound_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.ManagedObjectNotFound_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MethodNotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MethodNotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MethodNotFound_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"receiver"), aname="_receiver", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"method"), aname="_method", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidRequest_Def not in ns0.MethodNotFound_Def.__bases__:
                bases = list(ns0.MethodNotFound_Def.__bases__)
                bases.insert(0, ns0.InvalidRequest_Def)
                ns0.MethodNotFound_Def.__bases__ = tuple(bases)

            ns0.InvalidRequest_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotEnoughLicenses_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotEnoughLicenses")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotEnoughLicenses_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.NotEnoughLicenses_Def.__bases__:
                bases = list(ns0.NotEnoughLicenses_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.NotEnoughLicenses_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotImplemented_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotImplemented")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotImplemented_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.NotImplemented_Def.__bases__:
                bases = list(ns0.NotImplemented_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.NotImplemented_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.NotSupported_Def.__bases__:
                bases = list(ns0.NotSupported_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.NotSupported_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RequestCanceled_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RequestCanceled")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RequestCanceled_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.RequestCanceled_Def.__bases__:
                bases = list(ns0.RequestCanceled_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.RequestCanceled_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SecurityError_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SecurityError")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SecurityError_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.SecurityError_Def.__bases__:
                bases = list(ns0.SecurityError_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.SecurityError_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SystemError_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SystemError")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SystemError_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.SystemError_Def.__bases__:
                bases = list(ns0.SystemError_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.SystemError_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnexpectedFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnexpectedFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnexpectedFault_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"faultName"), aname="_faultName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.UnexpectedFault_Def.__bases__:
                bases = list(ns0.UnexpectedFault_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.UnexpectedFault_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidCollectorVersion_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidCollectorVersion")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidCollectorVersion_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MethodFault_Def not in ns0.InvalidCollectorVersion_Def.__bases__:
                bases = list(ns0.InvalidCollectorVersion_Def.__bases__)
                bases.insert(0, ns0.MethodFault_Def)
                ns0.InvalidCollectorVersion_Def.__bases__ = tuple(bases)

            ns0.MethodFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidProperty_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidProperty")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidProperty_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MethodFault_Def not in ns0.InvalidProperty_Def.__bases__:
                bases = list(ns0.InvalidProperty_Def.__bases__)
                bases.insert(0, ns0.MethodFault_Def)
                ns0.InvalidProperty_Def.__bases__ = tuple(bases)

            ns0.MethodFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PropertyFilterSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PropertyFilterSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PropertyFilterSpec_Def.schema
            TClist = [GTD("urn:vim25","PropertySpec",lazy=True)(pname=(ns,"propSet"), aname="_propSet", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ObjectSpec",lazy=True)(pname=(ns,"objectSet"), aname="_objectSet", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PropertyFilterSpec_Def.__bases__:
                bases = list(ns0.PropertyFilterSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PropertyFilterSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPropertyFilterSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPropertyFilterSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPropertyFilterSpec_Def.schema
            TClist = [GTD("urn:vim25","PropertyFilterSpec",lazy=True)(pname=(ns,"PropertyFilterSpec"), aname="_PropertyFilterSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PropertyFilterSpec = []
                    return
            Holder.__name__ = "ArrayOfPropertyFilterSpec_Holder"
            self.pyclass = Holder

    class PropertySpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PropertySpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PropertySpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"all"), aname="_all", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pathSet"), aname="_pathSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PropertySpec_Def.__bases__:
                bases = list(ns0.PropertySpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PropertySpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPropertySpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPropertySpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPropertySpec_Def.schema
            TClist = [GTD("urn:vim25","PropertySpec",lazy=True)(pname=(ns,"PropertySpec"), aname="_PropertySpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PropertySpec = []
                    return
            Holder.__name__ = "ArrayOfPropertySpec_Holder"
            self.pyclass = Holder

    class ObjectSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ObjectSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ObjectSpec_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"skip"), aname="_skip", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","SelectionSpec",lazy=True)(pname=(ns,"selectSet"), aname="_selectSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ObjectSpec_Def.__bases__:
                bases = list(ns0.ObjectSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ObjectSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfObjectSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfObjectSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfObjectSpec_Def.schema
            TClist = [GTD("urn:vim25","ObjectSpec",lazy=True)(pname=(ns,"ObjectSpec"), aname="_ObjectSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ObjectSpec = []
                    return
            Holder.__name__ = "ArrayOfObjectSpec_Holder"
            self.pyclass = Holder

    class SelectionSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SelectionSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SelectionSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.SelectionSpec_Def.__bases__:
                bases = list(ns0.SelectionSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.SelectionSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfSelectionSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfSelectionSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfSelectionSpec_Def.schema
            TClist = [GTD("urn:vim25","SelectionSpec",lazy=True)(pname=(ns,"SelectionSpec"), aname="_SelectionSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._SelectionSpec = []
                    return
            Holder.__name__ = "ArrayOfSelectionSpec_Holder"
            self.pyclass = Holder

    class TraversalSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TraversalSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TraversalSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"skip"), aname="_skip", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","SelectionSpec",lazy=True)(pname=(ns,"selectSet"), aname="_selectSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SelectionSpec_Def not in ns0.TraversalSpec_Def.__bases__:
                bases = list(ns0.TraversalSpec_Def.__bases__)
                bases.insert(0, ns0.SelectionSpec_Def)
                ns0.TraversalSpec_Def.__bases__ = tuple(bases)

            ns0.SelectionSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DestroyPropertyFilterRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DestroyPropertyFilterRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DestroyPropertyFilterRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DestroyPropertyFilterRequestType_Holder"
            self.pyclass = Holder

    class ObjectContent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ObjectContent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ObjectContent_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DynamicProperty",lazy=True)(pname=(ns,"propSet"), aname="_propSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","MissingProperty",lazy=True)(pname=(ns,"missingSet"), aname="_missingSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ObjectContent_Def.__bases__:
                bases = list(ns0.ObjectContent_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ObjectContent_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfObjectContent_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfObjectContent")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfObjectContent_Def.schema
            TClist = [GTD("urn:vim25","ObjectContent",lazy=True)(pname=(ns,"ObjectContent"), aname="_ObjectContent", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ObjectContent = []
                    return
            Holder.__name__ = "ArrayOfObjectContent_Holder"
            self.pyclass = Holder

    class UpdateSet_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UpdateSet")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UpdateSet_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PropertyFilterUpdate",lazy=True)(pname=(ns,"filterSet"), aname="_filterSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.UpdateSet_Def.__bases__:
                bases = list(ns0.UpdateSet_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.UpdateSet_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PropertyFilterUpdate_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PropertyFilterUpdate")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PropertyFilterUpdate_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"filter"), aname="_filter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ObjectUpdate",lazy=True)(pname=(ns,"objectSet"), aname="_objectSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","MissingObject",lazy=True)(pname=(ns,"missingSet"), aname="_missingSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PropertyFilterUpdate_Def.__bases__:
                bases = list(ns0.PropertyFilterUpdate_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PropertyFilterUpdate_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPropertyFilterUpdate_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPropertyFilterUpdate")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPropertyFilterUpdate_Def.schema
            TClist = [GTD("urn:vim25","PropertyFilterUpdate",lazy=True)(pname=(ns,"PropertyFilterUpdate"), aname="_PropertyFilterUpdate", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PropertyFilterUpdate = []
                    return
            Holder.__name__ = "ArrayOfPropertyFilterUpdate_Holder"
            self.pyclass = Holder

    class ObjectUpdateKind_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ObjectUpdateKind")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ObjectUpdate_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ObjectUpdate")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ObjectUpdate_Def.schema
            TClist = [GTD("urn:vim25","ObjectUpdateKind",lazy=True)(pname=(ns,"kind"), aname="_kind", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PropertyChange",lazy=True)(pname=(ns,"changeSet"), aname="_changeSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","MissingProperty",lazy=True)(pname=(ns,"missingSet"), aname="_missingSet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ObjectUpdate_Def.__bases__:
                bases = list(ns0.ObjectUpdate_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ObjectUpdate_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfObjectUpdate_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfObjectUpdate")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfObjectUpdate_Def.schema
            TClist = [GTD("urn:vim25","ObjectUpdate",lazy=True)(pname=(ns,"ObjectUpdate"), aname="_ObjectUpdate", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ObjectUpdate = []
                    return
            Holder.__name__ = "ArrayOfObjectUpdate_Holder"
            self.pyclass = Holder

    class PropertyChangeOp_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PropertyChangeOp")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class PropertyChange_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PropertyChange")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PropertyChange_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PropertyChangeOp",lazy=True)(pname=(ns,"op"), aname="_op", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"val"), aname="_val", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PropertyChange_Def.__bases__:
                bases = list(ns0.PropertyChange_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PropertyChange_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPropertyChange_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPropertyChange")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPropertyChange_Def.schema
            TClist = [GTD("urn:vim25","PropertyChange",lazy=True)(pname=(ns,"PropertyChange"), aname="_PropertyChange", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PropertyChange = []
                    return
            Holder.__name__ = "ArrayOfPropertyChange_Holder"
            self.pyclass = Holder

    class MissingProperty_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MissingProperty")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MissingProperty_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.MissingProperty_Def.__bases__:
                bases = list(ns0.MissingProperty_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.MissingProperty_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfMissingProperty_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfMissingProperty")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfMissingProperty_Def.schema
            TClist = [GTD("urn:vim25","MissingProperty",lazy=True)(pname=(ns,"MissingProperty"), aname="_MissingProperty", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._MissingProperty = []
                    return
            Holder.__name__ = "ArrayOfMissingProperty_Holder"
            self.pyclass = Holder

    class MissingObject_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MissingObject")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MissingObject_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.MissingObject_Def.__bases__:
                bases = list(ns0.MissingObject_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.MissingObject_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfMissingObject_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfMissingObject")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfMissingObject_Def.schema
            TClist = [GTD("urn:vim25","MissingObject",lazy=True)(pname=(ns,"MissingObject"), aname="_MissingObject", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._MissingObject = []
                    return
            Holder.__name__ = "ArrayOfMissingObject_Holder"
            self.pyclass = Holder

    class CreateFilterRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateFilterRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateFilterRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PropertyFilterSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"partialUpdates"), aname="_partialUpdates", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    self._partialUpdates = None
                    return
            Holder.__name__ = "CreateFilterRequestType_Holder"
            self.pyclass = Holder

    class RetrievePropertiesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrievePropertiesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrievePropertiesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PropertyFilterSpec",lazy=True)(pname=(ns,"specSet"), aname="_specSet", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._specSet = []
                    return
            Holder.__name__ = "RetrievePropertiesRequestType_Holder"
            self.pyclass = Holder

    class CheckForUpdatesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CheckForUpdatesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CheckForUpdatesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._version = None
                    return
            Holder.__name__ = "CheckForUpdatesRequestType_Holder"
            self.pyclass = Holder

    class WaitForUpdatesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "WaitForUpdatesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.WaitForUpdatesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._version = None
                    return
            Holder.__name__ = "WaitForUpdatesRequestType_Holder"
            self.pyclass = Holder

    class CancelWaitForUpdatesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CancelWaitForUpdatesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CancelWaitForUpdatesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "CancelWaitForUpdatesRequestType_Holder"
            self.pyclass = Holder

    class LocalizedMethodFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LocalizedMethodFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LocalizedMethodFault_Def.schema
            TClist = [GTD("urn:vim25","MethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"localizedMessage"), aname="_localizedMessage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.LocalizedMethodFault_Def.__bases__:
                bases = list(ns0.LocalizedMethodFault_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.LocalizedMethodFault_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MethodFault_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MethodFault")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MethodFault_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"dynamicType"), aname="_dynamicType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DynamicProperty",lazy=True)(pname=(ns,"dynamicProperty"), aname="_dynamicProperty", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._dynamicType = None
                    self._dynamicProperty = []
                    return
            Holder.__name__ = "MethodFault_Holder"
            self.pyclass = Holder

    class ArrayOfMethodFault_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfMethodFault")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfMethodFault_Def.schema
            TClist = [GTD("urn:vim25","MethodFault",lazy=True)(pname=(ns,"MethodFault"), aname="_MethodFault", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._MethodFault = []
                    return
            Holder.__name__ = "ArrayOfMethodFault_Holder"
            self.pyclass = Holder

    class RuntimeFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RuntimeFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RuntimeFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MethodFault_Def not in ns0.RuntimeFault_Def.__bases__:
                bases = list(ns0.RuntimeFault_Def.__bases__)
                bases.insert(0, ns0.MethodFault_Def)
                ns0.RuntimeFault_Def.__bases__ = tuple(bases)

            ns0.MethodFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AboutInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AboutInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AboutInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fullName"), aname="_fullName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vendor"), aname="_vendor", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"build"), aname="_build", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"localeVersion"), aname="_localeVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"localeBuild"), aname="_localeBuild", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"osType"), aname="_osType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"productLineId"), aname="_productLineId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"apiType"), aname="_apiType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"apiVersion"), aname="_apiVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AboutInfo_Def.__bases__:
                bases = list(ns0.AboutInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AboutInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AuthorizationDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AuthorizationDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AuthorizationDescription_Def.schema
            TClist = [GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"privilege"), aname="_privilege", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"privilegeGroup"), aname="_privilegeGroup", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AuthorizationDescription_Def.__bases__:
                bases = list(ns0.AuthorizationDescription_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AuthorizationDescription_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class Permission_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "Permission")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.Permission_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"principal"), aname="_principal", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"roleId"), aname="_roleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"propagate"), aname="_propagate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.Permission_Def.__bases__:
                bases = list(ns0.Permission_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.Permission_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPermission_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPermission")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPermission_Def.schema
            TClist = [GTD("urn:vim25","Permission",lazy=True)(pname=(ns,"Permission"), aname="_Permission", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._Permission = []
                    return
            Holder.__name__ = "ArrayOfPermission_Holder"
            self.pyclass = Holder

    class AuthorizationRole_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AuthorizationRole")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AuthorizationRole_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"roleId"), aname="_roleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"system"), aname="_system", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Description",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"privilege"), aname="_privilege", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AuthorizationRole_Def.__bases__:
                bases = list(ns0.AuthorizationRole_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AuthorizationRole_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfAuthorizationRole_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfAuthorizationRole")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfAuthorizationRole_Def.schema
            TClist = [GTD("urn:vim25","AuthorizationRole",lazy=True)(pname=(ns,"AuthorizationRole"), aname="_AuthorizationRole", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._AuthorizationRole = []
                    return
            Holder.__name__ = "ArrayOfAuthorizationRole_Holder"
            self.pyclass = Holder

    class AuthorizationPrivilege_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AuthorizationPrivilege")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AuthorizationPrivilege_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"privId"), aname="_privId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"onParent"), aname="_onParent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"privGroupName"), aname="_privGroupName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AuthorizationPrivilege_Def.__bases__:
                bases = list(ns0.AuthorizationPrivilege_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AuthorizationPrivilege_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfAuthorizationPrivilege_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfAuthorizationPrivilege")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfAuthorizationPrivilege_Def.schema
            TClist = [GTD("urn:vim25","AuthorizationPrivilege",lazy=True)(pname=(ns,"AuthorizationPrivilege"), aname="_AuthorizationPrivilege", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._AuthorizationPrivilege = []
                    return
            Holder.__name__ = "ArrayOfAuthorizationPrivilege_Holder"
            self.pyclass = Holder

    class AddAuthorizationRoleRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddAuthorizationRoleRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddAuthorizationRoleRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"privIds"), aname="_privIds", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._privIds = []
                    return
            Holder.__name__ = "AddAuthorizationRoleRequestType_Holder"
            self.pyclass = Holder

    class RemoveAuthorizationRoleRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveAuthorizationRoleRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveAuthorizationRoleRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"roleId"), aname="_roleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"failIfUsed"), aname="_failIfUsed", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._roleId = None
                    self._failIfUsed = None
                    return
            Holder.__name__ = "RemoveAuthorizationRoleRequestType_Holder"
            self.pyclass = Holder

    class UpdateAuthorizationRoleRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateAuthorizationRoleRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateAuthorizationRoleRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"roleId"), aname="_roleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"privIds"), aname="_privIds", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._roleId = None
                    self._newName = None
                    self._privIds = []
                    return
            Holder.__name__ = "UpdateAuthorizationRoleRequestType_Holder"
            self.pyclass = Holder

    class MergePermissionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MergePermissionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MergePermissionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"srcRoleId"), aname="_srcRoleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"dstRoleId"), aname="_dstRoleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._srcRoleId = None
                    self._dstRoleId = None
                    return
            Holder.__name__ = "MergePermissionsRequestType_Holder"
            self.pyclass = Holder

    class RetrieveRolePermissionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveRolePermissionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveRolePermissionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"roleId"), aname="_roleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._roleId = None
                    return
            Holder.__name__ = "RetrieveRolePermissionsRequestType_Holder"
            self.pyclass = Holder

    class RetrieveEntityPermissionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveEntityPermissionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveEntityPermissionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"inherited"), aname="_inherited", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._inherited = None
                    return
            Holder.__name__ = "RetrieveEntityPermissionsRequestType_Holder"
            self.pyclass = Holder

    class RetrieveAllPermissionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveAllPermissionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveAllPermissionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RetrieveAllPermissionsRequestType_Holder"
            self.pyclass = Holder

    class SetEntityPermissionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetEntityPermissionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetEntityPermissionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Permission",lazy=True)(pname=(ns,"permission"), aname="_permission", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._permission = []
                    return
            Holder.__name__ = "SetEntityPermissionsRequestType_Holder"
            self.pyclass = Holder

    class ResetEntityPermissionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetEntityPermissionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetEntityPermissionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Permission",lazy=True)(pname=(ns,"permission"), aname="_permission", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._permission = []
                    return
            Holder.__name__ = "ResetEntityPermissionsRequestType_Holder"
            self.pyclass = Holder

    class RemoveEntityPermissionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveEntityPermissionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveEntityPermissionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"user"), aname="_user", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"isGroup"), aname="_isGroup", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._user = None
                    self._isGroup = None
                    return
            Holder.__name__ = "RemoveEntityPermissionRequestType_Holder"
            self.pyclass = Holder

    class Capability_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "Capability")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.Capability_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"provisioningSupported"), aname="_provisioningSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"multiHostSupported"), aname="_multiHostSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"userShellAccessSupported"), aname="_userShellAccessSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.Capability_Def.__bases__:
                bases = list(ns0.Capability_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.Capability_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterComputeResourceSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterComputeResourceSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterComputeResourceSummary_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"currentFailoverLevel"), aname="_currentFailoverLevel", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numVmotions"), aname="_numVmotions", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ComputeResourceSummary_Def not in ns0.ClusterComputeResourceSummary_Def.__bases__:
                bases = list(ns0.ClusterComputeResourceSummary_Def.__bases__)
                bases.insert(0, ns0.ComputeResourceSummary_Def)
                ns0.ClusterComputeResourceSummary_Def.__bases__ = tuple(bases)

            ns0.ComputeResourceSummary_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReconfigureClusterRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureClusterRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureClusterRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterConfigSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"modify"), aname="_modify", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    self._modify = None
                    return
            Holder.__name__ = "ReconfigureClusterRequestType_Holder"
            self.pyclass = Holder

    class ApplyRecommendationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ApplyRecommendationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ApplyRecommendationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._key = None
                    return
            Holder.__name__ = "ApplyRecommendationRequestType_Holder"
            self.pyclass = Holder

    class RecommendHostsForVmRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RecommendHostsForVmRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RecommendHostsForVmRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vm = None
                    self._pool = None
                    return
            Holder.__name__ = "RecommendHostsForVmRequestType_Holder"
            self.pyclass = Holder

    class AddHostRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddHostRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddHostRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostConnectSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"asConnected"), aname="_asConnected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"resourcePool"), aname="_resourcePool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    self._asConnected = None
                    self._resourcePool = None
                    return
            Holder.__name__ = "AddHostRequestType_Holder"
            self.pyclass = Holder

    class MoveIntoRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MoveIntoRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MoveIntoRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = []
                    return
            Holder.__name__ = "MoveIntoRequestType_Holder"
            self.pyclass = Holder

    class MoveHostIntoRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MoveHostIntoRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MoveHostIntoRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"resourcePool"), aname="_resourcePool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    self._resourcePool = None
                    return
            Holder.__name__ = "MoveHostIntoRequestType_Holder"
            self.pyclass = Holder

    class RefreshRecommendationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshRecommendationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshRecommendationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshRecommendationRequestType_Holder"
            self.pyclass = Holder

    class ComputeResourceSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ComputeResourceSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ComputeResourceSummary_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"totalCpu"), aname="_totalCpu", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"totalMemory"), aname="_totalMemory", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"numCpuCores"), aname="_numCpuCores", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"numCpuThreads"), aname="_numCpuThreads", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"effectiveCpu"), aname="_effectiveCpu", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"effectiveMemory"), aname="_effectiveMemory", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numHosts"), aname="_numHosts", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numEffectiveHosts"), aname="_numEffectiveHosts", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityStatus",lazy=True)(pname=(ns,"overallStatus"), aname="_overallStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ComputeResourceSummary_Def.__bases__:
                bases = list(ns0.ComputeResourceSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ComputeResourceSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ComputeResourceConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ComputeResourceConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ComputeResourceConfigInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"vmSwapPlacement"), aname="_vmSwapPlacement", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ComputeResourceConfigInfo_Def.__bases__:
                bases = list(ns0.ComputeResourceConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ComputeResourceConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ComputeResourceConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ComputeResourceConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ComputeResourceConfigSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"vmSwapPlacement"), aname="_vmSwapPlacement", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ComputeResourceConfigSpec_Def.__bases__:
                bases = list(ns0.ComputeResourceConfigSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ComputeResourceConfigSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReconfigureComputeResourceRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureComputeResourceRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureComputeResourceRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ComputeResourceConfigSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"modify"), aname="_modify", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    self._modify = None
                    return
            Holder.__name__ = "ReconfigureComputeResourceRequestType_Holder"
            self.pyclass = Holder

    class CustomFieldDef_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldDef")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldDef_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"managedObjectType"), aname="_managedObjectType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PrivilegePolicyDef",lazy=True)(pname=(ns,"fieldDefPrivileges"), aname="_fieldDefPrivileges", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PrivilegePolicyDef",lazy=True)(pname=(ns,"fieldInstancePrivileges"), aname="_fieldInstancePrivileges", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomFieldDef_Def.__bases__:
                bases = list(ns0.CustomFieldDef_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomFieldDef_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfCustomFieldDef_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfCustomFieldDef")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfCustomFieldDef_Def.schema
            TClist = [GTD("urn:vim25","CustomFieldDef",lazy=True)(pname=(ns,"CustomFieldDef"), aname="_CustomFieldDef", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._CustomFieldDef = []
                    return
            Holder.__name__ = "ArrayOfCustomFieldDef_Holder"
            self.pyclass = Holder

    class CustomFieldValue_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldValue")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldValue_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomFieldValue_Def.__bases__:
                bases = list(ns0.CustomFieldValue_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomFieldValue_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfCustomFieldValue_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfCustomFieldValue")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfCustomFieldValue_Def.schema
            TClist = [GTD("urn:vim25","CustomFieldValue",lazy=True)(pname=(ns,"CustomFieldValue"), aname="_CustomFieldValue", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._CustomFieldValue = []
                    return
            Holder.__name__ = "ArrayOfCustomFieldValue_Holder"
            self.pyclass = Holder

    class CustomFieldStringValue_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldStringValue")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldStringValue_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomFieldValue_Def not in ns0.CustomFieldStringValue_Def.__bases__:
                bases = list(ns0.CustomFieldStringValue_Def.__bases__)
                bases.insert(0, ns0.CustomFieldValue_Def)
                ns0.CustomFieldStringValue_Def.__bases__ = tuple(bases)

            ns0.CustomFieldValue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AddCustomFieldDefRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddCustomFieldDefRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddCustomFieldDefRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"moType"), aname="_moType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PrivilegePolicyDef",lazy=True)(pname=(ns,"fieldDefPolicy"), aname="_fieldDefPolicy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PrivilegePolicyDef",lazy=True)(pname=(ns,"fieldPolicy"), aname="_fieldPolicy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._moType = None
                    self._fieldDefPolicy = None
                    self._fieldPolicy = None
                    return
            Holder.__name__ = "AddCustomFieldDefRequestType_Holder"
            self.pyclass = Holder

    class RemoveCustomFieldDefRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveCustomFieldDefRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveCustomFieldDefRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._key = None
                    return
            Holder.__name__ = "RemoveCustomFieldDefRequestType_Holder"
            self.pyclass = Holder

    class RenameCustomFieldDefRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RenameCustomFieldDefRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RenameCustomFieldDefRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._key = None
                    self._name = None
                    return
            Holder.__name__ = "RenameCustomFieldDefRequestType_Holder"
            self.pyclass = Holder

    class SetFieldRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetFieldRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetFieldRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._key = None
                    self._value = None
                    return
            Holder.__name__ = "SetFieldRequestType_Holder"
            self.pyclass = Holder

    class DoesCustomizationSpecExistRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DoesCustomizationSpecExistRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DoesCustomizationSpecExistRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    return
            Holder.__name__ = "DoesCustomizationSpecExistRequestType_Holder"
            self.pyclass = Holder

    class GetCustomizationSpecRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "GetCustomizationSpecRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.GetCustomizationSpecRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    return
            Holder.__name__ = "GetCustomizationSpecRequestType_Holder"
            self.pyclass = Holder

    class CreateCustomizationSpecRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateCustomizationSpecRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateCustomizationSpecRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSpecItem",lazy=True)(pname=(ns,"item"), aname="_item", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._item = None
                    return
            Holder.__name__ = "CreateCustomizationSpecRequestType_Holder"
            self.pyclass = Holder

    class OverwriteCustomizationSpecRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "OverwriteCustomizationSpecRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.OverwriteCustomizationSpecRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSpecItem",lazy=True)(pname=(ns,"item"), aname="_item", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._item = None
                    return
            Holder.__name__ = "OverwriteCustomizationSpecRequestType_Holder"
            self.pyclass = Holder

    class DeleteCustomizationSpecRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DeleteCustomizationSpecRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DeleteCustomizationSpecRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    return
            Holder.__name__ = "DeleteCustomizationSpecRequestType_Holder"
            self.pyclass = Holder

    class DuplicateCustomizationSpecRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DuplicateCustomizationSpecRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DuplicateCustomizationSpecRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._newName = None
                    return
            Holder.__name__ = "DuplicateCustomizationSpecRequestType_Holder"
            self.pyclass = Holder

    class RenameCustomizationSpecRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RenameCustomizationSpecRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RenameCustomizationSpecRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._newName = None
                    return
            Holder.__name__ = "RenameCustomizationSpecRequestType_Holder"
            self.pyclass = Holder

    class CustomizationSpecItemToXmlRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CustomizationSpecItemToXmlRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CustomizationSpecItemToXmlRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSpecItem",lazy=True)(pname=(ns,"item"), aname="_item", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._item = None
                    return
            Holder.__name__ = "CustomizationSpecItemToXmlRequestType_Holder"
            self.pyclass = Holder

    class XmlToCustomizationSpecItemRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "XmlToCustomizationSpecItemRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.XmlToCustomizationSpecItemRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"specItemXml"), aname="_specItemXml", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._specItemXml = None
                    return
            Holder.__name__ = "XmlToCustomizationSpecItemRequestType_Holder"
            self.pyclass = Holder

    class CheckCustomizationResourcesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CheckCustomizationResourcesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CheckCustomizationResourcesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestOs"), aname="_guestOs", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._guestOs = None
                    return
            Holder.__name__ = "CheckCustomizationResourcesRequestType_Holder"
            self.pyclass = Holder

    class CustomizationSpecInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationSpecInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationSpecInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"changeVersion"), aname="_changeVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"lastUpdateTime"), aname="_lastUpdateTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationSpecInfo_Def.__bases__:
                bases = list(ns0.CustomizationSpecInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationSpecInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfCustomizationSpecInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfCustomizationSpecInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfCustomizationSpecInfo_Def.schema
            TClist = [GTD("urn:vim25","CustomizationSpecInfo",lazy=True)(pname=(ns,"CustomizationSpecInfo"), aname="_CustomizationSpecInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._CustomizationSpecInfo = []
                    return
            Holder.__name__ = "ArrayOfCustomizationSpecInfo_Holder"
            self.pyclass = Holder

    class CustomizationSpecItem_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationSpecItem")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationSpecItem_Def.schema
            TClist = [GTD("urn:vim25","CustomizationSpecInfo",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationSpecItem_Def.__bases__:
                bases = list(ns0.CustomizationSpecItem_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationSpecItem_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class QueryConnectionInfoRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryConnectionInfoRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryConnectionInfoRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"hostname"), aname="_hostname", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"username"), aname="_username", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"password"), aname="_password", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sslThumbprint"), aname="_sslThumbprint", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._hostname = None
                    self._port = None
                    self._username = None
                    self._password = None
                    self._sslThumbprint = None
                    return
            Holder.__name__ = "QueryConnectionInfoRequestType_Holder"
            self.pyclass = Holder

    class PowerOnMultiVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PowerOnMultiVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.PowerOnMultiVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vm = []
                    return
            Holder.__name__ = "PowerOnMultiVMRequestType_Holder"
            self.pyclass = Holder

    class DatastoreSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreSummary_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"url"), aname="_url", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"capacity"), aname="_capacity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"freeSpace"), aname="_freeSpace", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"accessible"), aname="_accessible", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"multipleHostAccess"), aname="_multipleHostAccess", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DatastoreSummary_Def.__bases__:
                bases = list(ns0.DatastoreSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DatastoreSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"url"), aname="_url", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"freeSpace"), aname="_freeSpace", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"maxFileSize"), aname="_maxFileSize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DatastoreInfo_Def.__bases__:
                bases = list(ns0.DatastoreInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DatastoreInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreCapability_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreCapability")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreCapability_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"directoryHierarchySupported"), aname="_directoryHierarchySupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"rawDiskMappingsSupported"), aname="_rawDiskMappingsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"perFileThinProvisioningSupported"), aname="_perFileThinProvisioningSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DatastoreCapability_Def.__bases__:
                bases = list(ns0.DatastoreCapability_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DatastoreCapability_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreHostMount_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreHostMount")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreHostMount_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostMountInfo",lazy=True)(pname=(ns,"mountInfo"), aname="_mountInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DatastoreHostMount_Def.__bases__:
                bases = list(ns0.DatastoreHostMount_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DatastoreHostMount_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfDatastoreHostMount_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfDatastoreHostMount")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfDatastoreHostMount_Def.schema
            TClist = [GTD("urn:vim25","DatastoreHostMount",lazy=True)(pname=(ns,"DatastoreHostMount"), aname="_DatastoreHostMount", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._DatastoreHostMount = []
                    return
            Holder.__name__ = "ArrayOfDatastoreHostMount_Holder"
            self.pyclass = Holder

    class RenameDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RenameDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RenameDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._newName = None
                    return
            Holder.__name__ = "RenameDatastoreRequestType_Holder"
            self.pyclass = Holder

    class RefreshDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshDatastoreRequestType_Holder"
            self.pyclass = Holder

    class DestroyDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DestroyDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DestroyDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DestroyDatastoreRequestType_Holder"
            self.pyclass = Holder

    class Description_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "Description")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.Description_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"label"), aname="_label", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"summary"), aname="_summary", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.Description_Def.__bases__:
                bases = list(ns0.Description_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.Description_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DiagnosticManagerLogCreator_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DiagnosticManagerLogCreator")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class DiagnosticManagerLogFormat_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DiagnosticManagerLogFormat")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class DiagnosticManagerLogDescriptor_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DiagnosticManagerLogDescriptor")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DiagnosticManagerLogDescriptor_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fileName"), aname="_fileName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"creator"), aname="_creator", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"format"), aname="_format", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mimeType"), aname="_mimeType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Description",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DiagnosticManagerLogDescriptor_Def.__bases__:
                bases = list(ns0.DiagnosticManagerLogDescriptor_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DiagnosticManagerLogDescriptor_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfDiagnosticManagerLogDescriptor_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfDiagnosticManagerLogDescriptor")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfDiagnosticManagerLogDescriptor_Def.schema
            TClist = [GTD("urn:vim25","DiagnosticManagerLogDescriptor",lazy=True)(pname=(ns,"DiagnosticManagerLogDescriptor"), aname="_DiagnosticManagerLogDescriptor", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._DiagnosticManagerLogDescriptor = []
                    return
            Holder.__name__ = "ArrayOfDiagnosticManagerLogDescriptor_Holder"
            self.pyclass = Holder

    class DiagnosticManagerLogHeader_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DiagnosticManagerLogHeader")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DiagnosticManagerLogHeader_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"lineStart"), aname="_lineStart", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"lineEnd"), aname="_lineEnd", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"lineText"), aname="_lineText", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DiagnosticManagerLogHeader_Def.__bases__:
                bases = list(ns0.DiagnosticManagerLogHeader_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DiagnosticManagerLogHeader_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DiagnosticManagerBundleInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DiagnosticManagerBundleInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DiagnosticManagerBundleInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"system"), aname="_system", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"url"), aname="_url", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DiagnosticManagerBundleInfo_Def.__bases__:
                bases = list(ns0.DiagnosticManagerBundleInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DiagnosticManagerBundleInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfDiagnosticManagerBundleInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfDiagnosticManagerBundleInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfDiagnosticManagerBundleInfo_Def.schema
            TClist = [GTD("urn:vim25","DiagnosticManagerBundleInfo",lazy=True)(pname=(ns,"DiagnosticManagerBundleInfo"), aname="_DiagnosticManagerBundleInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._DiagnosticManagerBundleInfo = []
                    return
            Holder.__name__ = "ArrayOfDiagnosticManagerBundleInfo_Holder"
            self.pyclass = Holder

    class QueryDescriptionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryDescriptionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryDescriptionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "QueryDescriptionsRequestType_Holder"
            self.pyclass = Holder

    class BrowseDiagnosticLogRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "BrowseDiagnosticLogRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.BrowseDiagnosticLogRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"start"), aname="_start", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"lines"), aname="_lines", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    self._key = None
                    self._start = None
                    self._lines = None
                    return
            Holder.__name__ = "BrowseDiagnosticLogRequestType_Holder"
            self.pyclass = Holder

    class GenerateLogBundlesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "GenerateLogBundlesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.GenerateLogBundlesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"includeDefault"), aname="_includeDefault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._includeDefault = None
                    self._host = []
                    return
            Holder.__name__ = "GenerateLogBundlesRequestType_Holder"
            self.pyclass = Holder

    class ElementDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ElementDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ElementDescription_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Description_Def not in ns0.ElementDescription_Def.__bases__:
                bases = list(ns0.ElementDescription_Def.__bases__)
                bases.insert(0, ns0.Description_Def)
                ns0.ElementDescription_Def.__bases__ = tuple(bases)

            ns0.Description_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfElementDescription_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfElementDescription")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfElementDescription_Def.schema
            TClist = [GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"ElementDescription"), aname="_ElementDescription", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ElementDescription = []
                    return
            Holder.__name__ = "ArrayOfElementDescription_Holder"
            self.pyclass = Holder

    class QueryConfigOptionDescriptorRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryConfigOptionDescriptorRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryConfigOptionDescriptorRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "QueryConfigOptionDescriptorRequestType_Holder"
            self.pyclass = Holder

    class QueryConfigOptionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryConfigOptionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryConfigOptionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._key = None
                    self._host = None
                    return
            Holder.__name__ = "QueryConfigOptionRequestType_Holder"
            self.pyclass = Holder

    class QueryConfigTargetRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryConfigTargetRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryConfigTargetRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "QueryConfigTargetRequestType_Holder"
            self.pyclass = Holder

    class setCustomValueRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "setCustomValueRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.setCustomValueRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._key = None
                    self._value = None
                    return
            Holder.__name__ = "setCustomValueRequestType_Holder"
            self.pyclass = Holder

    class ExtensionServerInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtensionServerInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtensionServerInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"url"), aname="_url", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Description",lazy=True)(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"company"), aname="_company", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"adminEmail"), aname="_adminEmail", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtensionServerInfo_Def.__bases__:
                bases = list(ns0.ExtensionServerInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtensionServerInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtensionServerInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtensionServerInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtensionServerInfo_Def.schema
            TClist = [GTD("urn:vim25","ExtensionServerInfo",lazy=True)(pname=(ns,"ExtensionServerInfo"), aname="_ExtensionServerInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtensionServerInfo = []
                    return
            Holder.__name__ = "ArrayOfExtensionServerInfo_Holder"
            self.pyclass = Holder

    class ExtensionClientInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtensionClientInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtensionClientInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Description",lazy=True)(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"company"), aname="_company", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"url"), aname="_url", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtensionClientInfo_Def.__bases__:
                bases = list(ns0.ExtensionClientInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtensionClientInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtensionClientInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtensionClientInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtensionClientInfo_Def.schema
            TClist = [GTD("urn:vim25","ExtensionClientInfo",lazy=True)(pname=(ns,"ExtensionClientInfo"), aname="_ExtensionClientInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtensionClientInfo = []
                    return
            Holder.__name__ = "ArrayOfExtensionClientInfo_Holder"
            self.pyclass = Holder

    class ExtensionTaskTypeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtensionTaskTypeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtensionTaskTypeInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"taskID"), aname="_taskID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtensionTaskTypeInfo_Def.__bases__:
                bases = list(ns0.ExtensionTaskTypeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtensionTaskTypeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtensionTaskTypeInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtensionTaskTypeInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtensionTaskTypeInfo_Def.schema
            TClist = [GTD("urn:vim25","ExtensionTaskTypeInfo",lazy=True)(pname=(ns,"ExtensionTaskTypeInfo"), aname="_ExtensionTaskTypeInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtensionTaskTypeInfo = []
                    return
            Holder.__name__ = "ArrayOfExtensionTaskTypeInfo_Holder"
            self.pyclass = Holder

    class ExtensionEventTypeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtensionEventTypeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtensionEventTypeInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"eventID"), aname="_eventID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtensionEventTypeInfo_Def.__bases__:
                bases = list(ns0.ExtensionEventTypeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtensionEventTypeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtensionEventTypeInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtensionEventTypeInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtensionEventTypeInfo_Def.schema
            TClist = [GTD("urn:vim25","ExtensionEventTypeInfo",lazy=True)(pname=(ns,"ExtensionEventTypeInfo"), aname="_ExtensionEventTypeInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtensionEventTypeInfo = []
                    return
            Holder.__name__ = "ArrayOfExtensionEventTypeInfo_Holder"
            self.pyclass = Holder

    class ExtensionFaultTypeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtensionFaultTypeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtensionFaultTypeInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"faultID"), aname="_faultID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtensionFaultTypeInfo_Def.__bases__:
                bases = list(ns0.ExtensionFaultTypeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtensionFaultTypeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtensionFaultTypeInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtensionFaultTypeInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtensionFaultTypeInfo_Def.schema
            TClist = [GTD("urn:vim25","ExtensionFaultTypeInfo",lazy=True)(pname=(ns,"ExtensionFaultTypeInfo"), aname="_ExtensionFaultTypeInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtensionFaultTypeInfo = []
                    return
            Holder.__name__ = "ArrayOfExtensionFaultTypeInfo_Holder"
            self.pyclass = Holder

    class ExtensionPrivilegeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtensionPrivilegeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtensionPrivilegeInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"privID"), aname="_privID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"privGroupName"), aname="_privGroupName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtensionPrivilegeInfo_Def.__bases__:
                bases = list(ns0.ExtensionPrivilegeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtensionPrivilegeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtensionPrivilegeInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtensionPrivilegeInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtensionPrivilegeInfo_Def.schema
            TClist = [GTD("urn:vim25","ExtensionPrivilegeInfo",lazy=True)(pname=(ns,"ExtensionPrivilegeInfo"), aname="_ExtensionPrivilegeInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtensionPrivilegeInfo = []
                    return
            Holder.__name__ = "ArrayOfExtensionPrivilegeInfo_Holder"
            self.pyclass = Holder

    class ExtensionResourceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtensionResourceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtensionResourceInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"locale"), aname="_locale", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"module"), aname="_module", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","KeyValue",lazy=True)(pname=(ns,"data"), aname="_data", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtensionResourceInfo_Def.__bases__:
                bases = list(ns0.ExtensionResourceInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtensionResourceInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtensionResourceInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtensionResourceInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtensionResourceInfo_Def.schema
            TClist = [GTD("urn:vim25","ExtensionResourceInfo",lazy=True)(pname=(ns,"ExtensionResourceInfo"), aname="_ExtensionResourceInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtensionResourceInfo = []
                    return
            Holder.__name__ = "ArrayOfExtensionResourceInfo_Holder"
            self.pyclass = Holder

    class Extension_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "Extension")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.Extension_Def.schema
            TClist = [GTD("urn:vim25","Description",lazy=True)(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"subjectName"), aname="_subjectName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtensionServerInfo",lazy=True)(pname=(ns,"server"), aname="_server", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtensionClientInfo",lazy=True)(pname=(ns,"client"), aname="_client", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtensionTaskTypeInfo",lazy=True)(pname=(ns,"taskList"), aname="_taskList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtensionEventTypeInfo",lazy=True)(pname=(ns,"eventList"), aname="_eventList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtensionFaultTypeInfo",lazy=True)(pname=(ns,"faultList"), aname="_faultList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtensionPrivilegeInfo",lazy=True)(pname=(ns,"privilegeList"), aname="_privilegeList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtensionResourceInfo",lazy=True)(pname=(ns,"resourceList"), aname="_resourceList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"lastHeartbeatTime"), aname="_lastHeartbeatTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.Extension_Def.__bases__:
                bases = list(ns0.Extension_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.Extension_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtension_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtension")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtension_Def.schema
            TClist = [GTD("urn:vim25","Extension",lazy=True)(pname=(ns,"Extension"), aname="_Extension", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._Extension = []
                    return
            Holder.__name__ = "ArrayOfExtension_Holder"
            self.pyclass = Holder

    class UnregisterExtensionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UnregisterExtensionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UnregisterExtensionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"extensionKey"), aname="_extensionKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._extensionKey = None
                    return
            Holder.__name__ = "UnregisterExtensionRequestType_Holder"
            self.pyclass = Holder

    class FindExtensionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FindExtensionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FindExtensionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"extensionKey"), aname="_extensionKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._extensionKey = None
                    return
            Holder.__name__ = "FindExtensionRequestType_Holder"
            self.pyclass = Holder

    class RegisterExtensionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RegisterExtensionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RegisterExtensionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Extension",lazy=True)(pname=(ns,"extension"), aname="_extension", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._extension = None
                    return
            Holder.__name__ = "RegisterExtensionRequestType_Holder"
            self.pyclass = Holder

    class UpdateExtensionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateExtensionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateExtensionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Extension",lazy=True)(pname=(ns,"extension"), aname="_extension", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._extension = None
                    return
            Holder.__name__ = "UpdateExtensionRequestType_Holder"
            self.pyclass = Holder

    class GetPublicKeyRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "GetPublicKeyRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.GetPublicKeyRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "GetPublicKeyRequestType_Holder"
            self.pyclass = Holder

    class SetPublicKeyRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetPublicKeyRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetPublicKeyRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"extensionKey"), aname="_extensionKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"publicKey"), aname="_publicKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._extensionKey = None
                    self._publicKey = None
                    return
            Holder.__name__ = "SetPublicKeyRequestType_Holder"
            self.pyclass = Holder

    class FileManagerFileType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FileManagerFileType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class MoveDatastoreFileRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MoveDatastoreFileRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MoveDatastoreFileRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sourceName"), aname="_sourceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"sourceDatacenter"), aname="_sourceDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"destinationName"), aname="_destinationName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"destinationDatacenter"), aname="_destinationDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._sourceName = None
                    self._sourceDatacenter = None
                    self._destinationName = None
                    self._destinationDatacenter = None
                    self._force = None
                    return
            Holder.__name__ = "MoveDatastoreFileRequestType_Holder"
            self.pyclass = Holder

    class CopyDatastoreFileRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CopyDatastoreFileRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CopyDatastoreFileRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sourceName"), aname="_sourceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"sourceDatacenter"), aname="_sourceDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"destinationName"), aname="_destinationName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"destinationDatacenter"), aname="_destinationDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._sourceName = None
                    self._sourceDatacenter = None
                    self._destinationName = None
                    self._destinationDatacenter = None
                    self._force = None
                    return
            Holder.__name__ = "CopyDatastoreFileRequestType_Holder"
            self.pyclass = Holder

    class DeleteDatastoreFileRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DeleteDatastoreFileRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DeleteDatastoreFileRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "DeleteDatastoreFileRequestType_Holder"
            self.pyclass = Holder

    class MakeDirectoryRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MakeDirectoryRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MakeDirectoryRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"createParentDirectories"), aname="_createParentDirectories", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    self._createParentDirectories = None
                    return
            Holder.__name__ = "MakeDirectoryRequestType_Holder"
            self.pyclass = Holder

    class CreateFolderRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateFolderRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateFolderRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    return
            Holder.__name__ = "CreateFolderRequestType_Holder"
            self.pyclass = Holder

    class MoveIntoFolderRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MoveIntoFolderRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MoveIntoFolderRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"list"), aname="_list", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._list = []
                    return
            Holder.__name__ = "MoveIntoFolderRequestType_Holder"
            self.pyclass = Holder

    class CreateVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConfigSpec",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._config = None
                    self._pool = None
                    self._host = None
                    return
            Holder.__name__ = "CreateVMRequestType_Holder"
            self.pyclass = Holder

    class RegisterVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RegisterVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RegisterVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"asTemplate"), aname="_asTemplate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._path = None
                    self._name = None
                    self._asTemplate = None
                    self._pool = None
                    self._host = None
                    return
            Holder.__name__ = "RegisterVMRequestType_Holder"
            self.pyclass = Holder

    class CreateClusterRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateClusterRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateClusterRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterConfigSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateClusterRequestType_Holder"
            self.pyclass = Holder

    class CreateClusterExRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateClusterExRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateClusterExRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterConfigSpecEx",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateClusterExRequestType_Holder"
            self.pyclass = Holder

    class AddStandaloneHostRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddStandaloneHostRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddStandaloneHostRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostConnectSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ComputeResourceConfigSpec",lazy=True)(pname=(ns,"compResSpec"), aname="_compResSpec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"addConnected"), aname="_addConnected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    self._compResSpec = None
                    self._addConnected = None
                    return
            Holder.__name__ = "AddStandaloneHostRequestType_Holder"
            self.pyclass = Holder

    class CreateDatacenterRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateDatacenterRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateDatacenterRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    return
            Holder.__name__ = "CreateDatacenterRequestType_Holder"
            self.pyclass = Holder

    class UnregisterAndDestroyRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UnregisterAndDestroyRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UnregisterAndDestroyRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "UnregisterAndDestroyRequestType_Holder"
            self.pyclass = Holder

    class SetCollectorPageSizeRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetCollectorPageSizeRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetCollectorPageSizeRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxCount"), aname="_maxCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._maxCount = None
                    return
            Holder.__name__ = "SetCollectorPageSizeRequestType_Holder"
            self.pyclass = Holder

    class RewindCollectorRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RewindCollectorRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RewindCollectorRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RewindCollectorRequestType_Holder"
            self.pyclass = Holder

    class ResetCollectorRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetCollectorRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetCollectorRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ResetCollectorRequestType_Holder"
            self.pyclass = Holder

    class DestroyCollectorRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DestroyCollectorRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DestroyCollectorRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DestroyCollectorRequestType_Holder"
            self.pyclass = Holder

    class HostServiceTicket_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostServiceTicket")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostServiceTicket_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sslThumbprint"), aname="_sslThumbprint", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"service"), aname="_service", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"serviceVersion"), aname="_serviceVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sessionId"), aname="_sessionId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostServiceTicket_Def.__bases__:
                bases = list(ns0.HostServiceTicket_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostServiceTicket_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostSystemConnectionState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostSystemConnectionState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostSystemPowerState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostSystemPowerState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class QueryHostConnectionInfoRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryHostConnectionInfoRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryHostConnectionInfoRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "QueryHostConnectionInfoRequestType_Holder"
            self.pyclass = Holder

    class UpdateSystemResourcesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateSystemResourcesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateSystemResourcesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSystemResourceInfo",lazy=True)(pname=(ns,"resourceInfo"), aname="_resourceInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._resourceInfo = None
                    return
            Holder.__name__ = "UpdateSystemResourcesRequestType_Holder"
            self.pyclass = Holder

    class ReconnectHostRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconnectHostRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconnectHostRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostConnectSpec",lazy=True)(pname=(ns,"cnxSpec"), aname="_cnxSpec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._cnxSpec = None
                    return
            Holder.__name__ = "ReconnectHostRequestType_Holder"
            self.pyclass = Holder

    class DisconnectHostRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DisconnectHostRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DisconnectHostRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DisconnectHostRequestType_Holder"
            self.pyclass = Holder

    class EnterMaintenanceModeRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "EnterMaintenanceModeRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.EnterMaintenanceModeRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"timeout"), aname="_timeout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"evacuatePoweredOffVms"), aname="_evacuatePoweredOffVms", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._timeout = None
                    self._evacuatePoweredOffVms = None
                    return
            Holder.__name__ = "EnterMaintenanceModeRequestType_Holder"
            self.pyclass = Holder

    class ExitMaintenanceModeRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ExitMaintenanceModeRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ExitMaintenanceModeRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"timeout"), aname="_timeout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._timeout = None
                    return
            Holder.__name__ = "ExitMaintenanceModeRequestType_Holder"
            self.pyclass = Holder

    class RebootHostRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RebootHostRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RebootHostRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._force = None
                    return
            Holder.__name__ = "RebootHostRequestType_Holder"
            self.pyclass = Holder

    class ShutdownHostRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ShutdownHostRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ShutdownHostRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._force = None
                    return
            Holder.__name__ = "ShutdownHostRequestType_Holder"
            self.pyclass = Holder

    class PowerDownHostToStandByRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PowerDownHostToStandByRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.PowerDownHostToStandByRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"timeoutSec"), aname="_timeoutSec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"evacuatePoweredOffVms"), aname="_evacuatePoweredOffVms", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._timeoutSec = None
                    self._evacuatePoweredOffVms = None
                    return
            Holder.__name__ = "PowerDownHostToStandByRequestType_Holder"
            self.pyclass = Holder

    class PowerUpHostFromStandByRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PowerUpHostFromStandByRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.PowerUpHostFromStandByRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"timeoutSec"), aname="_timeoutSec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._timeoutSec = None
                    return
            Holder.__name__ = "PowerUpHostFromStandByRequestType_Holder"
            self.pyclass = Holder

    class QueryMemoryOverheadRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryMemoryOverheadRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryMemoryOverheadRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memorySize"), aname="_memorySize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"videoRamSize"), aname="_videoRamSize", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numVcpus"), aname="_numVcpus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._memorySize = None
                    self._videoRamSize = None
                    self._numVcpus = None
                    return
            Holder.__name__ = "QueryMemoryOverheadRequestType_Holder"
            self.pyclass = Holder

    class QueryMemoryOverheadExRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryMemoryOverheadExRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryMemoryOverheadExRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConfigInfo",lazy=True)(pname=(ns,"vmConfigInfo"), aname="_vmConfigInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vmConfigInfo = None
                    return
            Holder.__name__ = "QueryMemoryOverheadExRequestType_Holder"
            self.pyclass = Holder

    class ReconfigureHostForDASRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureHostForDASRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureHostForDASRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ReconfigureHostForDASRequestType_Holder"
            self.pyclass = Holder

    class UpdateFlagsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateFlagsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateFlagsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFlagInfo",lazy=True)(pname=(ns,"flagInfo"), aname="_flagInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._flagInfo = None
                    return
            Holder.__name__ = "UpdateFlagsRequestType_Holder"
            self.pyclass = Holder

    class AcquireCimServicesTicketRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AcquireCimServicesTicketRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AcquireCimServicesTicketRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "AcquireCimServicesTicketRequestType_Holder"
            self.pyclass = Holder

    class KeyValue_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "KeyValue")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.KeyValue_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.KeyValue_Def.__bases__:
                bases = list(ns0.KeyValue_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.KeyValue_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfKeyValue_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfKeyValue")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfKeyValue_Def.schema
            TClist = [GTD("urn:vim25","KeyValue",lazy=True)(pname=(ns,"KeyValue"), aname="_KeyValue", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._KeyValue = []
                    return
            Holder.__name__ = "ArrayOfKeyValue_Holder"
            self.pyclass = Holder

    class LicenseManagerState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LicenseManagerState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class LicenseManagerLicenseKey_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LicenseManagerLicenseKey")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class LicenseSource_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseSource")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseSource_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.LicenseSource_Def.__bases__:
                bases = list(ns0.LicenseSource_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.LicenseSource_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseServerSource_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseServerSource")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseServerSource_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"licenseServer"), aname="_licenseServer", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseSource_Def not in ns0.LicenseServerSource_Def.__bases__:
                bases = list(ns0.LicenseServerSource_Def.__bases__)
                bases.insert(0, ns0.LicenseSource_Def)
                ns0.LicenseServerSource_Def.__bases__ = tuple(bases)

            ns0.LicenseSource_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LocalLicenseSource_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LocalLicenseSource")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LocalLicenseSource_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"licenseKeys"), aname="_licenseKeys", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseSource_Def not in ns0.LocalLicenseSource_Def.__bases__:
                bases = list(ns0.LocalLicenseSource_Def.__bases__)
                bases.insert(0, ns0.LicenseSource_Def)
                ns0.LocalLicenseSource_Def.__bases__ = tuple(bases)

            ns0.LicenseSource_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EvaluationLicenseSource_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EvaluationLicenseSource")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EvaluationLicenseSource_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"remainingHours"), aname="_remainingHours", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseSource_Def not in ns0.EvaluationLicenseSource_Def.__bases__:
                bases = list(ns0.EvaluationLicenseSource_Def.__bases__)
                bases.insert(0, ns0.LicenseSource_Def)
                ns0.EvaluationLicenseSource_Def.__bases__ = tuple(bases)

            ns0.LicenseSource_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseFeatureInfoUnit_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LicenseFeatureInfoUnit")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class LicenseFeatureInfoState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LicenseFeatureInfoState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class LicenseFeatureInfoSourceRestriction_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LicenseFeatureInfoSourceRestriction")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class LicenseFeatureInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseFeatureInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseFeatureInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"featureName"), aname="_featureName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"featureDescription"), aname="_featureDescription", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LicenseFeatureInfoState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"costUnit"), aname="_costUnit", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sourceRestriction"), aname="_sourceRestriction", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"dependentKey"), aname="_dependentKey", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"edition"), aname="_edition", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"expiresOn"), aname="_expiresOn", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.LicenseFeatureInfo_Def.__bases__:
                bases = list(ns0.LicenseFeatureInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.LicenseFeatureInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfLicenseFeatureInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfLicenseFeatureInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfLicenseFeatureInfo_Def.schema
            TClist = [GTD("urn:vim25","LicenseFeatureInfo",lazy=True)(pname=(ns,"LicenseFeatureInfo"), aname="_LicenseFeatureInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._LicenseFeatureInfo = []
                    return
            Holder.__name__ = "ArrayOfLicenseFeatureInfo_Holder"
            self.pyclass = Holder

    class LicenseReservationInfoState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LicenseReservationInfoState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class LicenseReservationInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseReservationInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseReservationInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LicenseReservationInfoState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"required"), aname="_required", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.LicenseReservationInfo_Def.__bases__:
                bases = list(ns0.LicenseReservationInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.LicenseReservationInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfLicenseReservationInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfLicenseReservationInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfLicenseReservationInfo_Def.schema
            TClist = [GTD("urn:vim25","LicenseReservationInfo",lazy=True)(pname=(ns,"LicenseReservationInfo"), aname="_LicenseReservationInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._LicenseReservationInfo = []
                    return
            Holder.__name__ = "ArrayOfLicenseReservationInfo_Holder"
            self.pyclass = Holder

    class LicenseAvailabilityInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseAvailabilityInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseAvailabilityInfo_Def.schema
            TClist = [GTD("urn:vim25","LicenseFeatureInfo",lazy=True)(pname=(ns,"feature"), aname="_feature", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"total"), aname="_total", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"available"), aname="_available", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.LicenseAvailabilityInfo_Def.__bases__:
                bases = list(ns0.LicenseAvailabilityInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.LicenseAvailabilityInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfLicenseAvailabilityInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfLicenseAvailabilityInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfLicenseAvailabilityInfo_Def.schema
            TClist = [GTD("urn:vim25","LicenseAvailabilityInfo",lazy=True)(pname=(ns,"LicenseAvailabilityInfo"), aname="_LicenseAvailabilityInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._LicenseAvailabilityInfo = []
                    return
            Holder.__name__ = "ArrayOfLicenseAvailabilityInfo_Holder"
            self.pyclass = Holder

    class LicenseDiagnostics_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseDiagnostics")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseDiagnostics_Def.schema
            TClist = [ZSI.TCtimes.gDateTime(pname=(ns,"sourceLastChanged"), aname="_sourceLastChanged", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sourceLost"), aname="_sourceLost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.FPfloat(pname=(ns,"sourceLatency"), aname="_sourceLatency", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"licenseRequests"), aname="_licenseRequests", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"licenseRequestFailures"), aname="_licenseRequestFailures", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"licenseFeatureUnknowns"), aname="_licenseFeatureUnknowns", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LicenseManagerState",lazy=True)(pname=(ns,"opState"), aname="_opState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"lastStatusUpdate"), aname="_lastStatusUpdate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"opFailureMessage"), aname="_opFailureMessage", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.LicenseDiagnostics_Def.__bases__:
                bases = list(ns0.LicenseDiagnostics_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.LicenseDiagnostics_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseUsageInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseUsageInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseUsageInfo_Def.schema
            TClist = [GTD("urn:vim25","LicenseSource",lazy=True)(pname=(ns,"source"), aname="_source", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sourceAvailable"), aname="_sourceAvailable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LicenseReservationInfo",lazy=True)(pname=(ns,"reservationInfo"), aname="_reservationInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LicenseFeatureInfo",lazy=True)(pname=(ns,"featureInfo"), aname="_featureInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.LicenseUsageInfo_Def.__bases__:
                bases = list(ns0.LicenseUsageInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.LicenseUsageInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class QuerySupportedFeaturesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QuerySupportedFeaturesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QuerySupportedFeaturesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "QuerySupportedFeaturesRequestType_Holder"
            self.pyclass = Holder

    class QueryLicenseSourceAvailabilityRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryLicenseSourceAvailabilityRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryLicenseSourceAvailabilityRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "QueryLicenseSourceAvailabilityRequestType_Holder"
            self.pyclass = Holder

    class QueryLicenseUsageRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryLicenseUsageRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryLicenseUsageRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "QueryLicenseUsageRequestType_Holder"
            self.pyclass = Holder

    class SetLicenseEditionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetLicenseEditionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetLicenseEditionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"featureKey"), aname="_featureKey", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    self._featureKey = None
                    return
            Holder.__name__ = "SetLicenseEditionRequestType_Holder"
            self.pyclass = Holder

    class CheckLicenseFeatureRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CheckLicenseFeatureRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CheckLicenseFeatureRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"featureKey"), aname="_featureKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    self._featureKey = None
                    return
            Holder.__name__ = "CheckLicenseFeatureRequestType_Holder"
            self.pyclass = Holder

    class EnableFeatureRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "EnableFeatureRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.EnableFeatureRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"featureKey"), aname="_featureKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    self._featureKey = None
                    return
            Holder.__name__ = "EnableFeatureRequestType_Holder"
            self.pyclass = Holder

    class DisableFeatureRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DisableFeatureRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DisableFeatureRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"featureKey"), aname="_featureKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    self._featureKey = None
                    return
            Holder.__name__ = "DisableFeatureRequestType_Holder"
            self.pyclass = Holder

    class ConfigureLicenseSourceRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ConfigureLicenseSourceRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ConfigureLicenseSourceRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LicenseSource",lazy=True)(pname=(ns,"licenseSource"), aname="_licenseSource", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    self._licenseSource = None
                    return
            Holder.__name__ = "ConfigureLicenseSourceRequestType_Holder"
            self.pyclass = Holder

    class ManagedEntityStatus_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ManagedEntityStatus")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ReloadRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReloadRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReloadRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ReloadRequestType_Holder"
            self.pyclass = Holder

    class RenameRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RenameRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RenameRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._newName = None
                    return
            Holder.__name__ = "RenameRequestType_Holder"
            self.pyclass = Holder

    class DestroyRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DestroyRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DestroyRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DestroyRequestType_Holder"
            self.pyclass = Holder

    class MethodDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MethodDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MethodDescription_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Description_Def not in ns0.MethodDescription_Def.__bases__:
                bases = list(ns0.MethodDescription_Def.__bases__)
                bases.insert(0, ns0.Description_Def)
                ns0.MethodDescription_Def.__bases__ = tuple(bases)

            ns0.Description_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NetworkSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NetworkSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NetworkSummary_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"network"), aname="_network", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"accessible"), aname="_accessible", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.NetworkSummary_Def.__bases__:
                bases = list(ns0.NetworkSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.NetworkSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DestroyNetworkRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DestroyNetworkRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DestroyNetworkRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DestroyNetworkRequestType_Holder"
            self.pyclass = Holder

    class PerformanceDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerformanceDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerformanceDescription_Def.schema
            TClist = [GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"counterType"), aname="_counterType", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"statsType"), aname="_statsType", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerformanceDescription_Def.__bases__:
                bases = list(ns0.PerformanceDescription_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerformanceDescription_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PerfFormat_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PerfFormat")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class PerfProviderSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfProviderSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfProviderSummary_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"currentSupported"), aname="_currentSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"summarySupported"), aname="_summarySupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"refreshRate"), aname="_refreshRate", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfProviderSummary_Def.__bases__:
                bases = list(ns0.PerfProviderSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfProviderSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PerfSummaryType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PerfSummaryType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class PerfStatsType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PerfStatsType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class PerformanceManagerUnit_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PerformanceManagerUnit")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class PerfCounterInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfCounterInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfCounterInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"nameInfo"), aname="_nameInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"groupInfo"), aname="_groupInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"unitInfo"), aname="_unitInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfSummaryType",lazy=True)(pname=(ns,"rollupType"), aname="_rollupType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfStatsType",lazy=True)(pname=(ns,"statsType"), aname="_statsType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"level"), aname="_level", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"associatedCounterId"), aname="_associatedCounterId", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfCounterInfo_Def.__bases__:
                bases = list(ns0.PerfCounterInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfCounterInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfCounterInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfCounterInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfCounterInfo_Def.schema
            TClist = [GTD("urn:vim25","PerfCounterInfo",lazy=True)(pname=(ns,"PerfCounterInfo"), aname="_PerfCounterInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfCounterInfo = []
                    return
            Holder.__name__ = "ArrayOfPerfCounterInfo_Holder"
            self.pyclass = Holder

    class PerfMetricId_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfMetricId")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfMetricId_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"counterId"), aname="_counterId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"instance"), aname="_instance", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfMetricId_Def.__bases__:
                bases = list(ns0.PerfMetricId_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfMetricId_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfMetricId_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfMetricId")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfMetricId_Def.schema
            TClist = [GTD("urn:vim25","PerfMetricId",lazy=True)(pname=(ns,"PerfMetricId"), aname="_PerfMetricId", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfMetricId = []
                    return
            Holder.__name__ = "ArrayOfPerfMetricId_Holder"
            self.pyclass = Holder

    class PerfQuerySpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfQuerySpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfQuerySpec_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"startTime"), aname="_startTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"endTime"), aname="_endTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxSample"), aname="_maxSample", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfMetricId",lazy=True)(pname=(ns,"metricId"), aname="_metricId", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"intervalId"), aname="_intervalId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"format"), aname="_format", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfQuerySpec_Def.__bases__:
                bases = list(ns0.PerfQuerySpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfQuerySpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfQuerySpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfQuerySpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfQuerySpec_Def.schema
            TClist = [GTD("urn:vim25","PerfQuerySpec",lazy=True)(pname=(ns,"PerfQuerySpec"), aname="_PerfQuerySpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfQuerySpec = []
                    return
            Holder.__name__ = "ArrayOfPerfQuerySpec_Holder"
            self.pyclass = Holder

    class PerfSampleInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfSampleInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfSampleInfo_Def.schema
            TClist = [ZSI.TCtimes.gDateTime(pname=(ns,"timestamp"), aname="_timestamp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"interval"), aname="_interval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfSampleInfo_Def.__bases__:
                bases = list(ns0.PerfSampleInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfSampleInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfSampleInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfSampleInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfSampleInfo_Def.schema
            TClist = [GTD("urn:vim25","PerfSampleInfo",lazy=True)(pname=(ns,"PerfSampleInfo"), aname="_PerfSampleInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfSampleInfo = []
                    return
            Holder.__name__ = "ArrayOfPerfSampleInfo_Holder"
            self.pyclass = Holder

    class PerfMetricSeries_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfMetricSeries")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfMetricSeries_Def.schema
            TClist = [GTD("urn:vim25","PerfMetricId",lazy=True)(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfMetricSeries_Def.__bases__:
                bases = list(ns0.PerfMetricSeries_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfMetricSeries_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfMetricSeries_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfMetricSeries")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfMetricSeries_Def.schema
            TClist = [GTD("urn:vim25","PerfMetricSeries",lazy=True)(pname=(ns,"PerfMetricSeries"), aname="_PerfMetricSeries", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfMetricSeries = []
                    return
            Holder.__name__ = "ArrayOfPerfMetricSeries_Holder"
            self.pyclass = Holder

    class PerfMetricIntSeries_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfMetricIntSeries")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfMetricIntSeries_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"value"), aname="_value", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PerfMetricSeries_Def not in ns0.PerfMetricIntSeries_Def.__bases__:
                bases = list(ns0.PerfMetricIntSeries_Def.__bases__)
                bases.insert(0, ns0.PerfMetricSeries_Def)
                ns0.PerfMetricIntSeries_Def.__bases__ = tuple(bases)

            ns0.PerfMetricSeries_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PerfMetricSeriesCSV_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfMetricSeriesCSV")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfMetricSeriesCSV_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PerfMetricSeries_Def not in ns0.PerfMetricSeriesCSV_Def.__bases__:
                bases = list(ns0.PerfMetricSeriesCSV_Def.__bases__)
                bases.insert(0, ns0.PerfMetricSeries_Def)
                ns0.PerfMetricSeriesCSV_Def.__bases__ = tuple(bases)

            ns0.PerfMetricSeries_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfMetricSeriesCSV_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfMetricSeriesCSV")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfMetricSeriesCSV_Def.schema
            TClist = [GTD("urn:vim25","PerfMetricSeriesCSV",lazy=True)(pname=(ns,"PerfMetricSeriesCSV"), aname="_PerfMetricSeriesCSV", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfMetricSeriesCSV = []
                    return
            Holder.__name__ = "ArrayOfPerfMetricSeriesCSV_Holder"
            self.pyclass = Holder

    class PerfEntityMetricBase_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfEntityMetricBase")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfEntityMetricBase_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfEntityMetricBase_Def.__bases__:
                bases = list(ns0.PerfEntityMetricBase_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfEntityMetricBase_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfEntityMetricBase_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfEntityMetricBase")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfEntityMetricBase_Def.schema
            TClist = [GTD("urn:vim25","PerfEntityMetricBase",lazy=True)(pname=(ns,"PerfEntityMetricBase"), aname="_PerfEntityMetricBase", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfEntityMetricBase = []
                    return
            Holder.__name__ = "ArrayOfPerfEntityMetricBase_Holder"
            self.pyclass = Holder

    class PerfEntityMetric_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfEntityMetric")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfEntityMetric_Def.schema
            TClist = [GTD("urn:vim25","PerfSampleInfo",lazy=True)(pname=(ns,"sampleInfo"), aname="_sampleInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfMetricSeries",lazy=True)(pname=(ns,"value"), aname="_value", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PerfEntityMetricBase_Def not in ns0.PerfEntityMetric_Def.__bases__:
                bases = list(ns0.PerfEntityMetric_Def.__bases__)
                bases.insert(0, ns0.PerfEntityMetricBase_Def)
                ns0.PerfEntityMetric_Def.__bases__ = tuple(bases)

            ns0.PerfEntityMetricBase_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PerfEntityMetricCSV_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfEntityMetricCSV")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfEntityMetricCSV_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"sampleInfoCSV"), aname="_sampleInfoCSV", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfMetricSeriesCSV",lazy=True)(pname=(ns,"value"), aname="_value", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PerfEntityMetricBase_Def not in ns0.PerfEntityMetricCSV_Def.__bases__:
                bases = list(ns0.PerfEntityMetricCSV_Def.__bases__)
                bases.insert(0, ns0.PerfEntityMetricBase_Def)
                ns0.PerfEntityMetricCSV_Def.__bases__ = tuple(bases)

            ns0.PerfEntityMetricBase_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfEntityMetricCSV_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfEntityMetricCSV")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfEntityMetricCSV_Def.schema
            TClist = [GTD("urn:vim25","PerfEntityMetricCSV",lazy=True)(pname=(ns,"PerfEntityMetricCSV"), aname="_PerfEntityMetricCSV", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfEntityMetricCSV = []
                    return
            Holder.__name__ = "ArrayOfPerfEntityMetricCSV_Holder"
            self.pyclass = Holder

    class PerfCompositeMetric_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfCompositeMetric")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfCompositeMetric_Def.schema
            TClist = [GTD("urn:vim25","PerfEntityMetricBase",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfEntityMetricBase",lazy=True)(pname=(ns,"childEntity"), aname="_childEntity", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfCompositeMetric_Def.__bases__:
                bases = list(ns0.PerfCompositeMetric_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfCompositeMetric_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class QueryPerfProviderSummaryRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryPerfProviderSummaryRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryPerfProviderSummaryRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    return
            Holder.__name__ = "QueryPerfProviderSummaryRequestType_Holder"
            self.pyclass = Holder

    class QueryAvailablePerfMetricRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryAvailablePerfMetricRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryAvailablePerfMetricRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"beginTime"), aname="_beginTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"endTime"), aname="_endTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"intervalId"), aname="_intervalId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._beginTime = None
                    self._endTime = None
                    self._intervalId = None
                    return
            Holder.__name__ = "QueryAvailablePerfMetricRequestType_Holder"
            self.pyclass = Holder

    class QueryPerfCounterRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryPerfCounterRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryPerfCounterRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"counterId"), aname="_counterId", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._counterId = []
                    return
            Holder.__name__ = "QueryPerfCounterRequestType_Holder"
            self.pyclass = Holder

    class QueryPerfCounterByLevelRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryPerfCounterByLevelRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryPerfCounterByLevelRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"level"), aname="_level", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._level = None
                    return
            Holder.__name__ = "QueryPerfCounterByLevelRequestType_Holder"
            self.pyclass = Holder

    class QueryPerfRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryPerfRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryPerfRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfQuerySpec",lazy=True)(pname=(ns,"querySpec"), aname="_querySpec", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._querySpec = []
                    return
            Holder.__name__ = "QueryPerfRequestType_Holder"
            self.pyclass = Holder

    class QueryPerfCompositeRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryPerfCompositeRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryPerfCompositeRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfQuerySpec",lazy=True)(pname=(ns,"querySpec"), aname="_querySpec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._querySpec = None
                    return
            Holder.__name__ = "QueryPerfCompositeRequestType_Holder"
            self.pyclass = Holder

    class CreatePerfIntervalRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreatePerfIntervalRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreatePerfIntervalRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfInterval",lazy=True)(pname=(ns,"intervalId"), aname="_intervalId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._intervalId = None
                    return
            Holder.__name__ = "CreatePerfIntervalRequestType_Holder"
            self.pyclass = Holder

    class RemovePerfIntervalRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemovePerfIntervalRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemovePerfIntervalRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"samplePeriod"), aname="_samplePeriod", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._samplePeriod = None
                    return
            Holder.__name__ = "RemovePerfIntervalRequestType_Holder"
            self.pyclass = Holder

    class UpdatePerfIntervalRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdatePerfIntervalRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdatePerfIntervalRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfInterval",lazy=True)(pname=(ns,"interval"), aname="_interval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._interval = None
                    return
            Holder.__name__ = "UpdatePerfIntervalRequestType_Holder"
            self.pyclass = Holder

    class PerfInterval_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PerfInterval")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PerfInterval_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"samplingPeriod"), aname="_samplingPeriod", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"length"), aname="_length", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"level"), aname="_level", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PerfInterval_Def.__bases__:
                bases = list(ns0.PerfInterval_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PerfInterval_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPerfInterval_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPerfInterval")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPerfInterval_Def.schema
            TClist = [GTD("urn:vim25","PerfInterval",lazy=True)(pname=(ns,"PerfInterval"), aname="_PerfInterval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PerfInterval = []
                    return
            Holder.__name__ = "ArrayOfPerfInterval_Holder"
            self.pyclass = Holder

    class PrivilegePolicyDef_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PrivilegePolicyDef")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PrivilegePolicyDef_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"createPrivilege"), aname="_createPrivilege", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"readPrivilege"), aname="_readPrivilege", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"updatePrivilege"), aname="_updatePrivilege", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"deletePrivilege"), aname="_deletePrivilege", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PrivilegePolicyDef_Def.__bases__:
                bases = list(ns0.PrivilegePolicyDef_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PrivilegePolicyDef_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ProxyServiceAccessMode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ProxyServiceAccessMode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ResourceAllocationInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourceAllocationInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourceAllocationInfo_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"reservation"), aname="_reservation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"expandableReservation"), aname="_expandableReservation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"limit"), aname="_limit", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","SharesInfo",lazy=True)(pname=(ns,"shares"), aname="_shares", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"overheadLimit"), aname="_overheadLimit", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ResourceAllocationInfo_Def.__bases__:
                bases = list(ns0.ResourceAllocationInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ResourceAllocationInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourceConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourceConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourceConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"changeVersion"), aname="_changeVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"lastModified"), aname="_lastModified", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceAllocationInfo",lazy=True)(pname=(ns,"cpuAllocation"), aname="_cpuAllocation", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceAllocationInfo",lazy=True)(pname=(ns,"memoryAllocation"), aname="_memoryAllocation", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ResourceConfigSpec_Def.__bases__:
                bases = list(ns0.ResourceConfigSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ResourceConfigSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfResourceConfigSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfResourceConfigSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfResourceConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ResourceConfigSpec",lazy=True)(pname=(ns,"ResourceConfigSpec"), aname="_ResourceConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ResourceConfigSpec = []
                    return
            Holder.__name__ = "ArrayOfResourceConfigSpec_Holder"
            self.pyclass = Holder

    class ResourcePoolResourceUsage_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolResourceUsage")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolResourceUsage_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"reservationUsed"), aname="_reservationUsed", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"reservationUsedForVm"), aname="_reservationUsedForVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"unreservedForPool"), aname="_unreservedForPool", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"unreservedForVm"), aname="_unreservedForVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"overallUsage"), aname="_overallUsage", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"maxUsage"), aname="_maxUsage", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ResourcePoolResourceUsage_Def.__bases__:
                bases = list(ns0.ResourcePoolResourceUsage_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ResourcePoolResourceUsage_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolRuntimeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolRuntimeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolRuntimeInfo_Def.schema
            TClist = [GTD("urn:vim25","ResourcePoolResourceUsage",lazy=True)(pname=(ns,"memory"), aname="_memory", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourcePoolResourceUsage",lazy=True)(pname=(ns,"cpu"), aname="_cpu", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityStatus",lazy=True)(pname=(ns,"overallStatus"), aname="_overallStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ResourcePoolRuntimeInfo_Def.__bases__:
                bases = list(ns0.ResourcePoolRuntimeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ResourcePoolRuntimeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolSummary_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceConfigSpec",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourcePoolRuntimeInfo",lazy=True)(pname=(ns,"runtime"), aname="_runtime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ResourcePoolSummary_Def.__bases__:
                bases = list(ns0.ResourcePoolSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ResourcePoolSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdateConfigRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateConfigRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateConfigRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceConfigSpec",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._config = None
                    return
            Holder.__name__ = "UpdateConfigRequestType_Holder"
            self.pyclass = Holder

    class MoveIntoResourcePoolRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MoveIntoResourcePoolRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MoveIntoResourcePoolRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"list"), aname="_list", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._list = []
                    return
            Holder.__name__ = "MoveIntoResourcePoolRequestType_Holder"
            self.pyclass = Holder

    class UpdateChildResourceConfigurationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateChildResourceConfigurationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateChildResourceConfigurationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceConfigSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = []
                    return
            Holder.__name__ = "UpdateChildResourceConfigurationRequestType_Holder"
            self.pyclass = Holder

    class CreateResourcePoolRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateResourcePoolRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateResourcePoolRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceConfigSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateResourcePoolRequestType_Holder"
            self.pyclass = Holder

    class DestroyChildrenRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DestroyChildrenRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DestroyChildrenRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DestroyChildrenRequestType_Holder"
            self.pyclass = Holder

    class FindByUuidRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FindByUuidRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FindByUuidRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmSearch"), aname="_vmSearch", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datacenter = None
                    self._uuid = None
                    self._vmSearch = None
                    return
            Holder.__name__ = "FindByUuidRequestType_Holder"
            self.pyclass = Holder

    class FindByDatastorePathRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FindByDatastorePathRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FindByDatastorePathRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datacenter = None
                    self._path = None
                    return
            Holder.__name__ = "FindByDatastorePathRequestType_Holder"
            self.pyclass = Holder

    class FindByDnsNameRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FindByDnsNameRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FindByDnsNameRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"dnsName"), aname="_dnsName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmSearch"), aname="_vmSearch", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datacenter = None
                    self._dnsName = None
                    self._vmSearch = None
                    return
            Holder.__name__ = "FindByDnsNameRequestType_Holder"
            self.pyclass = Holder

    class FindByIpRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FindByIpRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FindByIpRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ip"), aname="_ip", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmSearch"), aname="_vmSearch", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datacenter = None
                    self._ip = None
                    self._vmSearch = None
                    return
            Holder.__name__ = "FindByIpRequestType_Holder"
            self.pyclass = Holder

    class FindByInventoryPathRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FindByInventoryPathRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FindByInventoryPathRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"inventoryPath"), aname="_inventoryPath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._inventoryPath = None
                    return
            Holder.__name__ = "FindByInventoryPathRequestType_Holder"
            self.pyclass = Holder

    class FindChildRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FindChildRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FindChildRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._name = None
                    return
            Holder.__name__ = "FindChildRequestType_Holder"
            self.pyclass = Holder

    class ValidateMigrationTestType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ValidateMigrationTestType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VMotionCompatibilityType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VMotionCompatibilityType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostVMotionCompatibility_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVMotionCompatibility")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVMotionCompatibility_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"compatibility"), aname="_compatibility", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVMotionCompatibility_Def.__bases__:
                bases = list(ns0.HostVMotionCompatibility_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVMotionCompatibility_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostVMotionCompatibility_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostVMotionCompatibility")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostVMotionCompatibility_Def.schema
            TClist = [GTD("urn:vim25","HostVMotionCompatibility",lazy=True)(pname=(ns,"HostVMotionCompatibility"), aname="_HostVMotionCompatibility", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostVMotionCompatibility = []
                    return
            Holder.__name__ = "ArrayOfHostVMotionCompatibility_Holder"
            self.pyclass = Holder

    class ProductComponentInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ProductComponentInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ProductComponentInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"release"), aname="_release", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ProductComponentInfo_Def.__bases__:
                bases = list(ns0.ProductComponentInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ProductComponentInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfProductComponentInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfProductComponentInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfProductComponentInfo_Def.schema
            TClist = [GTD("urn:vim25","ProductComponentInfo",lazy=True)(pname=(ns,"ProductComponentInfo"), aname="_ProductComponentInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ProductComponentInfo = []
                    return
            Holder.__name__ = "ArrayOfProductComponentInfo_Holder"
            self.pyclass = Holder

    class CurrentTimeRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CurrentTimeRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CurrentTimeRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "CurrentTimeRequestType_Holder"
            self.pyclass = Holder

    class RetrieveServiceContentRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveServiceContentRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveServiceContentRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RetrieveServiceContentRequestType_Holder"
            self.pyclass = Holder

    class ValidateMigrationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ValidateMigrationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ValidateMigrationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachinePowerState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"testType"), aname="_testType", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vm = []
                    self._state = None
                    self._testType = []
                    self._pool = None
                    self._host = None
                    return
            Holder.__name__ = "ValidateMigrationRequestType_Holder"
            self.pyclass = Holder

    class QueryVMotionCompatibilityRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryVMotionCompatibilityRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryVMotionCompatibilityRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"compatibility"), aname="_compatibility", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vm = None
                    self._host = []
                    self._compatibility = []
                    return
            Holder.__name__ = "QueryVMotionCompatibilityRequestType_Holder"
            self.pyclass = Holder

    class RetrieveProductComponentsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveProductComponentsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveProductComponentsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RetrieveProductComponentsRequestType_Holder"
            self.pyclass = Holder

    class ServiceContent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ServiceContent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ServiceContent_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"rootFolder"), aname="_rootFolder", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"propertyCollector"), aname="_propertyCollector", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"viewManager"), aname="_viewManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AboutInfo",lazy=True)(pname=(ns,"about"), aname="_about", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"setting"), aname="_setting", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"userDirectory"), aname="_userDirectory", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"sessionManager"), aname="_sessionManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"authorizationManager"), aname="_authorizationManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"perfManager"), aname="_perfManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"scheduledTaskManager"), aname="_scheduledTaskManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"alarmManager"), aname="_alarmManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"eventManager"), aname="_eventManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"taskManager"), aname="_taskManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"extensionManager"), aname="_extensionManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"customizationSpecManager"), aname="_customizationSpecManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"customFieldsManager"), aname="_customFieldsManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"accountManager"), aname="_accountManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"diagnosticManager"), aname="_diagnosticManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"licenseManager"), aname="_licenseManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"searchIndex"), aname="_searchIndex", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"fileManager"), aname="_fileManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"virtualDiskManager"), aname="_virtualDiskManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"virtualizationManager"), aname="_virtualizationManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ServiceContent_Def.__bases__:
                bases = list(ns0.ServiceContent_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ServiceContent_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SessionManagerLocalTicket_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SessionManagerLocalTicket")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SessionManagerLocalTicket_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"passwordFilePath"), aname="_passwordFilePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.SessionManagerLocalTicket_Def.__bases__:
                bases = list(ns0.SessionManagerLocalTicket_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.SessionManagerLocalTicket_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdateServiceMessageRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateServiceMessageRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateServiceMessageRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"message"), aname="_message", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._message = None
                    return
            Holder.__name__ = "UpdateServiceMessageRequestType_Holder"
            self.pyclass = Holder

    class LoginRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LoginRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.LoginRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"password"), aname="_password", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locale"), aname="_locale", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._userName = None
                    self._password = None
                    self._locale = None
                    return
            Holder.__name__ = "LoginRequestType_Holder"
            self.pyclass = Holder

    class LoginBySSPIRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LoginBySSPIRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.LoginBySSPIRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"base64Token"), aname="_base64Token", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locale"), aname="_locale", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._base64Token = None
                    self._locale = None
                    return
            Holder.__name__ = "LoginBySSPIRequestType_Holder"
            self.pyclass = Holder

    class LogoutRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LogoutRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.LogoutRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "LogoutRequestType_Holder"
            self.pyclass = Holder

    class AcquireLocalTicketRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AcquireLocalTicketRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AcquireLocalTicketRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._userName = None
                    return
            Holder.__name__ = "AcquireLocalTicketRequestType_Holder"
            self.pyclass = Holder

    class TerminateSessionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "TerminateSessionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.TerminateSessionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sessionId"), aname="_sessionId", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._sessionId = []
                    return
            Holder.__name__ = "TerminateSessionRequestType_Holder"
            self.pyclass = Holder

    class SetLocaleRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetLocaleRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetLocaleRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locale"), aname="_locale", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._locale = None
                    return
            Holder.__name__ = "SetLocaleRequestType_Holder"
            self.pyclass = Holder

    class ImpersonateUserRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ImpersonateUserRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ImpersonateUserRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locale"), aname="_locale", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._userName = None
                    self._locale = None
                    return
            Holder.__name__ = "ImpersonateUserRequestType_Holder"
            self.pyclass = Holder

    class SessionIsActiveRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SessionIsActiveRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SessionIsActiveRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sessionID"), aname="_sessionID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._sessionID = None
                    self._userName = None
                    return
            Holder.__name__ = "SessionIsActiveRequestType_Holder"
            self.pyclass = Holder

    class UserSession_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserSession")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserSession_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fullName"), aname="_fullName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"loginTime"), aname="_loginTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"lastActiveTime"), aname="_lastActiveTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locale"), aname="_locale", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"messageLocale"), aname="_messageLocale", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.UserSession_Def.__bases__:
                bases = list(ns0.UserSession_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.UserSession_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfUserSession_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfUserSession")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfUserSession_Def.schema
            TClist = [GTD("urn:vim25","UserSession",lazy=True)(pname=(ns,"UserSession"), aname="_UserSession", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._UserSession = []
                    return
            Holder.__name__ = "ArrayOfUserSession_Holder"
            self.pyclass = Holder

    class SharesLevel_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SharesLevel")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class SharesInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SharesInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SharesInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"shares"), aname="_shares", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","SharesLevel",lazy=True)(pname=(ns,"level"), aname="_level", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.SharesInfo_Def.__bases__:
                bases = list(ns0.SharesInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.SharesInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SimpleCommandEncoding_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SimpleCommandEncoding")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class CancelTaskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CancelTaskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CancelTaskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "CancelTaskRequestType_Holder"
            self.pyclass = Holder

    class UpdateProgressRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateProgressRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateProgressRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"percentDone"), aname="_percentDone", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._percentDone = None
                    return
            Holder.__name__ = "UpdateProgressRequestType_Holder"
            self.pyclass = Holder

    class SetTaskStateRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetTaskStateRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetTaskStateRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskInfoState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"result"), aname="_result", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._state = None
                    self._result = None
                    self._fault = None
                    return
            Holder.__name__ = "SetTaskStateRequestType_Holder"
            self.pyclass = Holder

    class TaskDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskDescription_Def.schema
            TClist = [GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"methodInfo"), aname="_methodInfo", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TypeDescription",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskDescription_Def.__bases__:
                bases = list(ns0.TaskDescription_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskDescription_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskFilterSpecRecursionOption_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "TaskFilterSpecRecursionOption")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class TaskFilterSpecTimeOption_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "TaskFilterSpecTimeOption")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class TaskFilterSpecByEntity_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskFilterSpecByEntity")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskFilterSpecByEntity_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskFilterSpecRecursionOption",lazy=True)(pname=(ns,"recursion"), aname="_recursion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskFilterSpecByEntity_Def.__bases__:
                bases = list(ns0.TaskFilterSpecByEntity_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskFilterSpecByEntity_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskFilterSpecByTime_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskFilterSpecByTime")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskFilterSpecByTime_Def.schema
            TClist = [GTD("urn:vim25","TaskFilterSpecTimeOption",lazy=True)(pname=(ns,"timeType"), aname="_timeType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"beginTime"), aname="_beginTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"endTime"), aname="_endTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskFilterSpecByTime_Def.__bases__:
                bases = list(ns0.TaskFilterSpecByTime_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskFilterSpecByTime_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskFilterSpecByUsername_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskFilterSpecByUsername")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskFilterSpecByUsername_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"systemUser"), aname="_systemUser", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userList"), aname="_userList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskFilterSpecByUsername_Def.__bases__:
                bases = list(ns0.TaskFilterSpecByUsername_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskFilterSpecByUsername_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskFilterSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskFilterSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskFilterSpec_Def.schema
            TClist = [GTD("urn:vim25","TaskFilterSpecByEntity",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskFilterSpecByTime",lazy=True)(pname=(ns,"time"), aname="_time", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskFilterSpecByUsername",lazy=True)(pname=(ns,"userName"), aname="_userName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskInfoState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"alarm"), aname="_alarm", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"scheduledTask"), aname="_scheduledTask", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskFilterSpec_Def.__bases__:
                bases = list(ns0.TaskFilterSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskFilterSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReadNextTasksRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReadNextTasksRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReadNextTasksRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxCount"), aname="_maxCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._maxCount = None
                    return
            Holder.__name__ = "ReadNextTasksRequestType_Holder"
            self.pyclass = Holder

    class ReadPreviousTasksRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReadPreviousTasksRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReadPreviousTasksRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxCount"), aname="_maxCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._maxCount = None
                    return
            Holder.__name__ = "ReadPreviousTasksRequestType_Holder"
            self.pyclass = Holder

    class TaskInfoState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "TaskInfoState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ArrayOfTaskInfoState_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfTaskInfoState")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfTaskInfoState_Def.schema
            TClist = [GTD("urn:vim25","TaskInfoState",lazy=True)(pname=(ns,"TaskInfoState"), aname="_TaskInfoState", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._TaskInfoState = []
                    return
            Holder.__name__ = "ArrayOfTaskInfoState_Holder"
            self.pyclass = Holder

    class TaskInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"task"), aname="_task", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"descriptionId"), aname="_descriptionId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"entityName"), aname="_entityName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"locked"), aname="_locked", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskInfoState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"cancelled"), aname="_cancelled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"cancelable"), aname="_cancelable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"error"), aname="_error", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"result"), aname="_result", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"progress"), aname="_progress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskReason",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"queueTime"), aname="_queueTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"startTime"), aname="_startTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"completeTime"), aname="_completeTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"eventChainId"), aname="_eventChainId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskInfo_Def.__bases__:
                bases = list(ns0.TaskInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfTaskInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfTaskInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfTaskInfo_Def.schema
            TClist = [GTD("urn:vim25","TaskInfo",lazy=True)(pname=(ns,"TaskInfo"), aname="_TaskInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._TaskInfo = []
                    return
            Holder.__name__ = "ArrayOfTaskInfo_Holder"
            self.pyclass = Holder

    class CreateCollectorForTasksRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateCollectorForTasksRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateCollectorForTasksRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskFilterSpec",lazy=True)(pname=(ns,"filter"), aname="_filter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._filter = None
                    return
            Holder.__name__ = "CreateCollectorForTasksRequestType_Holder"
            self.pyclass = Holder

    class CreateTaskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateTaskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateTaskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"taskTypeId"), aname="_taskTypeId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"initiatedBy"), aname="_initiatedBy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"cancelable"), aname="_cancelable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._obj = None
                    self._taskTypeId = None
                    self._initiatedBy = None
                    self._cancelable = None
                    return
            Holder.__name__ = "CreateTaskRequestType_Holder"
            self.pyclass = Holder

    class TaskReason_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskReason")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskReason_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskReason_Def.__bases__:
                bases = list(ns0.TaskReason_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskReason_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskReasonSystem_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskReasonSystem")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskReasonSystem_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskReason_Def not in ns0.TaskReasonSystem_Def.__bases__:
                bases = list(ns0.TaskReasonSystem_Def.__bases__)
                bases.insert(0, ns0.TaskReason_Def)
                ns0.TaskReasonSystem_Def.__bases__ = tuple(bases)

            ns0.TaskReason_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskReasonUser_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskReasonUser")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskReasonUser_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskReason_Def not in ns0.TaskReasonUser_Def.__bases__:
                bases = list(ns0.TaskReasonUser_Def.__bases__)
                bases.insert(0, ns0.TaskReason_Def)
                ns0.TaskReasonUser_Def.__bases__ = tuple(bases)

            ns0.TaskReason_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskReasonAlarm_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskReasonAlarm")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskReasonAlarm_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"alarmName"), aname="_alarmName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"alarm"), aname="_alarm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"entityName"), aname="_entityName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskReason_Def not in ns0.TaskReasonAlarm_Def.__bases__:
                bases = list(ns0.TaskReasonAlarm_Def.__bases__)
                bases.insert(0, ns0.TaskReason_Def)
                ns0.TaskReasonAlarm_Def.__bases__ = tuple(bases)

            ns0.TaskReason_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskReasonSchedule_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskReasonSchedule")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskReasonSchedule_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"scheduledTask"), aname="_scheduledTask", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskReason_Def not in ns0.TaskReasonSchedule_Def.__bases__:
                bases = list(ns0.TaskReasonSchedule_Def.__bases__)
                bases.insert(0, ns0.TaskReason_Def)
                ns0.TaskReasonSchedule_Def.__bases__ = tuple(bases)

            ns0.TaskReason_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TypeDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TypeDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TypeDescription_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Description_Def not in ns0.TypeDescription_Def.__bases__:
                bases = list(ns0.TypeDescription_Def.__bases__)
                bases.insert(0, ns0.Description_Def)
                ns0.TypeDescription_Def.__bases__ = tuple(bases)

            ns0.Description_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfTypeDescription_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfTypeDescription")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfTypeDescription_Def.schema
            TClist = [GTD("urn:vim25","TypeDescription",lazy=True)(pname=(ns,"TypeDescription"), aname="_TypeDescription", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._TypeDescription = []
                    return
            Holder.__name__ = "ArrayOfTypeDescription_Holder"
            self.pyclass = Holder

    class RetrieveUserGroupsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveUserGroupsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveUserGroupsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"domain"), aname="_domain", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"searchStr"), aname="_searchStr", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"belongsToGroup"), aname="_belongsToGroup", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"belongsToUser"), aname="_belongsToUser", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"exactMatch"), aname="_exactMatch", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"findUsers"), aname="_findUsers", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"findGroups"), aname="_findGroups", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._domain = None
                    self._searchStr = None
                    self._belongsToGroup = None
                    self._belongsToUser = None
                    self._exactMatch = None
                    self._findUsers = None
                    self._findGroups = None
                    return
            Holder.__name__ = "RetrieveUserGroupsRequestType_Holder"
            self.pyclass = Holder

    class UserSearchResult_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserSearchResult")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserSearchResult_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"principal"), aname="_principal", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fullName"), aname="_fullName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.UserSearchResult_Def.__bases__:
                bases = list(ns0.UserSearchResult_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.UserSearchResult_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfUserSearchResult_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfUserSearchResult")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfUserSearchResult_Def.schema
            TClist = [GTD("urn:vim25","UserSearchResult",lazy=True)(pname=(ns,"UserSearchResult"), aname="_UserSearchResult", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._UserSearchResult = []
                    return
            Holder.__name__ = "ArrayOfUserSearchResult_Holder"
            self.pyclass = Holder

    class PosixUserSearchResult_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PosixUserSearchResult")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PosixUserSearchResult_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"shellAccess"), aname="_shellAccess", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.UserSearchResult_Def not in ns0.PosixUserSearchResult_Def.__bases__:
                bases = list(ns0.PosixUserSearchResult_Def.__bases__)
                bases.insert(0, ns0.UserSearchResult_Def)
                ns0.PosixUserSearchResult_Def.__bases__ = tuple(bases)

            ns0.UserSearchResult_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualDiskType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualDiskAdapterType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualDiskAdapterType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualDiskSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskType"), aname="_diskType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"adapterType"), aname="_adapterType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDiskSpec_Def.__bases__:
                bases = list(ns0.VirtualDiskSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDiskSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileBackedVirtualDiskSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileBackedVirtualDiskSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileBackedVirtualDiskSpec_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"capacityKb"), aname="_capacityKb", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDiskSpec_Def not in ns0.FileBackedVirtualDiskSpec_Def.__bases__:
                bases = list(ns0.FileBackedVirtualDiskSpec_Def.__bases__)
                bases.insert(0, ns0.VirtualDiskSpec_Def)
                ns0.FileBackedVirtualDiskSpec_Def.__bases__ = tuple(bases)

            ns0.VirtualDiskSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DeviceBackedVirtualDiskSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DeviceBackedVirtualDiskSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DeviceBackedVirtualDiskSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDiskSpec_Def not in ns0.DeviceBackedVirtualDiskSpec_Def.__bases__:
                bases = list(ns0.DeviceBackedVirtualDiskSpec_Def.__bases__)
                bases.insert(0, ns0.VirtualDiskSpec_Def)
                ns0.DeviceBackedVirtualDiskSpec_Def.__bases__ = tuple(bases)

            ns0.VirtualDiskSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CreateVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDiskSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class DeleteVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DeleteVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DeleteVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "DeleteVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class MoveVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MoveVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MoveVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sourceName"), aname="_sourceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"sourceDatacenter"), aname="_sourceDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"destName"), aname="_destName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"destDatacenter"), aname="_destDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._sourceName = None
                    self._sourceDatacenter = None
                    self._destName = None
                    self._destDatacenter = None
                    self._force = None
                    return
            Holder.__name__ = "MoveVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class CopyVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CopyVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CopyVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sourceName"), aname="_sourceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"sourceDatacenter"), aname="_sourceDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"destName"), aname="_destName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"destDatacenter"), aname="_destDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDiskSpec",lazy=True)(pname=(ns,"destSpec"), aname="_destSpec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._sourceName = None
                    self._sourceDatacenter = None
                    self._destName = None
                    self._destDatacenter = None
                    self._destSpec = None
                    self._force = None
                    return
            Holder.__name__ = "CopyVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class ExtendVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ExtendVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ExtendVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"newCapacityKb"), aname="_newCapacityKb", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    self._newCapacityKb = None
                    return
            Holder.__name__ = "ExtendVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class QueryVirtualDiskFragmentationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryVirtualDiskFragmentationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryVirtualDiskFragmentationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "QueryVirtualDiskFragmentationRequestType_Holder"
            self.pyclass = Holder

    class DefragmentVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DefragmentVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DefragmentVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "DefragmentVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class ShrinkVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ShrinkVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ShrinkVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"copy"), aname="_copy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    self._copy = None
                    return
            Holder.__name__ = "ShrinkVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class InflateVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "InflateVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.InflateVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "InflateVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class ZeroFillVirtualDiskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ZeroFillVirtualDiskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ZeroFillVirtualDiskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "ZeroFillVirtualDiskRequestType_Holder"
            self.pyclass = Holder

    class SetVirtualDiskUuidRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetVirtualDiskUuidRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetVirtualDiskUuidRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    self._uuid = None
                    return
            Holder.__name__ = "SetVirtualDiskUuidRequestType_Holder"
            self.pyclass = Holder

    class QueryVirtualDiskUuidRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryVirtualDiskUuidRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryVirtualDiskUuidRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "QueryVirtualDiskUuidRequestType_Holder"
            self.pyclass = Holder

    class QueryVirtualDiskGeometryRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryVirtualDiskGeometryRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryVirtualDiskGeometryRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._datacenter = None
                    return
            Holder.__name__ = "QueryVirtualDiskGeometryRequestType_Holder"
            self.pyclass = Holder

    class VirtualMachinePowerState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachinePowerState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineConnectionState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConnectionState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineMovePriority_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineMovePriority")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineMksTicket_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineMksTicket")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineMksTicket_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ticket"), aname="_ticket", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"cfgFile"), aname="_cfgFile", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sslThumbprint"), aname="_sslThumbprint", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineMksTicket_Def.__bases__:
                bases = list(ns0.VirtualMachineMksTicket_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineMksTicket_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CreateSnapshotRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateSnapshotRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateSnapshotRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"memory"), aname="_memory", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"quiesce"), aname="_quiesce", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._description = None
                    self._memory = None
                    self._quiesce = None
                    return
            Holder.__name__ = "CreateSnapshotRequestType_Holder"
            self.pyclass = Holder

    class RevertToCurrentSnapshotRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RevertToCurrentSnapshotRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RevertToCurrentSnapshotRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "RevertToCurrentSnapshotRequestType_Holder"
            self.pyclass = Holder

    class RemoveAllSnapshotsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveAllSnapshotsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveAllSnapshotsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RemoveAllSnapshotsRequestType_Holder"
            self.pyclass = Holder

    class ReconfigVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConfigSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "ReconfigVMRequestType_Holder"
            self.pyclass = Holder

    class UpgradeVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpgradeVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpgradeVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._version = None
                    return
            Holder.__name__ = "UpgradeVMRequestType_Holder"
            self.pyclass = Holder

    class PowerOnVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PowerOnVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.PowerOnVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "PowerOnVMRequestType_Holder"
            self.pyclass = Holder

    class PowerOffVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PowerOffVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.PowerOffVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "PowerOffVMRequestType_Holder"
            self.pyclass = Holder

    class SuspendVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SuspendVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SuspendVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "SuspendVMRequestType_Holder"
            self.pyclass = Holder

    class ResetVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ResetVMRequestType_Holder"
            self.pyclass = Holder

    class ShutdownGuestRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ShutdownGuestRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ShutdownGuestRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ShutdownGuestRequestType_Holder"
            self.pyclass = Holder

    class RebootGuestRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RebootGuestRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RebootGuestRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RebootGuestRequestType_Holder"
            self.pyclass = Holder

    class StandbyGuestRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "StandbyGuestRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.StandbyGuestRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "StandbyGuestRequestType_Holder"
            self.pyclass = Holder

    class AnswerVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AnswerVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AnswerVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"questionId"), aname="_questionId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"answerChoice"), aname="_answerChoice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._questionId = None
                    self._answerChoice = None
                    return
            Holder.__name__ = "AnswerVMRequestType_Holder"
            self.pyclass = Holder

    class CustomizeVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CustomizeVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CustomizeVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "CustomizeVMRequestType_Holder"
            self.pyclass = Holder

    class CheckCustomizationSpecRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CheckCustomizationSpecRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CheckCustomizationSpecRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "CheckCustomizationSpecRequestType_Holder"
            self.pyclass = Holder

    class MigrateVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MigrateVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MigrateVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineMovePriority",lazy=True)(pname=(ns,"priority"), aname="_priority", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachinePowerState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._pool = None
                    self._host = None
                    self._priority = None
                    self._state = None
                    return
            Holder.__name__ = "MigrateVMRequestType_Holder"
            self.pyclass = Holder

    class RelocateVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RelocateVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RelocateVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineRelocateSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "RelocateVMRequestType_Holder"
            self.pyclass = Holder

    class CloneVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CloneVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CloneVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"folder"), aname="_folder", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineCloneSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._folder = None
                    self._name = None
                    self._spec = None
                    return
            Holder.__name__ = "CloneVMRequestType_Holder"
            self.pyclass = Holder

    class MarkAsTemplateRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MarkAsTemplateRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MarkAsTemplateRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "MarkAsTemplateRequestType_Holder"
            self.pyclass = Holder

    class MarkAsVirtualMachineRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MarkAsVirtualMachineRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MarkAsVirtualMachineRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._pool = None
                    self._host = None
                    return
            Holder.__name__ = "MarkAsVirtualMachineRequestType_Holder"
            self.pyclass = Holder

    class UnregisterVMRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UnregisterVMRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UnregisterVMRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "UnregisterVMRequestType_Holder"
            self.pyclass = Holder

    class ResetGuestInformationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetGuestInformationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetGuestInformationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ResetGuestInformationRequestType_Holder"
            self.pyclass = Holder

    class MountToolsInstallerRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MountToolsInstallerRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.MountToolsInstallerRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "MountToolsInstallerRequestType_Holder"
            self.pyclass = Holder

    class UnmountToolsInstallerRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UnmountToolsInstallerRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UnmountToolsInstallerRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "UnmountToolsInstallerRequestType_Holder"
            self.pyclass = Holder

    class UpgradeToolsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpgradeToolsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpgradeToolsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"installerOptions"), aname="_installerOptions", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._installerOptions = None
                    return
            Holder.__name__ = "UpgradeToolsRequestType_Holder"
            self.pyclass = Holder

    class AcquireMksTicketRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AcquireMksTicketRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AcquireMksTicketRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "AcquireMksTicketRequestType_Holder"
            self.pyclass = Holder

    class SetScreenResolutionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetScreenResolutionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetScreenResolutionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"width"), aname="_width", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"height"), aname="_height", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._width = None
                    self._height = None
                    return
            Holder.__name__ = "SetScreenResolutionRequestType_Holder"
            self.pyclass = Holder

    class DefragmentAllDisksRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DefragmentAllDisksRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DefragmentAllDisksRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DefragmentAllDisksRequestType_Holder"
            self.pyclass = Holder

    class VirtualizationManagerEntityType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualizationManagerEntityType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualizationManagerCollectionKey_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualizationManagerCollectionKey")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualizationManagerCredentialKey_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualizationManagerCredentialKey")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualizationManagerHealthValue_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualizationManagerHealthValue")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ActionParameter_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ActionParameter")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class Action_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "Action")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.Action_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.Action_Def.__bases__:
                bases = list(ns0.Action_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.Action_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MethodActionArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MethodActionArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MethodActionArgument_Def.schema
            TClist = [ZSI.TC.AnyType(pname=(ns,"value"), aname="_value", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.MethodActionArgument_Def.__bases__:
                bases = list(ns0.MethodActionArgument_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.MethodActionArgument_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfMethodActionArgument_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfMethodActionArgument")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfMethodActionArgument_Def.schema
            TClist = [GTD("urn:vim25","MethodActionArgument",lazy=True)(pname=(ns,"MethodActionArgument"), aname="_MethodActionArgument", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._MethodActionArgument = []
                    return
            Holder.__name__ = "ArrayOfMethodActionArgument_Holder"
            self.pyclass = Holder

    class MethodAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MethodAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MethodAction_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","MethodActionArgument",lazy=True)(pname=(ns,"argument"), aname="_argument", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Action_Def not in ns0.MethodAction_Def.__bases__:
                bases = list(ns0.MethodAction_Def.__bases__)
                bases.insert(0, ns0.Action_Def)
                ns0.MethodAction_Def.__bases__ = tuple(bases)

            ns0.Action_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SendEmailAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SendEmailAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SendEmailAction_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"toList"), aname="_toList", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ccList"), aname="_ccList", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"subject"), aname="_subject", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"body"), aname="_body", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Action_Def not in ns0.SendEmailAction_Def.__bases__:
                bases = list(ns0.SendEmailAction_Def.__bases__)
                bases.insert(0, ns0.Action_Def)
                ns0.SendEmailAction_Def.__bases__ = tuple(bases)

            ns0.Action_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SendSNMPAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SendSNMPAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SendSNMPAction_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Action_Def not in ns0.SendSNMPAction_Def.__bases__:
                bases = list(ns0.SendSNMPAction_Def.__bases__)
                bases.insert(0, ns0.Action_Def)
                ns0.SendSNMPAction_Def.__bases__ = tuple(bases)

            ns0.Action_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RunScriptAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RunScriptAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RunScriptAction_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"script"), aname="_script", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Action_Def not in ns0.RunScriptAction_Def.__bases__:
                bases = list(ns0.RunScriptAction_Def.__bases__)
                bases.insert(0, ns0.Action_Def)
                ns0.RunScriptAction_Def.__bases__ = tuple(bases)

            ns0.Action_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CreateTaskAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CreateTaskAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CreateTaskAction_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"taskTypeId"), aname="_taskTypeId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"cancelable"), aname="_cancelable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Action_Def not in ns0.CreateTaskAction_Def.__bases__:
                bases = list(ns0.CreateTaskAction_Def.__bases__)
                bases.insert(0, ns0.Action_Def)
                ns0.CreateTaskAction_Def.__bases__ = tuple(bases)

            ns0.Action_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RemoveAlarmRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveAlarmRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveAlarmRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RemoveAlarmRequestType_Holder"
            self.pyclass = Holder

    class ReconfigureAlarmRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureAlarmRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureAlarmRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AlarmSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "ReconfigureAlarmRequestType_Holder"
            self.pyclass = Holder

    class AlarmAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmAction_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AlarmAction_Def.__bases__:
                bases = list(ns0.AlarmAction_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AlarmAction_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfAlarmAction_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfAlarmAction")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfAlarmAction_Def.schema
            TClist = [GTD("urn:vim25","AlarmAction",lazy=True)(pname=(ns,"AlarmAction"), aname="_AlarmAction", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._AlarmAction = []
                    return
            Holder.__name__ = "ArrayOfAlarmAction_Holder"
            self.pyclass = Holder

    class AlarmTriggeringAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmTriggeringAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmTriggeringAction_Def.schema
            TClist = [GTD("urn:vim25","Action",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"green2yellow"), aname="_green2yellow", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"yellow2red"), aname="_yellow2red", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"red2yellow"), aname="_red2yellow", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"yellow2green"), aname="_yellow2green", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmAction_Def not in ns0.AlarmTriggeringAction_Def.__bases__:
                bases = list(ns0.AlarmTriggeringAction_Def.__bases__)
                bases.insert(0, ns0.AlarmAction_Def)
                ns0.AlarmTriggeringAction_Def.__bases__ = tuple(bases)

            ns0.AlarmAction_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GroupAlarmAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GroupAlarmAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GroupAlarmAction_Def.schema
            TClist = [GTD("urn:vim25","AlarmAction",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmAction_Def not in ns0.GroupAlarmAction_Def.__bases__:
                bases = list(ns0.GroupAlarmAction_Def.__bases__)
                bases.insert(0, ns0.AlarmAction_Def)
                ns0.GroupAlarmAction_Def.__bases__ = tuple(bases)

            ns0.AlarmAction_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmDescription_Def.schema
            TClist = [GTD("urn:vim25","TypeDescription",lazy=True)(pname=(ns,"expr"), aname="_expr", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"stateOperator"), aname="_stateOperator", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"metricOperator"), aname="_metricOperator", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"hostSystemConnectionState"), aname="_hostSystemConnectionState", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"virtualMachinePowerState"), aname="_virtualMachinePowerState", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"entityStatus"), aname="_entityStatus", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TypeDescription",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AlarmDescription_Def.__bases__:
                bases = list(ns0.AlarmDescription_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AlarmDescription_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmExpression_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmExpression")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmExpression_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AlarmExpression_Def.__bases__:
                bases = list(ns0.AlarmExpression_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AlarmExpression_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfAlarmExpression_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfAlarmExpression")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfAlarmExpression_Def.schema
            TClist = [GTD("urn:vim25","AlarmExpression",lazy=True)(pname=(ns,"AlarmExpression"), aname="_AlarmExpression", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._AlarmExpression = []
                    return
            Holder.__name__ = "ArrayOfAlarmExpression_Holder"
            self.pyclass = Holder

    class AndAlarmExpression_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AndAlarmExpression")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AndAlarmExpression_Def.schema
            TClist = [GTD("urn:vim25","AlarmExpression",lazy=True)(pname=(ns,"expression"), aname="_expression", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmExpression_Def not in ns0.AndAlarmExpression_Def.__bases__:
                bases = list(ns0.AndAlarmExpression_Def.__bases__)
                bases.insert(0, ns0.AlarmExpression_Def)
                ns0.AndAlarmExpression_Def.__bases__ = tuple(bases)

            ns0.AlarmExpression_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class OrAlarmExpression_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "OrAlarmExpression")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.OrAlarmExpression_Def.schema
            TClist = [GTD("urn:vim25","AlarmExpression",lazy=True)(pname=(ns,"expression"), aname="_expression", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmExpression_Def not in ns0.OrAlarmExpression_Def.__bases__:
                bases = list(ns0.OrAlarmExpression_Def.__bases__)
                bases.insert(0, ns0.AlarmExpression_Def)
                ns0.OrAlarmExpression_Def.__bases__ = tuple(bases)

            ns0.AlarmExpression_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class StateAlarmOperator_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "StateAlarmOperator")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class StateAlarmExpression_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "StateAlarmExpression")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.StateAlarmExpression_Def.schema
            TClist = [GTD("urn:vim25","StateAlarmOperator",lazy=True)(pname=(ns,"operator"), aname="_operator", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"statePath"), aname="_statePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"yellow"), aname="_yellow", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"red"), aname="_red", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmExpression_Def not in ns0.StateAlarmExpression_Def.__bases__:
                bases = list(ns0.StateAlarmExpression_Def.__bases__)
                bases.insert(0, ns0.AlarmExpression_Def)
                ns0.StateAlarmExpression_Def.__bases__ = tuple(bases)

            ns0.AlarmExpression_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EventAlarmExpression_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventAlarmExpression")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventAlarmExpression_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"eventType"), aname="_eventType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"eventTypeId"), aname="_eventTypeId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmExpression_Def not in ns0.EventAlarmExpression_Def.__bases__:
                bases = list(ns0.EventAlarmExpression_Def.__bases__)
                bases.insert(0, ns0.AlarmExpression_Def)
                ns0.EventAlarmExpression_Def.__bases__ = tuple(bases)

            ns0.AlarmExpression_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MetricAlarmOperator_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MetricAlarmOperator")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class MetricAlarmExpression_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MetricAlarmExpression")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MetricAlarmExpression_Def.schema
            TClist = [GTD("urn:vim25","MetricAlarmOperator",lazy=True)(pname=(ns,"operator"), aname="_operator", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PerfMetricId",lazy=True)(pname=(ns,"metric"), aname="_metric", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"yellow"), aname="_yellow", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"red"), aname="_red", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmExpression_Def not in ns0.MetricAlarmExpression_Def.__bases__:
                bases = list(ns0.MetricAlarmExpression_Def.__bases__)
                bases.insert(0, ns0.AlarmExpression_Def)
                ns0.MetricAlarmExpression_Def.__bases__ = tuple(bases)

            ns0.AlarmExpression_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"alarm"), aname="_alarm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"lastModifiedTime"), aname="_lastModifiedTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"lastModifiedUser"), aname="_lastModifiedUser", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"creationEventId"), aname="_creationEventId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmSpec_Def not in ns0.AlarmInfo_Def.__bases__:
                bases = list(ns0.AlarmInfo_Def.__bases__)
                bases.insert(0, ns0.AlarmSpec_Def)
                ns0.AlarmInfo_Def.__bases__ = tuple(bases)

            ns0.AlarmSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CreateAlarmRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateAlarmRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateAlarmRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AlarmSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateAlarmRequestType_Holder"
            self.pyclass = Holder

    class GetAlarmRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "GetAlarmRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.GetAlarmRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    return
            Holder.__name__ = "GetAlarmRequestType_Holder"
            self.pyclass = Holder

    class GetAlarmStateRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "GetAlarmStateRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.GetAlarmStateRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    return
            Holder.__name__ = "GetAlarmStateRequestType_Holder"
            self.pyclass = Holder

    class AlarmSetting_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmSetting")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmSetting_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"toleranceRange"), aname="_toleranceRange", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"reportingFrequency"), aname="_reportingFrequency", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AlarmSetting_Def.__bases__:
                bases = list(ns0.AlarmSetting_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AlarmSetting_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AlarmExpression",lazy=True)(pname=(ns,"expression"), aname="_expression", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AlarmAction",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AlarmSetting",lazy=True)(pname=(ns,"setting"), aname="_setting", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AlarmSpec_Def.__bases__:
                bases = list(ns0.AlarmSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AlarmSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmState_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmState")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmState_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"alarm"), aname="_alarm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityStatus",lazy=True)(pname=(ns,"overallStatus"), aname="_overallStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"time"), aname="_time", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AlarmState_Def.__bases__:
                bases = list(ns0.AlarmState_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AlarmState_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfAlarmState_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfAlarmState")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfAlarmState_Def.schema
            TClist = [GTD("urn:vim25","AlarmState",lazy=True)(pname=(ns,"AlarmState"), aname="_AlarmState", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._AlarmState = []
                    return
            Holder.__name__ = "ArrayOfAlarmState_Holder"
            self.pyclass = Holder

    class ActionType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ActionType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterAction_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"target"), aname="_target", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterAction_Def.__bases__:
                bases = list(ns0.ClusterAction_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterAction_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterAction_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterAction")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterAction_Def.schema
            TClist = [GTD("urn:vim25","ClusterAction",lazy=True)(pname=(ns,"ClusterAction"), aname="_ClusterAction", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterAction = []
                    return
            Holder.__name__ = "ArrayOfClusterAction_Holder"
            self.pyclass = Holder

    class ClusterActionHistory_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterActionHistory")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterActionHistory_Def.schema
            TClist = [GTD("urn:vim25","ClusterAction",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"time"), aname="_time", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterActionHistory_Def.__bases__:
                bases = list(ns0.ClusterActionHistory_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterActionHistory_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterActionHistory_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterActionHistory")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterActionHistory_Def.schema
            TClist = [GTD("urn:vim25","ClusterActionHistory",lazy=True)(pname=(ns,"ClusterActionHistory"), aname="_ClusterActionHistory", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterActionHistory = []
                    return
            Holder.__name__ = "ArrayOfClusterActionHistory_Holder"
            self.pyclass = Holder

    class ClusterAttemptedVmInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterAttemptedVmInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterAttemptedVmInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"task"), aname="_task", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterAttemptedVmInfo_Def.__bases__:
                bases = list(ns0.ClusterAttemptedVmInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterAttemptedVmInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterAttemptedVmInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterAttemptedVmInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterAttemptedVmInfo_Def.schema
            TClist = [GTD("urn:vim25","ClusterAttemptedVmInfo",lazy=True)(pname=(ns,"ClusterAttemptedVmInfo"), aname="_ClusterAttemptedVmInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterAttemptedVmInfo = []
                    return
            Holder.__name__ = "ArrayOfClusterAttemptedVmInfo_Holder"
            self.pyclass = Holder

    class ClusterConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ClusterDasConfigInfo",lazy=True)(pname=(ns,"dasConfig"), aname="_dasConfig", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDasVmConfigInfo",lazy=True)(pname=(ns,"dasVmConfig"), aname="_dasVmConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsConfigInfo",lazy=True)(pname=(ns,"drsConfig"), aname="_drsConfig", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsVmConfigInfo",lazy=True)(pname=(ns,"drsVmConfig"), aname="_drsVmConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterRuleInfo",lazy=True)(pname=(ns,"rule"), aname="_rule", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterConfigInfo_Def.__bases__:
                bases = list(ns0.ClusterConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsBehavior_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DrsBehavior")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterDrsConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDrsConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDrsConfigInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DrsBehavior",lazy=True)(pname=(ns,"defaultVmBehavior"), aname="_defaultVmBehavior", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"vmotionRate"), aname="_vmotionRate", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"option"), aname="_option", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDrsConfigInfo_Def.__bases__:
                bases = list(ns0.ClusterDrsConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDrsConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterDrsVmConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDrsVmConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDrsVmConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DrsBehavior",lazy=True)(pname=(ns,"behavior"), aname="_behavior", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDrsVmConfigInfo_Def.__bases__:
                bases = list(ns0.ClusterDrsVmConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDrsVmConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDrsVmConfigInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDrsVmConfigInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDrsVmConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ClusterDrsVmConfigInfo",lazy=True)(pname=(ns,"ClusterDrsVmConfigInfo"), aname="_ClusterDrsVmConfigInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDrsVmConfigInfo = []
                    return
            Holder.__name__ = "ArrayOfClusterDrsVmConfigInfo_Holder"
            self.pyclass = Holder

    class ClusterConfigInfoEx_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterConfigInfoEx")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterConfigInfoEx_Def.schema
            TClist = [GTD("urn:vim25","ClusterDasConfigInfo",lazy=True)(pname=(ns,"dasConfig"), aname="_dasConfig", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDasVmConfigInfo",lazy=True)(pname=(ns,"dasVmConfig"), aname="_dasVmConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsConfigInfo",lazy=True)(pname=(ns,"drsConfig"), aname="_drsConfig", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsVmConfigInfo",lazy=True)(pname=(ns,"drsVmConfig"), aname="_drsVmConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterRuleInfo",lazy=True)(pname=(ns,"rule"), aname="_rule", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDpmConfigInfo",lazy=True)(pname=(ns,"dpmConfigInfo"), aname="_dpmConfigInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDpmHostConfigInfo",lazy=True)(pname=(ns,"dpmHostConfig"), aname="_dpmHostConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ComputeResourceConfigInfo_Def not in ns0.ClusterConfigInfoEx_Def.__bases__:
                bases = list(ns0.ClusterConfigInfoEx_Def.__bases__)
                bases.insert(0, ns0.ComputeResourceConfigInfo_Def)
                ns0.ClusterConfigInfoEx_Def.__bases__ = tuple(bases)

            ns0.ComputeResourceConfigInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DpmBehavior_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DpmBehavior")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterDpmConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDpmConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDpmConfigInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DpmBehavior",lazy=True)(pname=(ns,"defaultDpmBehavior"), aname="_defaultDpmBehavior", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"option"), aname="_option", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDpmConfigInfo_Def.__bases__:
                bases = list(ns0.ClusterDpmConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDpmConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterDpmHostConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDpmHostConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDpmHostConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DpmBehavior",lazy=True)(pname=(ns,"behavior"), aname="_behavior", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDpmHostConfigInfo_Def.__bases__:
                bases = list(ns0.ClusterDpmHostConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDpmHostConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDpmHostConfigInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDpmHostConfigInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDpmHostConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ClusterDpmHostConfigInfo",lazy=True)(pname=(ns,"ClusterDpmHostConfigInfo"), aname="_ClusterDpmHostConfigInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDpmHostConfigInfo = []
                    return
            Holder.__name__ = "ArrayOfClusterDpmHostConfigInfo_Holder"
            self.pyclass = Holder

    class ClusterConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterDasConfigInfo",lazy=True)(pname=(ns,"dasConfig"), aname="_dasConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDasVmConfigSpec",lazy=True)(pname=(ns,"dasVmConfigSpec"), aname="_dasVmConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsConfigInfo",lazy=True)(pname=(ns,"drsConfig"), aname="_drsConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsVmConfigSpec",lazy=True)(pname=(ns,"drsVmConfigSpec"), aname="_drsVmConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterRuleSpec",lazy=True)(pname=(ns,"rulesSpec"), aname="_rulesSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterConfigSpec_Def.__bases__:
                bases = list(ns0.ClusterConfigSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterConfigSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterDasVmConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDasVmConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDasVmConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterDasVmConfigInfo",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ArrayUpdateSpec_Def not in ns0.ClusterDasVmConfigSpec_Def.__bases__:
                bases = list(ns0.ClusterDasVmConfigSpec_Def.__bases__)
                bases.insert(0, ns0.ArrayUpdateSpec_Def)
                ns0.ClusterDasVmConfigSpec_Def.__bases__ = tuple(bases)

            ns0.ArrayUpdateSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDasVmConfigSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDasVmConfigSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDasVmConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterDasVmConfigSpec",lazy=True)(pname=(ns,"ClusterDasVmConfigSpec"), aname="_ClusterDasVmConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDasVmConfigSpec = []
                    return
            Holder.__name__ = "ArrayOfClusterDasVmConfigSpec_Holder"
            self.pyclass = Holder

    class ClusterDrsVmConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDrsVmConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDrsVmConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterDrsVmConfigInfo",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ArrayUpdateSpec_Def not in ns0.ClusterDrsVmConfigSpec_Def.__bases__:
                bases = list(ns0.ClusterDrsVmConfigSpec_Def.__bases__)
                bases.insert(0, ns0.ArrayUpdateSpec_Def)
                ns0.ClusterDrsVmConfigSpec_Def.__bases__ = tuple(bases)

            ns0.ArrayUpdateSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDrsVmConfigSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDrsVmConfigSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDrsVmConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterDrsVmConfigSpec",lazy=True)(pname=(ns,"ClusterDrsVmConfigSpec"), aname="_ClusterDrsVmConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDrsVmConfigSpec = []
                    return
            Holder.__name__ = "ArrayOfClusterDrsVmConfigSpec_Holder"
            self.pyclass = Holder

    class ClusterRuleSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterRuleSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterRuleSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterRuleInfo",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ArrayUpdateSpec_Def not in ns0.ClusterRuleSpec_Def.__bases__:
                bases = list(ns0.ClusterRuleSpec_Def.__bases__)
                bases.insert(0, ns0.ArrayUpdateSpec_Def)
                ns0.ClusterRuleSpec_Def.__bases__ = tuple(bases)

            ns0.ArrayUpdateSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterRuleSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterRuleSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterRuleSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterRuleSpec",lazy=True)(pname=(ns,"ClusterRuleSpec"), aname="_ClusterRuleSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterRuleSpec = []
                    return
            Holder.__name__ = "ArrayOfClusterRuleSpec_Holder"
            self.pyclass = Holder

    class ClusterConfigSpecEx_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterConfigSpecEx")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterConfigSpecEx_Def.schema
            TClist = [GTD("urn:vim25","ClusterDasConfigInfo",lazy=True)(pname=(ns,"dasConfig"), aname="_dasConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDasVmConfigSpec",lazy=True)(pname=(ns,"dasVmConfigSpec"), aname="_dasVmConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsConfigInfo",lazy=True)(pname=(ns,"drsConfig"), aname="_drsConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsVmConfigSpec",lazy=True)(pname=(ns,"drsVmConfigSpec"), aname="_drsVmConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterRuleSpec",lazy=True)(pname=(ns,"rulesSpec"), aname="_rulesSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDpmConfigInfo",lazy=True)(pname=(ns,"dpmConfig"), aname="_dpmConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDpmHostConfigSpec",lazy=True)(pname=(ns,"dpmHostConfigSpec"), aname="_dpmHostConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ComputeResourceConfigSpec_Def not in ns0.ClusterConfigSpecEx_Def.__bases__:
                bases = list(ns0.ClusterConfigSpecEx_Def.__bases__)
                bases.insert(0, ns0.ComputeResourceConfigSpec_Def)
                ns0.ClusterConfigSpecEx_Def.__bases__ = tuple(bases)

            ns0.ComputeResourceConfigSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterDpmHostConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDpmHostConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDpmHostConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterDpmHostConfigInfo",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ArrayUpdateSpec_Def not in ns0.ClusterDpmHostConfigSpec_Def.__bases__:
                bases = list(ns0.ClusterDpmHostConfigSpec_Def.__bases__)
                bases.insert(0, ns0.ArrayUpdateSpec_Def)
                ns0.ClusterDpmHostConfigSpec_Def.__bases__ = tuple(bases)

            ns0.ArrayUpdateSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDpmHostConfigSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDpmHostConfigSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDpmHostConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","ClusterDpmHostConfigSpec",lazy=True)(pname=(ns,"ClusterDpmHostConfigSpec"), aname="_ClusterDpmHostConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDpmHostConfigSpec = []
                    return
            Holder.__name__ = "ArrayOfClusterDpmHostConfigSpec_Holder"
            self.pyclass = Holder

    class ClusterDasConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDasConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDasConfigInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"failoverLevel"), aname="_failoverLevel", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"admissionControlEnabled"), aname="_admissionControlEnabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDasVmSettings",lazy=True)(pname=(ns,"defaultVmSettings"), aname="_defaultVmSettings", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"option"), aname="_option", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDasConfigInfo_Def.__bases__:
                bases = list(ns0.ClusterDasConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDasConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasVmPriority_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DasVmPriority")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterDasVmConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDasVmConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDasVmConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DasVmPriority",lazy=True)(pname=(ns,"restartPriority"), aname="_restartPriority", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"powerOffOnIsolation"), aname="_powerOffOnIsolation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDasVmSettings",lazy=True)(pname=(ns,"dasSettings"), aname="_dasSettings", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDasVmConfigInfo_Def.__bases__:
                bases = list(ns0.ClusterDasVmConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDasVmConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDasVmConfigInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDasVmConfigInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDasVmConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ClusterDasVmConfigInfo",lazy=True)(pname=(ns,"ClusterDasVmConfigInfo"), aname="_ClusterDasVmConfigInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDasVmConfigInfo = []
                    return
            Holder.__name__ = "ArrayOfClusterDasVmConfigInfo_Holder"
            self.pyclass = Holder

    class ClusterDasVmSettingsRestartPriority_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ClusterDasVmSettingsRestartPriority")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterDasVmSettingsIsolationResponse_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ClusterDasVmSettingsIsolationResponse")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterDasVmSettings_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDasVmSettings")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDasVmSettings_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"restartPriority"), aname="_restartPriority", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"isolationResponse"), aname="_isolationResponse", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDasVmSettings_Def.__bases__:
                bases = list(ns0.ClusterDasVmSettings_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDasVmSettings_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterDrsMigration_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDrsMigration")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDrsMigration_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"time"), aname="_time", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"cpuLoad"), aname="_cpuLoad", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memoryLoad"), aname="_memoryLoad", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"source"), aname="_source", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"sourceCpuLoad"), aname="_sourceCpuLoad", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"sourceMemoryLoad"), aname="_sourceMemoryLoad", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"destination"), aname="_destination", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"destinationCpuLoad"), aname="_destinationCpuLoad", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"destinationMemoryLoad"), aname="_destinationMemoryLoad", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDrsMigration_Def.__bases__:
                bases = list(ns0.ClusterDrsMigration_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDrsMigration_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDrsMigration_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDrsMigration")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDrsMigration_Def.schema
            TClist = [GTD("urn:vim25","ClusterDrsMigration",lazy=True)(pname=(ns,"ClusterDrsMigration"), aname="_ClusterDrsMigration", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDrsMigration = []
                    return
            Holder.__name__ = "ArrayOfClusterDrsMigration_Holder"
            self.pyclass = Holder

    class DrsRecommendationReasonCode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DrsRecommendationReasonCode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterDrsRecommendation_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDrsRecommendation")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDrsRecommendation_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"rating"), aname="_rating", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"reasonText"), aname="_reasonText", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterDrsMigration",lazy=True)(pname=(ns,"migrationList"), aname="_migrationList", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterDrsRecommendation_Def.__bases__:
                bases = list(ns0.ClusterDrsRecommendation_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterDrsRecommendation_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterDrsRecommendation_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterDrsRecommendation")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterDrsRecommendation_Def.schema
            TClist = [GTD("urn:vim25","ClusterDrsRecommendation",lazy=True)(pname=(ns,"ClusterDrsRecommendation"), aname="_ClusterDrsRecommendation", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterDrsRecommendation = []
                    return
            Holder.__name__ = "ArrayOfClusterDrsRecommendation_Holder"
            self.pyclass = Holder

    class HostPowerOperationType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostPowerOperationType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterHostPowerAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterHostPowerAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterHostPowerAction_Def.schema
            TClist = [GTD("urn:vim25","HostPowerOperationType",lazy=True)(pname=(ns,"operationType"), aname="_operationType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"powerConsumptionWatt"), aname="_powerConsumptionWatt", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"cpuCapacityMHz"), aname="_cpuCapacityMHz", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"memCapacityMB"), aname="_memCapacityMB", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterAction_Def not in ns0.ClusterHostPowerAction_Def.__bases__:
                bases = list(ns0.ClusterHostPowerAction_Def.__bases__)
                bases.insert(0, ns0.ClusterAction_Def)
                ns0.ClusterHostPowerAction_Def.__bases__ = tuple(bases)

            ns0.ClusterAction_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterHostRecommendation_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterHostRecommendation")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterHostRecommendation_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"rating"), aname="_rating", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterHostRecommendation_Def.__bases__:
                bases = list(ns0.ClusterHostRecommendation_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterHostRecommendation_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterHostRecommendation_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterHostRecommendation")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterHostRecommendation_Def.schema
            TClist = [GTD("urn:vim25","ClusterHostRecommendation",lazy=True)(pname=(ns,"ClusterHostRecommendation"), aname="_ClusterHostRecommendation", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterHostRecommendation = []
                    return
            Holder.__name__ = "ArrayOfClusterHostRecommendation_Holder"
            self.pyclass = Holder

    class ClusterInitialPlacementAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterInitialPlacementAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterInitialPlacementAction_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"targetHost"), aname="_targetHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterAction_Def not in ns0.ClusterInitialPlacementAction_Def.__bases__:
                bases = list(ns0.ClusterInitialPlacementAction_Def.__bases__)
                bases.insert(0, ns0.ClusterAction_Def)
                ns0.ClusterInitialPlacementAction_Def.__bases__ = tuple(bases)

            ns0.ClusterAction_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterMigrationAction_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterMigrationAction")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterMigrationAction_Def.schema
            TClist = [GTD("urn:vim25","ClusterDrsMigration",lazy=True)(pname=(ns,"drsMigration"), aname="_drsMigration", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterAction_Def not in ns0.ClusterMigrationAction_Def.__bases__:
                bases = list(ns0.ClusterMigrationAction_Def.__bases__)
                bases.insert(0, ns0.ClusterAction_Def)
                ns0.ClusterMigrationAction_Def.__bases__ = tuple(bases)

            ns0.ClusterAction_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterNotAttemptedVmInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterNotAttemptedVmInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterNotAttemptedVmInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterNotAttemptedVmInfo_Def.__bases__:
                bases = list(ns0.ClusterNotAttemptedVmInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterNotAttemptedVmInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterNotAttemptedVmInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterNotAttemptedVmInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterNotAttemptedVmInfo_Def.schema
            TClist = [GTD("urn:vim25","ClusterNotAttemptedVmInfo",lazy=True)(pname=(ns,"ClusterNotAttemptedVmInfo"), aname="_ClusterNotAttemptedVmInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterNotAttemptedVmInfo = []
                    return
            Holder.__name__ = "ArrayOfClusterNotAttemptedVmInfo_Holder"
            self.pyclass = Holder

    class ClusterPowerOnVmResult_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterPowerOnVmResult")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterPowerOnVmResult_Def.schema
            TClist = [GTD("urn:vim25","ClusterAttemptedVmInfo",lazy=True)(pname=(ns,"attempted"), aname="_attempted", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterNotAttemptedVmInfo",lazy=True)(pname=(ns,"notAttempted"), aname="_notAttempted", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterRecommendation",lazy=True)(pname=(ns,"recommendations"), aname="_recommendations", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterPowerOnVmResult_Def.__bases__:
                bases = list(ns0.ClusterPowerOnVmResult_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterPowerOnVmResult_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RecommendationType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RecommendationType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class RecommendationReasonCode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RecommendationReasonCode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ClusterRecommendation_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterRecommendation")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterRecommendation_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"time"), aname="_time", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"rating"), aname="_rating", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"reasonText"), aname="_reasonText", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"prerequisite"), aname="_prerequisite", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ClusterAction",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"target"), aname="_target", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterRecommendation_Def.__bases__:
                bases = list(ns0.ClusterRecommendation_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterRecommendation_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterRecommendation_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterRecommendation")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterRecommendation_Def.schema
            TClist = [GTD("urn:vim25","ClusterRecommendation",lazy=True)(pname=(ns,"ClusterRecommendation"), aname="_ClusterRecommendation", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterRecommendation = []
                    return
            Holder.__name__ = "ArrayOfClusterRecommendation_Holder"
            self.pyclass = Holder

    class ClusterRuleInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterRuleInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterRuleInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityStatus",lazy=True)(pname=(ns,"status"), aname="_status", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ClusterRuleInfo_Def.__bases__:
                bases = list(ns0.ClusterRuleInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ClusterRuleInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfClusterRuleInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfClusterRuleInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfClusterRuleInfo_Def.schema
            TClist = [GTD("urn:vim25","ClusterRuleInfo",lazy=True)(pname=(ns,"ClusterRuleInfo"), aname="_ClusterRuleInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ClusterRuleInfo = []
                    return
            Holder.__name__ = "ArrayOfClusterRuleInfo_Holder"
            self.pyclass = Holder

    class ClusterAffinityRuleSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterAffinityRuleSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterAffinityRuleSpec_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterRuleInfo_Def not in ns0.ClusterAffinityRuleSpec_Def.__bases__:
                bases = list(ns0.ClusterAffinityRuleSpec_Def.__bases__)
                bases.insert(0, ns0.ClusterRuleInfo_Def)
                ns0.ClusterAffinityRuleSpec_Def.__bases__ = tuple(bases)

            ns0.ClusterRuleInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterAntiAffinityRuleSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterAntiAffinityRuleSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterAntiAffinityRuleSpec_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterRuleInfo_Def not in ns0.ClusterAntiAffinityRuleSpec_Def.__bases__:
                bases = list(ns0.ClusterAntiAffinityRuleSpec_Def.__bases__)
                bases.insert(0, ns0.ClusterRuleInfo_Def)
                ns0.ClusterAntiAffinityRuleSpec_Def.__bases__ = tuple(bases)

            ns0.ClusterRuleInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class Event_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "Event")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.Event_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"chainId"), aname="_chainId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"createdTime"), aname="_createdTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DatacenterEventArgument",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ComputeResourceEventArgument",lazy=True)(pname=(ns,"computeResource"), aname="_computeResource", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fullFormattedMessage"), aname="_fullFormattedMessage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.Event_Def.__bases__:
                bases = list(ns0.Event_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.Event_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfEvent_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfEvent")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfEvent_Def.schema
            TClist = [GTD("urn:vim25","Event",lazy=True)(pname=(ns,"Event"), aname="_Event", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._Event = []
                    return
            Holder.__name__ = "ArrayOfEvent_Holder"
            self.pyclass = Holder

    class GeneralEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"message"), aname="_message", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.GeneralEvent_Def.__bases__:
                bases = list(ns0.GeneralEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.GeneralEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GeneralHostInfoEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralHostInfoEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralHostInfoEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.GeneralHostInfoEvent_Def.__bases__:
                bases = list(ns0.GeneralHostInfoEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.GeneralHostInfoEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GeneralHostWarningEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralHostWarningEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralHostWarningEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.GeneralHostWarningEvent_Def.__bases__:
                bases = list(ns0.GeneralHostWarningEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.GeneralHostWarningEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GeneralHostErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralHostErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralHostErrorEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.GeneralHostErrorEvent_Def.__bases__:
                bases = list(ns0.GeneralHostErrorEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.GeneralHostErrorEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GeneralVmInfoEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralVmInfoEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralVmInfoEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.GeneralVmInfoEvent_Def.__bases__:
                bases = list(ns0.GeneralVmInfoEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.GeneralVmInfoEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GeneralVmWarningEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralVmWarningEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralVmWarningEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.GeneralVmWarningEvent_Def.__bases__:
                bases = list(ns0.GeneralVmWarningEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.GeneralVmWarningEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GeneralVmErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralVmErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralVmErrorEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.GeneralVmErrorEvent_Def.__bases__:
                bases = list(ns0.GeneralVmErrorEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.GeneralVmErrorEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GeneralUserEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GeneralUserEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GeneralUserEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.GeneralUserEvent_Def.__bases__:
                bases = list(ns0.GeneralUserEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.GeneralUserEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ExtendedEventPair_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtendedEventPair")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtendedEventPair_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ExtendedEventPair_Def.__bases__:
                bases = list(ns0.ExtendedEventPair_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ExtendedEventPair_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfExtendedEventPair_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfExtendedEventPair")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfExtendedEventPair_Def.schema
            TClist = [GTD("urn:vim25","ExtendedEventPair",lazy=True)(pname=(ns,"ExtendedEventPair"), aname="_ExtendedEventPair", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ExtendedEventPair = []
                    return
            Holder.__name__ = "ArrayOfExtendedEventPair_Holder"
            self.pyclass = Holder

    class ExtendedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtendedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtendedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"eventTypeId"), aname="_eventTypeId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"managedObject"), aname="_managedObject", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ExtendedEventPair",lazy=True)(pname=(ns,"data"), aname="_data", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.GeneralEvent_Def not in ns0.ExtendedEvent_Def.__bases__:
                bases = list(ns0.ExtendedEvent_Def.__bases__)
                bases.insert(0, ns0.GeneralEvent_Def)
                ns0.ExtendedEvent_Def.__bases__ = tuple(bases)

            ns0.GeneralEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatacenterEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatacenterEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatacenterEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.DatacenterEvent_Def.__bases__:
                bases = list(ns0.DatacenterEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.DatacenterEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatacenterCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatacenterCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatacenterCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","FolderEventArgument",lazy=True)(pname=(ns,"parent"), aname="_parent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatacenterEvent_Def not in ns0.DatacenterCreatedEvent_Def.__bases__:
                bases = list(ns0.DatacenterCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.DatacenterEvent_Def)
                ns0.DatacenterCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.DatacenterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatacenterRenamedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatacenterRenamedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatacenterRenamedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldName"), aname="_oldName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatacenterEvent_Def not in ns0.DatacenterRenamedEvent_Def.__bases__:
                bases = list(ns0.DatacenterRenamedEvent_Def.__bases__)
                bases.insert(0, ns0.DatacenterEvent_Def)
                ns0.DatacenterRenamedEvent_Def.__bases__ = tuple(bases)

            ns0.DatacenterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SessionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SessionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SessionEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.SessionEvent_Def.__bases__:
                bases = list(ns0.SessionEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.SessionEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ServerStartedSessionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ServerStartedSessionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ServerStartedSessionEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.ServerStartedSessionEvent_Def.__bases__:
                bases = list(ns0.ServerStartedSessionEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.ServerStartedSessionEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UserLoginSessionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserLoginSessionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserLoginSessionEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locale"), aname="_locale", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sessionId"), aname="_sessionId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.UserLoginSessionEvent_Def.__bases__:
                bases = list(ns0.UserLoginSessionEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.UserLoginSessionEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UserLogoutSessionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserLogoutSessionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserLogoutSessionEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.UserLogoutSessionEvent_Def.__bases__:
                bases = list(ns0.UserLogoutSessionEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.UserLogoutSessionEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class BadUsernameSessionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "BadUsernameSessionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.BadUsernameSessionEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.BadUsernameSessionEvent_Def.__bases__:
                bases = list(ns0.BadUsernameSessionEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.BadUsernameSessionEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlreadyAuthenticatedSessionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlreadyAuthenticatedSessionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlreadyAuthenticatedSessionEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.AlreadyAuthenticatedSessionEvent_Def.__bases__:
                bases = list(ns0.AlreadyAuthenticatedSessionEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.AlreadyAuthenticatedSessionEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoAccessUserEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoAccessUserEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoAccessUserEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.NoAccessUserEvent_Def.__bases__:
                bases = list(ns0.NoAccessUserEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.NoAccessUserEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SessionTerminatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SessionTerminatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SessionTerminatedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"sessionId"), aname="_sessionId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"terminatedUsername"), aname="_terminatedUsername", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.SessionTerminatedEvent_Def.__bases__:
                bases = list(ns0.SessionTerminatedEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.SessionTerminatedEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GlobalMessageChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GlobalMessageChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GlobalMessageChangedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"message"), aname="_message", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SessionEvent_Def not in ns0.GlobalMessageChangedEvent_Def.__bases__:
                bases = list(ns0.GlobalMessageChangedEvent_Def.__bases__)
                bases.insert(0, ns0.SessionEvent_Def)
                ns0.GlobalMessageChangedEvent_Def.__bases__ = tuple(bases)

            ns0.SessionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpgradeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UpgradeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UpgradeEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"message"), aname="_message", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.UpgradeEvent_Def.__bases__:
                bases = list(ns0.UpgradeEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.UpgradeEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InfoUpgradeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InfoUpgradeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InfoUpgradeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.UpgradeEvent_Def not in ns0.InfoUpgradeEvent_Def.__bases__:
                bases = list(ns0.InfoUpgradeEvent_Def.__bases__)
                bases.insert(0, ns0.UpgradeEvent_Def)
                ns0.InfoUpgradeEvent_Def.__bases__ = tuple(bases)

            ns0.UpgradeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class WarningUpgradeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "WarningUpgradeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.WarningUpgradeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.UpgradeEvent_Def not in ns0.WarningUpgradeEvent_Def.__bases__:
                bases = list(ns0.WarningUpgradeEvent_Def.__bases__)
                bases.insert(0, ns0.UpgradeEvent_Def)
                ns0.WarningUpgradeEvent_Def.__bases__ = tuple(bases)

            ns0.UpgradeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ErrorUpgradeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ErrorUpgradeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ErrorUpgradeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.UpgradeEvent_Def not in ns0.ErrorUpgradeEvent_Def.__bases__:
                bases = list(ns0.ErrorUpgradeEvent_Def.__bases__)
                bases.insert(0, ns0.UpgradeEvent_Def)
                ns0.ErrorUpgradeEvent_Def.__bases__ = tuple(bases)

            ns0.UpgradeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UserUpgradeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserUpgradeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserUpgradeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.UpgradeEvent_Def not in ns0.UserUpgradeEvent_Def.__bases__:
                bases = list(ns0.UserUpgradeEvent_Def.__bases__)
                bases.insert(0, ns0.UpgradeEvent_Def)
                ns0.UserUpgradeEvent_Def.__bases__ = tuple(bases)

            ns0.UpgradeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.HostEvent_Def.__bases__:
                bases = list(ns0.HostEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.HostEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDasEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDasEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDasEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDasEvent_Def.__bases__:
                bases = list(ns0.HostDasEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDasEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConnectedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConnectedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConnectedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostConnectedEvent_Def.__bases__:
                bases = list(ns0.HostConnectedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostConnectedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDisconnectedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDisconnectedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDisconnectedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDisconnectedEvent_Def.__bases__:
                bases = list(ns0.HostDisconnectedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDisconnectedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConnectionLostEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConnectionLostEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConnectionLostEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostConnectionLostEvent_Def.__bases__:
                bases = list(ns0.HostConnectionLostEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostConnectionLostEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostReconnectionFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostReconnectionFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostReconnectionFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostReconnectionFailedEvent_Def.__bases__:
                bases = list(ns0.HostReconnectionFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostReconnectionFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedNoConnectionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedNoConnectionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedNoConnectionEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedNoConnectionEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedNoConnectionEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedNoConnectionEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedBadUsernameEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedBadUsernameEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedBadUsernameEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedBadUsernameEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedBadUsernameEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedBadUsernameEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedBadVersionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedBadVersionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedBadVersionEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedBadVersionEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedBadVersionEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedBadVersionEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedAlreadyManagedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedAlreadyManagedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedAlreadyManagedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"serverName"), aname="_serverName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedAlreadyManagedEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedAlreadyManagedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedAlreadyManagedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedNoLicenseEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedNoLicenseEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedNoLicenseEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedNoLicenseEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedNoLicenseEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedNoLicenseEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedNetworkErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedNetworkErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedNetworkErrorEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedNetworkErrorEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedNetworkErrorEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedNetworkErrorEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostRemovedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostRemovedEvent_Def.__bases__:
                bases = list(ns0.HostRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedCcagentUpgradeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedCcagentUpgradeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedCcagentUpgradeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedCcagentUpgradeEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedCcagentUpgradeEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedCcagentUpgradeEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedBadCcagentEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedBadCcagentEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedBadCcagentEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedBadCcagentEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedBadCcagentEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedBadCcagentEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedAccountFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedAccountFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedAccountFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedAccountFailedEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedAccountFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedAccountFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedNoAccessEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedNoAccessEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedNoAccessEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedNoAccessEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedNoAccessEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedNoAccessEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostShutdownEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostShutdownEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostShutdownEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostShutdownEvent_Def.__bases__:
                bases = list(ns0.HostShutdownEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostShutdownEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedNotFoundEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedNotFoundEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedNotFoundEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedNotFoundEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedNotFoundEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedNotFoundEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCnxFailedTimeoutEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCnxFailedTimeoutEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCnxFailedTimeoutEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostCnxFailedTimeoutEvent_Def.__bases__:
                bases = list(ns0.HostCnxFailedTimeoutEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostCnxFailedTimeoutEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostUpgradeFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostUpgradeFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostUpgradeFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostUpgradeFailedEvent_Def.__bases__:
                bases = list(ns0.HostUpgradeFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostUpgradeFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EnteringMaintenanceModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EnteringMaintenanceModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EnteringMaintenanceModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.EnteringMaintenanceModeEvent_Def.__bases__:
                bases = list(ns0.EnteringMaintenanceModeEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.EnteringMaintenanceModeEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EnteredMaintenanceModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EnteredMaintenanceModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EnteredMaintenanceModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.EnteredMaintenanceModeEvent_Def.__bases__:
                bases = list(ns0.EnteredMaintenanceModeEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.EnteredMaintenanceModeEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ExitMaintenanceModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExitMaintenanceModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExitMaintenanceModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.ExitMaintenanceModeEvent_Def.__bases__:
                bases = list(ns0.ExitMaintenanceModeEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.ExitMaintenanceModeEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CanceledHostOperationEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CanceledHostOperationEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CanceledHostOperationEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.CanceledHostOperationEvent_Def.__bases__:
                bases = list(ns0.CanceledHostOperationEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.CanceledHostOperationEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TimedOutHostOperationEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TimedOutHostOperationEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TimedOutHostOperationEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.TimedOutHostOperationEvent_Def.__bases__:
                bases = list(ns0.TimedOutHostOperationEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.TimedOutHostOperationEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDasEnabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDasEnabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDasEnabledEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDasEnabledEvent_Def.__bases__:
                bases = list(ns0.HostDasEnabledEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDasEnabledEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDasDisabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDasDisabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDasDisabledEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDasDisabledEvent_Def.__bases__:
                bases = list(ns0.HostDasDisabledEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDasDisabledEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDasEnablingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDasEnablingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDasEnablingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDasEnablingEvent_Def.__bases__:
                bases = list(ns0.HostDasEnablingEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDasEnablingEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDasDisablingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDasDisablingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDasDisablingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDasDisablingEvent_Def.__bases__:
                bases = list(ns0.HostDasDisablingEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDasDisablingEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDasErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDasErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDasErrorEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"message"), aname="_message", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDasErrorEvent_Def.__bases__:
                bases = list(ns0.HostDasErrorEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDasErrorEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDasOkEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDasOkEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDasOkEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostDasOkEvent_Def.__bases__:
                bases = list(ns0.HostDasOkEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostDasOkEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VcAgentUpgradedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VcAgentUpgradedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VcAgentUpgradedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.VcAgentUpgradedEvent_Def.__bases__:
                bases = list(ns0.VcAgentUpgradedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.VcAgentUpgradedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VcAgentUpgradeFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VcAgentUpgradeFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VcAgentUpgradeFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.VcAgentUpgradeFailedEvent_Def.__bases__:
                bases = list(ns0.VcAgentUpgradeFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.VcAgentUpgradeFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostAddedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostAddedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostAddedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostAddedEvent_Def.__bases__:
                bases = list(ns0.HostAddedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostAddedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostAddFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostAddFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostAddFailedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"hostname"), aname="_hostname", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostAddFailedEvent_Def.__bases__:
                bases = list(ns0.HostAddFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostAddFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostIpChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostIpChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostIpChangedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldIP"), aname="_oldIP", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newIP"), aname="_newIP", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostIpChangedEvent_Def.__bases__:
                bases = list(ns0.HostIpChangedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostIpChangedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EnteringStandbyModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EnteringStandbyModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EnteringStandbyModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.EnteringStandbyModeEvent_Def.__bases__:
                bases = list(ns0.EnteringStandbyModeEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.EnteringStandbyModeEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EnteredStandbyModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EnteredStandbyModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EnteredStandbyModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.EnteredStandbyModeEvent_Def.__bases__:
                bases = list(ns0.EnteredStandbyModeEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.EnteredStandbyModeEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsEnteredStandbyModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsEnteredStandbyModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsEnteredStandbyModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EnteredStandbyModeEvent_Def not in ns0.DrsEnteredStandbyModeEvent_Def.__bases__:
                bases = list(ns0.DrsEnteredStandbyModeEvent_Def.__bases__)
                bases.insert(0, ns0.EnteredStandbyModeEvent_Def)
                ns0.DrsEnteredStandbyModeEvent_Def.__bases__ = tuple(bases)

            ns0.EnteredStandbyModeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ExitedStandbyModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExitedStandbyModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExitedStandbyModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.ExitedStandbyModeEvent_Def.__bases__:
                bases = list(ns0.ExitedStandbyModeEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.ExitedStandbyModeEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsExitedStandbyModeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsExitedStandbyModeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsExitedStandbyModeEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ExitedStandbyModeEvent_Def not in ns0.DrsExitedStandbyModeEvent_Def.__bases__:
                bases = list(ns0.DrsExitedStandbyModeEvent_Def.__bases__)
                bases.insert(0, ns0.ExitedStandbyModeEvent_Def)
                ns0.DrsExitedStandbyModeEvent_Def.__bases__ = tuple(bases)

            ns0.ExitedStandbyModeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdatedAgentBeingRestartedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UpdatedAgentBeingRestartedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UpdatedAgentBeingRestartedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.UpdatedAgentBeingRestartedEvent_Def.__bases__:
                bases = list(ns0.UpdatedAgentBeingRestartedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.UpdatedAgentBeingRestartedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AccountCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AccountCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AccountCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostAccountSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.AccountCreatedEvent_Def.__bases__:
                bases = list(ns0.AccountCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.AccountCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AccountRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AccountRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AccountRemovedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"account"), aname="_account", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.AccountRemovedEvent_Def.__bases__:
                bases = list(ns0.AccountRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.AccountRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UserPasswordChanged_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserPasswordChanged")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserPasswordChanged_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"userLogin"), aname="_userLogin", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.UserPasswordChanged_Def.__bases__:
                bases = list(ns0.UserPasswordChanged_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.UserPasswordChanged_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AccountUpdatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AccountUpdatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AccountUpdatedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostAccountSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.AccountUpdatedEvent_Def.__bases__:
                bases = list(ns0.AccountUpdatedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.AccountUpdatedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UserAssignedToGroup_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserAssignedToGroup")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserAssignedToGroup_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"userLogin"), aname="_userLogin", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.UserAssignedToGroup_Def.__bases__:
                bases = list(ns0.UserAssignedToGroup_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.UserAssignedToGroup_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UserUnassignedFromGroup_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserUnassignedFromGroup")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserUnassignedFromGroup_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"userLogin"), aname="_userLogin", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.UserUnassignedFromGroup_Def.__bases__:
                bases = list(ns0.UserUnassignedFromGroup_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.UserUnassignedFromGroup_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastorePrincipalConfigured_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastorePrincipalConfigured")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastorePrincipalConfigured_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"datastorePrincipal"), aname="_datastorePrincipal", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.DatastorePrincipalConfigured_Def.__bases__:
                bases = list(ns0.DatastorePrincipalConfigured_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.DatastorePrincipalConfigured_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMFSDatastoreCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMFSDatastoreCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMFSDatastoreCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.VMFSDatastoreCreatedEvent_Def.__bases__:
                bases = list(ns0.VMFSDatastoreCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.VMFSDatastoreCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NASDatastoreCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NASDatastoreCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NASDatastoreCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.NASDatastoreCreatedEvent_Def.__bases__:
                bases = list(ns0.NASDatastoreCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.NASDatastoreCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LocalDatastoreCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LocalDatastoreCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LocalDatastoreCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.LocalDatastoreCreatedEvent_Def.__bases__:
                bases = list(ns0.LocalDatastoreCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.LocalDatastoreCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreRemovedOnHostEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreRemovedOnHostEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreRemovedOnHostEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.DatastoreRemovedOnHostEvent_Def.__bases__:
                bases = list(ns0.DatastoreRemovedOnHostEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.DatastoreRemovedOnHostEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreRenamedOnHostEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreRenamedOnHostEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreRenamedOnHostEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldName"), aname="_oldName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.DatastoreRenamedOnHostEvent_Def.__bases__:
                bases = list(ns0.DatastoreRenamedOnHostEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.DatastoreRenamedOnHostEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DuplicateIpDetectedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DuplicateIpDetectedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DuplicateIpDetectedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"duplicateIP"), aname="_duplicateIP", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"macAddress"), aname="_macAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.DuplicateIpDetectedEvent_Def.__bases__:
                bases = list(ns0.DuplicateIpDetectedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.DuplicateIpDetectedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreDiscoveredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreDiscoveredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreDiscoveredEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.DatastoreDiscoveredEvent_Def.__bases__:
                bases = list(ns0.DatastoreDiscoveredEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.DatastoreDiscoveredEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsResourceConfigureFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsResourceConfigureFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsResourceConfigureFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.DrsResourceConfigureFailedEvent_Def.__bases__:
                bases = list(ns0.DrsResourceConfigureFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.DrsResourceConfigureFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsResourceConfigureSyncedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsResourceConfigureSyncedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsResourceConfigureSyncedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.DrsResourceConfigureSyncedEvent_Def.__bases__:
                bases = list(ns0.DrsResourceConfigureSyncedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.DrsResourceConfigureSyncedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostGetShortNameFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostGetShortNameFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostGetShortNameFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostGetShortNameFailedEvent_Def.__bases__:
                bases = list(ns0.HostGetShortNameFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostGetShortNameFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostShortNameToIpFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostShortNameToIpFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostShortNameToIpFailedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"shortName"), aname="_shortName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostShortNameToIpFailedEvent_Def.__bases__:
                bases = list(ns0.HostShortNameToIpFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostShortNameToIpFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostIpToShortNameFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostIpToShortNameFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostIpToShortNameFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostIpToShortNameFailedEvent_Def.__bases__:
                bases = list(ns0.HostIpToShortNameFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostIpToShortNameFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostPrimaryAgentNotShortNameEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPrimaryAgentNotShortNameEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPrimaryAgentNotShortNameEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"primaryAgent"), aname="_primaryAgent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDasEvent_Def not in ns0.HostPrimaryAgentNotShortNameEvent_Def.__bases__:
                bases = list(ns0.HostPrimaryAgentNotShortNameEvent_Def.__bases__)
                bases.insert(0, ns0.HostDasEvent_Def)
                ns0.HostPrimaryAgentNotShortNameEvent_Def.__bases__ = tuple(bases)

            ns0.HostDasEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNotInClusterEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNotInClusterEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNotInClusterEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDasEvent_Def not in ns0.HostNotInClusterEvent_Def.__bases__:
                bases = list(ns0.HostNotInClusterEvent_Def.__bases__)
                bases.insert(0, ns0.HostDasEvent_Def)
                ns0.HostNotInClusterEvent_Def.__bases__ = tuple(bases)

            ns0.HostDasEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostIsolationIpPingFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostIsolationIpPingFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostIsolationIpPingFailedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"isolationIp"), aname="_isolationIp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDasEvent_Def not in ns0.HostIsolationIpPingFailedEvent_Def.__bases__:
                bases = list(ns0.HostIsolationIpPingFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostDasEvent_Def)
                ns0.HostIsolationIpPingFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostDasEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostIpInconsistentEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostIpInconsistentEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostIpInconsistentEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipAddress2"), aname="_ipAddress2", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostIpInconsistentEvent_Def.__bases__:
                bases = list(ns0.HostIpInconsistentEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostIpInconsistentEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostShortNameInconsistentEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostShortNameInconsistentEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostShortNameInconsistentEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"shortName"), aname="_shortName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"shortName2"), aname="_shortName2", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDasEvent_Def not in ns0.HostShortNameInconsistentEvent_Def.__bases__:
                bases = list(ns0.HostShortNameInconsistentEvent_Def.__bases__)
                bases.insert(0, ns0.HostDasEvent_Def)
                ns0.HostShortNameInconsistentEvent_Def.__bases__ = tuple(bases)

            ns0.HostDasEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNoRedundantManagementNetworkEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNoRedundantManagementNetworkEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNoRedundantManagementNetworkEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDasEvent_Def not in ns0.HostNoRedundantManagementNetworkEvent_Def.__bases__:
                bases = list(ns0.HostNoRedundantManagementNetworkEvent_Def.__bases__)
                bases.insert(0, ns0.HostDasEvent_Def)
                ns0.HostNoRedundantManagementNetworkEvent_Def.__bases__ = tuple(bases)

            ns0.HostDasEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmEvent_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"template"), aname="_template", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.VmEvent_Def.__bases__:
                bases = list(ns0.VmEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.VmEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmPoweredOffEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmPoweredOffEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmPoweredOffEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmPoweredOffEvent_Def.__bases__:
                bases = list(ns0.VmPoweredOffEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmPoweredOffEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmPoweredOnEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmPoweredOnEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmPoweredOnEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmPoweredOnEvent_Def.__bases__:
                bases = list(ns0.VmPoweredOnEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmPoweredOnEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmSuspendedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmSuspendedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmSuspendedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmSuspendedEvent_Def.__bases__:
                bases = list(ns0.VmSuspendedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmSuspendedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmStartingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmStartingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmStartingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmStartingEvent_Def.__bases__:
                bases = list(ns0.VmStartingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmStartingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmStoppingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmStoppingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmStoppingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmStoppingEvent_Def.__bases__:
                bases = list(ns0.VmStoppingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmStoppingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmSuspendingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmSuspendingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmSuspendingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmSuspendingEvent_Def.__bases__:
                bases = list(ns0.VmSuspendingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmSuspendingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmResumingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmResumingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmResumingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmResumingEvent_Def.__bases__:
                bases = list(ns0.VmResumingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmResumingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDisconnectedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDisconnectedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDisconnectedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDisconnectedEvent_Def.__bases__:
                bases = list(ns0.VmDisconnectedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDisconnectedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDiscoveredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDiscoveredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDiscoveredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDiscoveredEvent_Def.__bases__:
                bases = list(ns0.VmDiscoveredEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDiscoveredEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmOrphanedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmOrphanedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmOrphanedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmOrphanedEvent_Def.__bases__:
                bases = list(ns0.VmOrphanedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmOrphanedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmBeingCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmBeingCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmBeingCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineConfigSpec",lazy=True)(pname=(ns,"configSpec"), aname="_configSpec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmBeingCreatedEvent_Def.__bases__:
                bases = list(ns0.VmBeingCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmBeingCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmCreatedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmCreatedEvent_Def.__bases__:
                bases = list(ns0.VmCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRegisteredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRegisteredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRegisteredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmRegisteredEvent_Def.__bases__:
                bases = list(ns0.VmRegisteredEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmRegisteredEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmAutoRenameEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmAutoRenameEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmAutoRenameEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldName"), aname="_oldName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmAutoRenameEvent_Def.__bases__:
                bases = list(ns0.VmAutoRenameEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmAutoRenameEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmBeingHotMigratedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmBeingHotMigratedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmBeingHotMigratedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmBeingHotMigratedEvent_Def.__bases__:
                bases = list(ns0.VmBeingHotMigratedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmBeingHotMigratedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmResettingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmResettingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmResettingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmResettingEvent_Def.__bases__:
                bases = list(ns0.VmResettingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmResettingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmStaticMacConflictEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmStaticMacConflictEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmStaticMacConflictEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"conflictedVm"), aname="_conflictedVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mac"), aname="_mac", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmStaticMacConflictEvent_Def.__bases__:
                bases = list(ns0.VmStaticMacConflictEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmStaticMacConflictEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmMacConflictEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmMacConflictEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmMacConflictEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"conflictedVm"), aname="_conflictedVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mac"), aname="_mac", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmMacConflictEvent_Def.__bases__:
                bases = list(ns0.VmMacConflictEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmMacConflictEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmBeingDeployedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmBeingDeployedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmBeingDeployedEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"srcTemplate"), aname="_srcTemplate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmBeingDeployedEvent_Def.__bases__:
                bases = list(ns0.VmBeingDeployedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmBeingDeployedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDeployFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDeployFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDeployFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","EntityEventArgument",lazy=True)(pname=(ns,"destDatastore"), aname="_destDatastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDeployFailedEvent_Def.__bases__:
                bases = list(ns0.VmDeployFailedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDeployFailedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDeployedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDeployedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDeployedEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"srcTemplate"), aname="_srcTemplate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDeployedEvent_Def.__bases__:
                bases = list(ns0.VmDeployedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDeployedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmMacChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmMacChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmMacChangedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"adapter"), aname="_adapter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"oldMac"), aname="_oldMac", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newMac"), aname="_newMac", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmMacChangedEvent_Def.__bases__:
                bases = list(ns0.VmMacChangedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmMacChangedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmMacAssignedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmMacAssignedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmMacAssignedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"adapter"), aname="_adapter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mac"), aname="_mac", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmMacAssignedEvent_Def.__bases__:
                bases = list(ns0.VmMacAssignedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmMacAssignedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmUuidConflictEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmUuidConflictEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmUuidConflictEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"conflictedVm"), aname="_conflictedVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmUuidConflictEvent_Def.__bases__:
                bases = list(ns0.VmUuidConflictEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmUuidConflictEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmBeingMigratedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmBeingMigratedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmBeingMigratedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmBeingMigratedEvent_Def.__bases__:
                bases = list(ns0.VmBeingMigratedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmBeingMigratedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedMigrateEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedMigrateEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedMigrateEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedMigrateEvent_Def.__bases__:
                bases = list(ns0.VmFailedMigrateEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedMigrateEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmMigratedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmMigratedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmMigratedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"sourceHost"), aname="_sourceHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmMigratedEvent_Def.__bases__:
                bases = list(ns0.VmMigratedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmMigratedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmUnsupportedStartingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmUnsupportedStartingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmUnsupportedStartingEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"guestId"), aname="_guestId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmStartingEvent_Def not in ns0.VmUnsupportedStartingEvent_Def.__bases__:
                bases = list(ns0.VmUnsupportedStartingEvent_Def.__bases__)
                bases.insert(0, ns0.VmStartingEvent_Def)
                ns0.VmUnsupportedStartingEvent_Def.__bases__ = tuple(bases)

            ns0.VmStartingEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsVmMigratedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsVmMigratedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsVmMigratedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmMigratedEvent_Def not in ns0.DrsVmMigratedEvent_Def.__bases__:
                bases = list(ns0.DrsVmMigratedEvent_Def.__bases__)
                bases.insert(0, ns0.VmMigratedEvent_Def)
                ns0.DrsVmMigratedEvent_Def.__bases__ = tuple(bases)

            ns0.VmMigratedEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsVmPoweredOnEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsVmPoweredOnEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsVmPoweredOnEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmPoweredOnEvent_Def not in ns0.DrsVmPoweredOnEvent_Def.__bases__:
                bases = list(ns0.DrsVmPoweredOnEvent_Def.__bases__)
                bases.insert(0, ns0.VmPoweredOnEvent_Def)
                ns0.DrsVmPoweredOnEvent_Def.__bases__ = tuple(bases)

            ns0.VmPoweredOnEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRelocateSpecEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRelocateSpecEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRelocateSpecEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmRelocateSpecEvent_Def.__bases__:
                bases = list(ns0.VmRelocateSpecEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmRelocateSpecEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmBeingRelocatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmBeingRelocatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmBeingRelocatedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmRelocateSpecEvent_Def not in ns0.VmBeingRelocatedEvent_Def.__bases__:
                bases = list(ns0.VmBeingRelocatedEvent_Def.__bases__)
                bases.insert(0, ns0.VmRelocateSpecEvent_Def)
                ns0.VmBeingRelocatedEvent_Def.__bases__ = tuple(bases)

            ns0.VmRelocateSpecEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRelocatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRelocatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRelocatedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"sourceHost"), aname="_sourceHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmRelocateSpecEvent_Def not in ns0.VmRelocatedEvent_Def.__bases__:
                bases = list(ns0.VmRelocatedEvent_Def.__bases__)
                bases.insert(0, ns0.VmRelocateSpecEvent_Def)
                ns0.VmRelocatedEvent_Def.__bases__ = tuple(bases)

            ns0.VmRelocateSpecEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRelocateFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRelocateFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRelocateFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmRelocateSpecEvent_Def not in ns0.VmRelocateFailedEvent_Def.__bases__:
                bases = list(ns0.VmRelocateFailedEvent_Def.__bases__)
                bases.insert(0, ns0.VmRelocateSpecEvent_Def)
                ns0.VmRelocateFailedEvent_Def.__bases__ = tuple(bases)

            ns0.VmRelocateSpecEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmEmigratingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmEmigratingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmEmigratingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmEmigratingEvent_Def.__bases__:
                bases = list(ns0.VmEmigratingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmEmigratingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmCloneEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmCloneEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmCloneEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmCloneEvent_Def.__bases__:
                bases = list(ns0.VmCloneEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmCloneEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmBeingClonedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmBeingClonedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmBeingClonedEvent_Def.schema
            TClist = [GTD("urn:vim25","FolderEventArgument",lazy=True)(pname=(ns,"destFolder"), aname="_destFolder", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"destName"), aname="_destName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmCloneEvent_Def not in ns0.VmBeingClonedEvent_Def.__bases__:
                bases = list(ns0.VmBeingClonedEvent_Def.__bases__)
                bases.insert(0, ns0.VmCloneEvent_Def)
                ns0.VmBeingClonedEvent_Def.__bases__ = tuple(bases)

            ns0.VmCloneEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmCloneFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmCloneFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmCloneFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","FolderEventArgument",lazy=True)(pname=(ns,"destFolder"), aname="_destFolder", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"destName"), aname="_destName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmCloneEvent_Def not in ns0.VmCloneFailedEvent_Def.__bases__:
                bases = list(ns0.VmCloneFailedEvent_Def.__bases__)
                bases.insert(0, ns0.VmCloneEvent_Def)
                ns0.VmCloneFailedEvent_Def.__bases__ = tuple(bases)

            ns0.VmCloneEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmClonedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmClonedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmClonedEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"sourceVm"), aname="_sourceVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmCloneEvent_Def not in ns0.VmClonedEvent_Def.__bases__:
                bases = list(ns0.VmClonedEvent_Def.__bases__)
                bases.insert(0, ns0.VmCloneEvent_Def)
                ns0.VmClonedEvent_Def.__bases__ = tuple(bases)

            ns0.VmCloneEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmResourceReallocatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmResourceReallocatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmResourceReallocatedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmResourceReallocatedEvent_Def.__bases__:
                bases = list(ns0.VmResourceReallocatedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmResourceReallocatedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRenamedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRenamedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRenamedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldName"), aname="_oldName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmRenamedEvent_Def.__bases__:
                bases = list(ns0.VmRenamedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmRenamedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDateRolledBackEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDateRolledBackEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDateRolledBackEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDateRolledBackEvent_Def.__bases__:
                bases = list(ns0.VmDateRolledBackEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDateRolledBackEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmNoNetworkAccessEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmNoNetworkAccessEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmNoNetworkAccessEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"destHost"), aname="_destHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmNoNetworkAccessEvent_Def.__bases__:
                bases = list(ns0.VmNoNetworkAccessEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmNoNetworkAccessEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDiskFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDiskFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDiskFailedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"disk"), aname="_disk", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDiskFailedEvent_Def.__bases__:
                bases = list(ns0.VmDiskFailedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDiskFailedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedToPowerOnEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedToPowerOnEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedToPowerOnEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedToPowerOnEvent_Def.__bases__:
                bases = list(ns0.VmFailedToPowerOnEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedToPowerOnEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedToPowerOffEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedToPowerOffEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedToPowerOffEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedToPowerOffEvent_Def.__bases__:
                bases = list(ns0.VmFailedToPowerOffEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedToPowerOffEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedToSuspendEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedToSuspendEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedToSuspendEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedToSuspendEvent_Def.__bases__:
                bases = list(ns0.VmFailedToSuspendEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedToSuspendEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedToResetEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedToResetEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedToResetEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedToResetEvent_Def.__bases__:
                bases = list(ns0.VmFailedToResetEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedToResetEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedToShutdownGuestEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedToShutdownGuestEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedToShutdownGuestEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedToShutdownGuestEvent_Def.__bases__:
                bases = list(ns0.VmFailedToShutdownGuestEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedToShutdownGuestEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedToRebootGuestEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedToRebootGuestEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedToRebootGuestEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedToRebootGuestEvent_Def.__bases__:
                bases = list(ns0.VmFailedToRebootGuestEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedToRebootGuestEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedToStandbyGuestEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedToStandbyGuestEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedToStandbyGuestEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedToStandbyGuestEvent_Def.__bases__:
                bases = list(ns0.VmFailedToStandbyGuestEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedToStandbyGuestEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRemovedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmRemovedEvent_Def.__bases__:
                bases = list(ns0.VmRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmGuestShutdownEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmGuestShutdownEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmGuestShutdownEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmGuestShutdownEvent_Def.__bases__:
                bases = list(ns0.VmGuestShutdownEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmGuestShutdownEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmGuestRebootEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmGuestRebootEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmGuestRebootEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmGuestRebootEvent_Def.__bases__:
                bases = list(ns0.VmGuestRebootEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmGuestRebootEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmGuestStandbyEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmGuestStandbyEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmGuestStandbyEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmGuestStandbyEvent_Def.__bases__:
                bases = list(ns0.VmGuestStandbyEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmGuestStandbyEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmUpgradingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmUpgradingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmUpgradingEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmUpgradingEvent_Def.__bases__:
                bases = list(ns0.VmUpgradingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmUpgradingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmUpgradeCompleteEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmUpgradeCompleteEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmUpgradeCompleteEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmUpgradeCompleteEvent_Def.__bases__:
                bases = list(ns0.VmUpgradeCompleteEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmUpgradeCompleteEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmUpgradeFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmUpgradeFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmUpgradeFailedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmUpgradeFailedEvent_Def.__bases__:
                bases = list(ns0.VmUpgradeFailedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmUpgradeFailedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRestartedOnAlternateHostEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRestartedOnAlternateHostEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRestartedOnAlternateHostEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"sourceHost"), aname="_sourceHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmPoweredOnEvent_Def not in ns0.VmRestartedOnAlternateHostEvent_Def.__bases__:
                bases = list(ns0.VmRestartedOnAlternateHostEvent_Def.__bases__)
                bases.insert(0, ns0.VmPoweredOnEvent_Def)
                ns0.VmRestartedOnAlternateHostEvent_Def.__bases__ = tuple(bases)

            ns0.VmPoweredOnEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmReconfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmReconfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmReconfiguredEvent_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineConfigSpec",lazy=True)(pname=(ns,"configSpec"), aname="_configSpec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmReconfiguredEvent_Def.__bases__:
                bases = list(ns0.VmReconfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmReconfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmMessageEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmMessageEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmMessageEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"message"), aname="_message", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineMessage",lazy=True)(pname=(ns,"messageInfo"), aname="_messageInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmMessageEvent_Def.__bases__:
                bases = list(ns0.VmMessageEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmMessageEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmConfigMissingEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmConfigMissingEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmConfigMissingEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmConfigMissingEvent_Def.__bases__:
                bases = list(ns0.VmConfigMissingEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmConfigMissingEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmPowerOffOnIsolationEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmPowerOffOnIsolationEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmPowerOffOnIsolationEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"isolatedHost"), aname="_isolatedHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmPoweredOffEvent_Def not in ns0.VmPowerOffOnIsolationEvent_Def.__bases__:
                bases = list(ns0.VmPowerOffOnIsolationEvent_Def.__bases__)
                bases.insert(0, ns0.VmPoweredOffEvent_Def)
                ns0.VmPowerOffOnIsolationEvent_Def.__bases__ = tuple(bases)

            ns0.VmPoweredOffEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailoverFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailoverFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailoverFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailoverFailed_Def.__bases__:
                bases = list(ns0.VmFailoverFailed_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailoverFailed_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotEnoughResourcesToStartVmEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotEnoughResourcesToStartVmEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotEnoughResourcesToStartVmEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.NotEnoughResourcesToStartVmEvent_Def.__bases__:
                bases = list(ns0.NotEnoughResourcesToStartVmEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.NotEnoughResourcesToStartVmEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmUuidAssignedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmUuidAssignedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmUuidAssignedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmUuidAssignedEvent_Def.__bases__:
                bases = list(ns0.VmUuidAssignedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmUuidAssignedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmUuidChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmUuidChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmUuidChangedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldUuid"), aname="_oldUuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newUuid"), aname="_newUuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmUuidChangedEvent_Def.__bases__:
                bases = list(ns0.VmUuidChangedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmUuidChangedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmWwnConflictEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmWwnConflictEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmWwnConflictEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"conflictedVms"), aname="_conflictedVms", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"conflictedHosts"), aname="_conflictedHosts", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"wwn"), aname="_wwn", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmWwnConflictEvent_Def.__bases__:
                bases = list(ns0.VmWwnConflictEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmWwnConflictEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmAcquiredMksTicketEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmAcquiredMksTicketEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmAcquiredMksTicketEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmAcquiredMksTicketEvent_Def.__bases__:
                bases = list(ns0.VmAcquiredMksTicketEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmAcquiredMksTicketEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostWwnConflictEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostWwnConflictEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostWwnConflictEvent_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"conflictedVms"), aname="_conflictedVms", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"conflictedHosts"), aname="_conflictedHosts", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"wwn"), aname="_wwn", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostWwnConflictEvent_Def.__bases__:
                bases = list(ns0.HostWwnConflictEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostWwnConflictEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmWwnAssignedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmWwnAssignedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmWwnAssignedEvent_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"nodeWwns"), aname="_nodeWwns", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"portWwns"), aname="_portWwns", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmWwnAssignedEvent_Def.__bases__:
                bases = list(ns0.VmWwnAssignedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmWwnAssignedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmWwnChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmWwnChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmWwnChangedEvent_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"oldNodeWwns"), aname="_oldNodeWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"oldPortWwns"), aname="_oldPortWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"newNodeWwns"), aname="_newNodeWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"newPortWwns"), aname="_newPortWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmWwnChangedEvent_Def.__bases__:
                bases = list(ns0.VmWwnChangedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmWwnChangedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostWwnChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostWwnChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostWwnChangedEvent_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"oldNodeWwns"), aname="_oldNodeWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"oldPortWwns"), aname="_oldPortWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"newNodeWwns"), aname="_newNodeWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"newPortWwns"), aname="_newPortWwns", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostWwnChangedEvent_Def.__bases__:
                bases = list(ns0.HostWwnChangedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostWwnChangedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostAdminDisableEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostAdminDisableEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostAdminDisableEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostAdminDisableEvent_Def.__bases__:
                bases = list(ns0.HostAdminDisableEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostAdminDisableEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostAdminEnableEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostAdminEnableEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostAdminEnableEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostAdminEnableEvent_Def.__bases__:
                bases = list(ns0.HostAdminEnableEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostAdminEnableEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostEnableAdminFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostEnableAdminFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostEnableAdminFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","Permission",lazy=True)(pname=(ns,"permissions"), aname="_permissions", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.HostEnableAdminFailedEvent_Def.__bases__:
                bases = list(ns0.HostEnableAdminFailedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.HostEnableAdminFailedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedRelayoutOnVmfs2DatastoreEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedRelayoutOnVmfs2DatastoreEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedRelayoutOnVmfs2DatastoreEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedRelayoutOnVmfs2DatastoreEvent_Def.__bases__:
                bases = list(ns0.VmFailedRelayoutOnVmfs2DatastoreEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedRelayoutOnVmfs2DatastoreEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmFailedRelayoutEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmFailedRelayoutEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmFailedRelayoutEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmFailedRelayoutEvent_Def.__bases__:
                bases = list(ns0.VmFailedRelayoutEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmFailedRelayoutEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRelayoutSuccessfulEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRelayoutSuccessfulEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRelayoutSuccessfulEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmRelayoutSuccessfulEvent_Def.__bases__:
                bases = list(ns0.VmRelayoutSuccessfulEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmRelayoutSuccessfulEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmRelayoutUpToDateEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmRelayoutUpToDateEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmRelayoutUpToDateEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmRelayoutUpToDateEvent_Def.__bases__:
                bases = list(ns0.VmRelayoutUpToDateEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmRelayoutUpToDateEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmConnectedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmConnectedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmConnectedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmConnectedEvent_Def.__bases__:
                bases = list(ns0.VmConnectedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmConnectedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDasUpdateErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDasUpdateErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDasUpdateErrorEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDasUpdateErrorEvent_Def.__bases__:
                bases = list(ns0.VmDasUpdateErrorEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDasUpdateErrorEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoMaintenanceModeDrsRecommendationForVM_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoMaintenanceModeDrsRecommendationForVM")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoMaintenanceModeDrsRecommendationForVM_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.NoMaintenanceModeDrsRecommendationForVM_Def.__bases__:
                bases = list(ns0.NoMaintenanceModeDrsRecommendationForVM_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.NoMaintenanceModeDrsRecommendationForVM_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDasUpdateOkEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDasUpdateOkEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDasUpdateOkEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmDasUpdateOkEvent_Def.__bases__:
                bases = list(ns0.VmDasUpdateOkEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmDasUpdateOkEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskEvent_Def.schema
            TClist = [GTD("urn:vim25","ScheduledTaskEventArgument",lazy=True)(pname=(ns,"scheduledTask"), aname="_scheduledTask", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.ScheduledTaskEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.ScheduledTaskEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskCreatedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskCreatedEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskStartedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskStartedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskStartedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskStartedEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskStartedEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskStartedEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskRemovedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskRemovedEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskReconfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskReconfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskReconfiguredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskReconfiguredEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskReconfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskReconfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskCompletedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskCompletedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskCompletedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskCompletedEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskCompletedEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskCompletedEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskFailedEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskFailedEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskFailedEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskEmailCompletedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskEmailCompletedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskEmailCompletedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"to"), aname="_to", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskEmailCompletedEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskEmailCompletedEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskEmailCompletedEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskEmailFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskEmailFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskEmailFailedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"to"), aname="_to", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskEvent_Def not in ns0.ScheduledTaskEmailFailedEvent_Def.__bases__:
                bases = list(ns0.ScheduledTaskEmailFailedEvent_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskEvent_Def)
                ns0.ScheduledTaskEmailFailedEvent_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmEvent_Def.schema
            TClist = [GTD("urn:vim25","AlarmEventArgument",lazy=True)(pname=(ns,"alarm"), aname="_alarm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.AlarmEvent_Def.__bases__:
                bases = list(ns0.AlarmEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.AlarmEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmCreatedEvent_Def.__bases__:
                bases = list(ns0.AlarmCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmStatusChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmStatusChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmStatusChangedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"source"), aname="_source", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"from"), aname="_from", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"to"), aname="_to", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmStatusChangedEvent_Def.__bases__:
                bases = list(ns0.AlarmStatusChangedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmStatusChangedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmActionTriggeredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmActionTriggeredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmActionTriggeredEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"source"), aname="_source", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmActionTriggeredEvent_Def.__bases__:
                bases = list(ns0.AlarmActionTriggeredEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmActionTriggeredEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmEmailCompletedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmEmailCompletedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmEmailCompletedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"to"), aname="_to", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmEmailCompletedEvent_Def.__bases__:
                bases = list(ns0.AlarmEmailCompletedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmEmailCompletedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmEmailFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmEmailFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmEmailFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"to"), aname="_to", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmEmailFailedEvent_Def.__bases__:
                bases = list(ns0.AlarmEmailFailedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmEmailFailedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmSnmpCompletedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmSnmpCompletedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmSnmpCompletedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmSnmpCompletedEvent_Def.__bases__:
                bases = list(ns0.AlarmSnmpCompletedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmSnmpCompletedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmSnmpFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmSnmpFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmSnmpFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmSnmpFailedEvent_Def.__bases__:
                bases = list(ns0.AlarmSnmpFailedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmSnmpFailedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmScriptCompleteEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmScriptCompleteEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmScriptCompleteEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"script"), aname="_script", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmScriptCompleteEvent_Def.__bases__:
                bases = list(ns0.AlarmScriptCompleteEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmScriptCompleteEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmScriptFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmScriptFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmScriptFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"script"), aname="_script", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmScriptFailedEvent_Def.__bases__:
                bases = list(ns0.AlarmScriptFailedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmScriptFailedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmRemovedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmRemovedEvent_Def.__bases__:
                bases = list(ns0.AlarmRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmReconfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmReconfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmReconfiguredEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AlarmEvent_Def not in ns0.AlarmReconfiguredEvent_Def.__bases__:
                bases = list(ns0.AlarmReconfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.AlarmEvent_Def)
                ns0.AlarmReconfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.AlarmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomFieldEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.CustomFieldEvent_Def.__bases__:
                bases = list(ns0.CustomFieldEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.CustomFieldEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomFieldDefEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldDefEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldDefEvent_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"fieldKey"), aname="_fieldKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomFieldEvent_Def not in ns0.CustomFieldDefEvent_Def.__bases__:
                bases = list(ns0.CustomFieldDefEvent_Def.__bases__)
                bases.insert(0, ns0.CustomFieldEvent_Def)
                ns0.CustomFieldDefEvent_Def.__bases__ = tuple(bases)

            ns0.CustomFieldEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomFieldDefAddedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldDefAddedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldDefAddedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomFieldDefEvent_Def not in ns0.CustomFieldDefAddedEvent_Def.__bases__:
                bases = list(ns0.CustomFieldDefAddedEvent_Def.__bases__)
                bases.insert(0, ns0.CustomFieldDefEvent_Def)
                ns0.CustomFieldDefAddedEvent_Def.__bases__ = tuple(bases)

            ns0.CustomFieldDefEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomFieldDefRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldDefRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldDefRemovedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomFieldDefEvent_Def not in ns0.CustomFieldDefRemovedEvent_Def.__bases__:
                bases = list(ns0.CustomFieldDefRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.CustomFieldDefEvent_Def)
                ns0.CustomFieldDefRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.CustomFieldDefEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomFieldDefRenamedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldDefRenamedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldDefRenamedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomFieldDefEvent_Def not in ns0.CustomFieldDefRenamedEvent_Def.__bases__:
                bases = list(ns0.CustomFieldDefRenamedEvent_Def.__bases__)
                bases.insert(0, ns0.CustomFieldDefEvent_Def)
                ns0.CustomFieldDefRenamedEvent_Def.__bases__ = tuple(bases)

            ns0.CustomFieldDefEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomFieldValueChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomFieldValueChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomFieldValueChangedEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"fieldKey"), aname="_fieldKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomFieldEvent_Def not in ns0.CustomFieldValueChangedEvent_Def.__bases__:
                bases = list(ns0.CustomFieldValueChangedEvent_Def.__bases__)
                bases.insert(0, ns0.CustomFieldEvent_Def)
                ns0.CustomFieldValueChangedEvent_Def.__bases__ = tuple(bases)

            ns0.CustomFieldEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AuthorizationEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AuthorizationEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AuthorizationEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.AuthorizationEvent_Def.__bases__:
                bases = list(ns0.AuthorizationEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.AuthorizationEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PermissionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PermissionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PermissionEvent_Def.schema
            TClist = [GTD("urn:vim25","ManagedEntityEventArgument",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"principal"), aname="_principal", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AuthorizationEvent_Def not in ns0.PermissionEvent_Def.__bases__:
                bases = list(ns0.PermissionEvent_Def.__bases__)
                bases.insert(0, ns0.AuthorizationEvent_Def)
                ns0.PermissionEvent_Def.__bases__ = tuple(bases)

            ns0.AuthorizationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PermissionAddedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PermissionAddedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PermissionAddedEvent_Def.schema
            TClist = [GTD("urn:vim25","RoleEventArgument",lazy=True)(pname=(ns,"role"), aname="_role", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"propagate"), aname="_propagate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PermissionEvent_Def not in ns0.PermissionAddedEvent_Def.__bases__:
                bases = list(ns0.PermissionAddedEvent_Def.__bases__)
                bases.insert(0, ns0.PermissionEvent_Def)
                ns0.PermissionAddedEvent_Def.__bases__ = tuple(bases)

            ns0.PermissionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PermissionUpdatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PermissionUpdatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PermissionUpdatedEvent_Def.schema
            TClist = [GTD("urn:vim25","RoleEventArgument",lazy=True)(pname=(ns,"role"), aname="_role", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"propagate"), aname="_propagate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PermissionEvent_Def not in ns0.PermissionUpdatedEvent_Def.__bases__:
                bases = list(ns0.PermissionUpdatedEvent_Def.__bases__)
                bases.insert(0, ns0.PermissionEvent_Def)
                ns0.PermissionUpdatedEvent_Def.__bases__ = tuple(bases)

            ns0.PermissionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PermissionRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PermissionRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PermissionRemovedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PermissionEvent_Def not in ns0.PermissionRemovedEvent_Def.__bases__:
                bases = list(ns0.PermissionRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.PermissionEvent_Def)
                ns0.PermissionRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.PermissionEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RoleEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RoleEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RoleEvent_Def.schema
            TClist = [GTD("urn:vim25","RoleEventArgument",lazy=True)(pname=(ns,"role"), aname="_role", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.AuthorizationEvent_Def not in ns0.RoleEvent_Def.__bases__:
                bases = list(ns0.RoleEvent_Def.__bases__)
                bases.insert(0, ns0.AuthorizationEvent_Def)
                ns0.RoleEvent_Def.__bases__ = tuple(bases)

            ns0.AuthorizationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RoleAddedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RoleAddedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RoleAddedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"privilegeList"), aname="_privilegeList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RoleEvent_Def not in ns0.RoleAddedEvent_Def.__bases__:
                bases = list(ns0.RoleAddedEvent_Def.__bases__)
                bases.insert(0, ns0.RoleEvent_Def)
                ns0.RoleAddedEvent_Def.__bases__ = tuple(bases)

            ns0.RoleEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RoleUpdatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RoleUpdatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RoleUpdatedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"privilegeList"), aname="_privilegeList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RoleEvent_Def not in ns0.RoleUpdatedEvent_Def.__bases__:
                bases = list(ns0.RoleUpdatedEvent_Def.__bases__)
                bases.insert(0, ns0.RoleEvent_Def)
                ns0.RoleUpdatedEvent_Def.__bases__ = tuple(bases)

            ns0.RoleEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RoleRemovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RoleRemovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RoleRemovedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RoleEvent_Def not in ns0.RoleRemovedEvent_Def.__bases__:
                bases = list(ns0.RoleRemovedEvent_Def.__bases__)
                bases.insert(0, ns0.RoleEvent_Def)
                ns0.RoleRemovedEvent_Def.__bases__ = tuple(bases)

            ns0.RoleEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.DatastoreEvent_Def.__bases__:
                bases = list(ns0.DatastoreEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.DatastoreEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreDestroyedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreDestroyedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreDestroyedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatastoreEvent_Def not in ns0.DatastoreDestroyedEvent_Def.__bases__:
                bases = list(ns0.DatastoreDestroyedEvent_Def.__bases__)
                bases.insert(0, ns0.DatastoreEvent_Def)
                ns0.DatastoreDestroyedEvent_Def.__bases__ = tuple(bases)

            ns0.DatastoreEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreRenamedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreRenamedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreRenamedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldName"), aname="_oldName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newName"), aname="_newName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatastoreEvent_Def not in ns0.DatastoreRenamedEvent_Def.__bases__:
                bases = list(ns0.DatastoreRenamedEvent_Def.__bases__)
                bases.insert(0, ns0.DatastoreEvent_Def)
                ns0.DatastoreRenamedEvent_Def.__bases__ = tuple(bases)

            ns0.DatastoreEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreDuplicatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreDuplicatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreDuplicatedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatastoreEvent_Def not in ns0.DatastoreDuplicatedEvent_Def.__bases__:
                bases = list(ns0.DatastoreDuplicatedEvent_Def.__bases__)
                bases.insert(0, ns0.DatastoreEvent_Def)
                ns0.DatastoreDuplicatedEvent_Def.__bases__ = tuple(bases)

            ns0.DatastoreEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskEvent_Def.schema
            TClist = [GTD("urn:vim25","TaskInfo",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.TaskEvent_Def.__bases__:
                bases = list(ns0.TaskEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.TaskEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskTimeoutEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskTimeoutEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskTimeoutEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskEvent_Def not in ns0.TaskTimeoutEvent_Def.__bases__:
                bases = list(ns0.TaskTimeoutEvent_Def.__bases__)
                bases.insert(0, ns0.TaskEvent_Def)
                ns0.TaskTimeoutEvent_Def.__bases__ = tuple(bases)

            ns0.TaskEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.LicenseEvent_Def.__bases__:
                bases = list(ns0.LicenseEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.LicenseEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ServerLicenseExpiredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ServerLicenseExpiredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ServerLicenseExpiredEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"product"), aname="_product", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.ServerLicenseExpiredEvent_Def.__bases__:
                bases = list(ns0.ServerLicenseExpiredEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.ServerLicenseExpiredEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostLicenseExpiredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostLicenseExpiredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostLicenseExpiredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.HostLicenseExpiredEvent_Def.__bases__:
                bases = list(ns0.HostLicenseExpiredEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.HostLicenseExpiredEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionLicenseExpiredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionLicenseExpiredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionLicenseExpiredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.VMotionLicenseExpiredEvent_Def.__bases__:
                bases = list(ns0.VMotionLicenseExpiredEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.VMotionLicenseExpiredEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoLicenseEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoLicenseEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoLicenseEvent_Def.schema
            TClist = [GTD("urn:vim25","LicenseFeatureInfo",lazy=True)(pname=(ns,"feature"), aname="_feature", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.NoLicenseEvent_Def.__bases__:
                bases = list(ns0.NoLicenseEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.NoLicenseEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseServerUnavailableEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseServerUnavailableEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseServerUnavailableEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"licenseServer"), aname="_licenseServer", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.LicenseServerUnavailableEvent_Def.__bases__:
                bases = list(ns0.LicenseServerUnavailableEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.LicenseServerUnavailableEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseServerAvailableEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseServerAvailableEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseServerAvailableEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"licenseServer"), aname="_licenseServer", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.LicenseServerAvailableEvent_Def.__bases__:
                bases = list(ns0.LicenseServerAvailableEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.LicenseServerAvailableEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseExpiredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseExpiredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseExpiredEvent_Def.schema
            TClist = [GTD("urn:vim25","LicenseFeatureInfo",lazy=True)(pname=(ns,"feature"), aname="_feature", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.LicenseExpiredEvent_Def.__bases__:
                bases = list(ns0.LicenseExpiredEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.LicenseExpiredEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidEditionEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidEditionEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidEditionEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"feature"), aname="_feature", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.InvalidEditionEvent_Def.__bases__:
                bases = list(ns0.InvalidEditionEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.InvalidEditionEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInventoryFullEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInventoryFullEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInventoryFullEvent_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"capacity"), aname="_capacity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.HostInventoryFullEvent_Def.__bases__:
                bases = list(ns0.HostInventoryFullEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.HostInventoryFullEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseRestrictedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseRestrictedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseRestrictedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.LicenseRestrictedEvent_Def.__bases__:
                bases = list(ns0.LicenseRestrictedEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.LicenseRestrictedEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IncorrectHostInformationEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IncorrectHostInformationEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IncorrectHostInformationEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.IncorrectHostInformationEvent_Def.__bases__:
                bases = list(ns0.IncorrectHostInformationEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.IncorrectHostInformationEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnlicensedVirtualMachinesEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnlicensedVirtualMachinesEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnlicensedVirtualMachinesEvent_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"unlicensed"), aname="_unlicensed", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"available"), aname="_available", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.UnlicensedVirtualMachinesEvent_Def.__bases__:
                bases = list(ns0.UnlicensedVirtualMachinesEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.UnlicensedVirtualMachinesEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnlicensedVirtualMachinesFoundEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnlicensedVirtualMachinesFoundEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnlicensedVirtualMachinesFoundEvent_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"available"), aname="_available", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.UnlicensedVirtualMachinesFoundEvent_Def.__bases__:
                bases = list(ns0.UnlicensedVirtualMachinesFoundEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.UnlicensedVirtualMachinesFoundEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AllVirtualMachinesLicensedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AllVirtualMachinesLicensedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AllVirtualMachinesLicensedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.LicenseEvent_Def not in ns0.AllVirtualMachinesLicensedEvent_Def.__bases__:
                bases = list(ns0.AllVirtualMachinesLicensedEvent_Def.__bases__)
                bases.insert(0, ns0.LicenseEvent_Def)
                ns0.AllVirtualMachinesLicensedEvent_Def.__bases__ = tuple(bases)

            ns0.LicenseEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.MigrationEvent_Def.__bases__:
                bases = list(ns0.MigrationEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.MigrationEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationWarningEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationWarningEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationWarningEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationEvent_Def not in ns0.MigrationWarningEvent_Def.__bases__:
                bases = list(ns0.MigrationWarningEvent_Def.__bases__)
                bases.insert(0, ns0.MigrationEvent_Def)
                ns0.MigrationWarningEvent_Def.__bases__ = tuple(bases)

            ns0.MigrationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationErrorEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationEvent_Def not in ns0.MigrationErrorEvent_Def.__bases__:
                bases = list(ns0.MigrationErrorEvent_Def.__bases__)
                bases.insert(0, ns0.MigrationEvent_Def)
                ns0.MigrationErrorEvent_Def.__bases__ = tuple(bases)

            ns0.MigrationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationHostWarningEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationHostWarningEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationHostWarningEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"dstHost"), aname="_dstHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationEvent_Def not in ns0.MigrationHostWarningEvent_Def.__bases__:
                bases = list(ns0.MigrationHostWarningEvent_Def.__bases__)
                bases.insert(0, ns0.MigrationEvent_Def)
                ns0.MigrationHostWarningEvent_Def.__bases__ = tuple(bases)

            ns0.MigrationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationHostErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationHostErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationHostErrorEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"dstHost"), aname="_dstHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationEvent_Def not in ns0.MigrationHostErrorEvent_Def.__bases__:
                bases = list(ns0.MigrationHostErrorEvent_Def.__bases__)
                bases.insert(0, ns0.MigrationEvent_Def)
                ns0.MigrationHostErrorEvent_Def.__bases__ = tuple(bases)

            ns0.MigrationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationResourceWarningEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationResourceWarningEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationResourceWarningEvent_Def.schema
            TClist = [GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"dstPool"), aname="_dstPool", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"dstHost"), aname="_dstHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationEvent_Def not in ns0.MigrationResourceWarningEvent_Def.__bases__:
                bases = list(ns0.MigrationResourceWarningEvent_Def.__bases__)
                bases.insert(0, ns0.MigrationEvent_Def)
                ns0.MigrationResourceWarningEvent_Def.__bases__ = tuple(bases)

            ns0.MigrationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationResourceErrorEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationResourceErrorEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationResourceErrorEvent_Def.schema
            TClist = [GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"dstPool"), aname="_dstPool", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"dstHost"), aname="_dstHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationEvent_Def not in ns0.MigrationResourceErrorEvent_Def.__bases__:
                bases = list(ns0.MigrationResourceErrorEvent_Def.__bases__)
                bases.insert(0, ns0.MigrationEvent_Def)
                ns0.MigrationResourceErrorEvent_Def.__bases__ = tuple(bases)

            ns0.MigrationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.ClusterEvent_Def.__bases__:
                bases = list(ns0.ClusterEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.ClusterEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasEnabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasEnabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasEnabledEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasEnabledEvent_Def.__bases__:
                bases = list(ns0.DasEnabledEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasEnabledEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasDisabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasDisabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasDisabledEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasDisabledEvent_Def.__bases__:
                bases = list(ns0.DasDisabledEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasDisabledEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasAdmissionControlDisabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasAdmissionControlDisabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasAdmissionControlDisabledEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasAdmissionControlDisabledEvent_Def.__bases__:
                bases = list(ns0.DasAdmissionControlDisabledEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasAdmissionControlDisabledEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasAdmissionControlEnabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasAdmissionControlEnabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasAdmissionControlEnabledEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasAdmissionControlEnabledEvent_Def.__bases__:
                bases = list(ns0.DasAdmissionControlEnabledEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasAdmissionControlEnabledEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasHostFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasHostFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasHostFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"failedHost"), aname="_failedHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasHostFailedEvent_Def.__bases__:
                bases = list(ns0.DasHostFailedEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasHostFailedEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasHostIsolatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasHostIsolatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasHostIsolatedEvent_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"isolatedHost"), aname="_isolatedHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasHostIsolatedEvent_Def.__bases__:
                bases = list(ns0.DasHostIsolatedEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasHostIsolatedEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasAgentUnavailableEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasAgentUnavailableEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasAgentUnavailableEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasAgentUnavailableEvent_Def.__bases__:
                bases = list(ns0.DasAgentUnavailableEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasAgentUnavailableEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasAgentFoundEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasAgentFoundEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasAgentFoundEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DasAgentFoundEvent_Def.__bases__:
                bases = list(ns0.DasAgentFoundEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DasAgentFoundEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InsufficientFailoverResourcesEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InsufficientFailoverResourcesEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InsufficientFailoverResourcesEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.InsufficientFailoverResourcesEvent_Def.__bases__:
                bases = list(ns0.InsufficientFailoverResourcesEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.InsufficientFailoverResourcesEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FailoverLevelRestored_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FailoverLevelRestored")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FailoverLevelRestored_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.FailoverLevelRestored_Def.__bases__:
                bases = list(ns0.FailoverLevelRestored_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.FailoverLevelRestored_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterOvercommittedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterOvercommittedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterOvercommittedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.ClusterOvercommittedEvent_Def.__bases__:
                bases = list(ns0.ClusterOvercommittedEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.ClusterOvercommittedEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterStatusChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterStatusChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterStatusChangedEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"oldStatus"), aname="_oldStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"newStatus"), aname="_newStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.ClusterStatusChangedEvent_Def.__bases__:
                bases = list(ns0.ClusterStatusChangedEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.ClusterStatusChangedEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","FolderEventArgument",lazy=True)(pname=(ns,"parent"), aname="_parent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.ClusterCreatedEvent_Def.__bases__:
                bases = list(ns0.ClusterCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.ClusterCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterDestroyedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterDestroyedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterDestroyedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.ClusterDestroyedEvent_Def.__bases__:
                bases = list(ns0.ClusterDestroyedEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.ClusterDestroyedEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsEnabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsEnabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsEnabledEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"behavior"), aname="_behavior", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DrsEnabledEvent_Def.__bases__:
                bases = list(ns0.DrsEnabledEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DrsEnabledEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DrsDisabledEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DrsDisabledEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DrsDisabledEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.DrsDisabledEvent_Def.__bases__:
                bases = list(ns0.DrsDisabledEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.DrsDisabledEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ClusterReconfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ClusterReconfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ClusterReconfiguredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ClusterEvent_Def not in ns0.ClusterReconfiguredEvent_Def.__bases__:
                bases = list(ns0.ClusterReconfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.ClusterEvent_Def)
                ns0.ClusterReconfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.ClusterEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolEvent_Def.schema
            TClist = [GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"resourcePool"), aname="_resourcePool", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.ResourcePoolEvent_Def.__bases__:
                bases = list(ns0.ResourcePoolEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.ResourcePoolEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolCreatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolCreatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolCreatedEvent_Def.schema
            TClist = [GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"parent"), aname="_parent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ResourcePoolEvent_Def not in ns0.ResourcePoolCreatedEvent_Def.__bases__:
                bases = list(ns0.ResourcePoolCreatedEvent_Def.__bases__)
                bases.insert(0, ns0.ResourcePoolEvent_Def)
                ns0.ResourcePoolCreatedEvent_Def.__bases__ = tuple(bases)

            ns0.ResourcePoolEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolDestroyedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolDestroyedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolDestroyedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ResourcePoolEvent_Def not in ns0.ResourcePoolDestroyedEvent_Def.__bases__:
                bases = list(ns0.ResourcePoolDestroyedEvent_Def.__bases__)
                bases.insert(0, ns0.ResourcePoolEvent_Def)
                ns0.ResourcePoolDestroyedEvent_Def.__bases__ = tuple(bases)

            ns0.ResourcePoolEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolMovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolMovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolMovedEvent_Def.schema
            TClist = [GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"oldParent"), aname="_oldParent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"newParent"), aname="_newParent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ResourcePoolEvent_Def not in ns0.ResourcePoolMovedEvent_Def.__bases__:
                bases = list(ns0.ResourcePoolMovedEvent_Def.__bases__)
                bases.insert(0, ns0.ResourcePoolEvent_Def)
                ns0.ResourcePoolMovedEvent_Def.__bases__ = tuple(bases)

            ns0.ResourcePoolEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolReconfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolReconfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolReconfiguredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ResourcePoolEvent_Def not in ns0.ResourcePoolReconfiguredEvent_Def.__bases__:
                bases = list(ns0.ResourcePoolReconfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.ResourcePoolEvent_Def)
                ns0.ResourcePoolReconfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.ResourcePoolEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourceViolatedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourceViolatedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourceViolatedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ResourcePoolEvent_Def not in ns0.ResourceViolatedEvent_Def.__bases__:
                bases = list(ns0.ResourceViolatedEvent_Def.__bases__)
                bases.insert(0, ns0.ResourcePoolEvent_Def)
                ns0.ResourceViolatedEvent_Def.__bases__ = tuple(bases)

            ns0.ResourcePoolEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmResourcePoolMovedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmResourcePoolMovedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmResourcePoolMovedEvent_Def.schema
            TClist = [GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"oldParent"), aname="_oldParent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourcePoolEventArgument",lazy=True)(pname=(ns,"newParent"), aname="_newParent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.VmResourcePoolMovedEvent_Def.__bases__:
                bases = list(ns0.VmResourcePoolMovedEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.VmResourcePoolMovedEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TemplateUpgradeEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TemplateUpgradeEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TemplateUpgradeEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"legacyTemplate"), aname="_legacyTemplate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.TemplateUpgradeEvent_Def.__bases__:
                bases = list(ns0.TemplateUpgradeEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.TemplateUpgradeEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TemplateBeingUpgradedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TemplateBeingUpgradedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TemplateBeingUpgradedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TemplateUpgradeEvent_Def not in ns0.TemplateBeingUpgradedEvent_Def.__bases__:
                bases = list(ns0.TemplateBeingUpgradedEvent_Def.__bases__)
                bases.insert(0, ns0.TemplateUpgradeEvent_Def)
                ns0.TemplateBeingUpgradedEvent_Def.__bases__ = tuple(bases)

            ns0.TemplateUpgradeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TemplateUpgradeFailedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TemplateUpgradeFailedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TemplateUpgradeFailedEvent_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TemplateUpgradeEvent_Def not in ns0.TemplateUpgradeFailedEvent_Def.__bases__:
                bases = list(ns0.TemplateUpgradeFailedEvent_Def.__bases__)
                bases.insert(0, ns0.TemplateUpgradeEvent_Def)
                ns0.TemplateUpgradeFailedEvent_Def.__bases__ = tuple(bases)

            ns0.TemplateUpgradeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TemplateUpgradedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TemplateUpgradedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TemplateUpgradedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TemplateUpgradeEvent_Def not in ns0.TemplateUpgradedEvent_Def.__bases__:
                bases = list(ns0.TemplateUpgradedEvent_Def.__bases__)
                bases.insert(0, ns0.TemplateUpgradeEvent_Def)
                ns0.TemplateUpgradedEvent_Def.__bases__ = tuple(bases)

            ns0.TemplateUpgradeEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationEvent_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"logLocation"), aname="_logLocation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmEvent_Def not in ns0.CustomizationEvent_Def.__bases__:
                bases = list(ns0.CustomizationEvent_Def.__bases__)
                bases.insert(0, ns0.VmEvent_Def)
                ns0.CustomizationEvent_Def.__bases__ = tuple(bases)

            ns0.VmEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationStartedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationStartedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationStartedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationEvent_Def not in ns0.CustomizationStartedEvent_Def.__bases__:
                bases = list(ns0.CustomizationStartedEvent_Def.__bases__)
                bases.insert(0, ns0.CustomizationEvent_Def)
                ns0.CustomizationStartedEvent_Def.__bases__ = tuple(bases)

            ns0.CustomizationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationSucceeded_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationSucceeded")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationSucceeded_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationEvent_Def not in ns0.CustomizationSucceeded_Def.__bases__:
                bases = list(ns0.CustomizationSucceeded_Def.__bases__)
                bases.insert(0, ns0.CustomizationEvent_Def)
                ns0.CustomizationSucceeded_Def.__bases__ = tuple(bases)

            ns0.CustomizationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationEvent_Def not in ns0.CustomizationFailed_Def.__bases__:
                bases = list(ns0.CustomizationFailed_Def.__bases__)
                bases.insert(0, ns0.CustomizationEvent_Def)
                ns0.CustomizationFailed_Def.__bases__ = tuple(bases)

            ns0.CustomizationEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationUnknownFailure_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationUnknownFailure")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationUnknownFailure_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFailed_Def not in ns0.CustomizationUnknownFailure_Def.__bases__:
                bases = list(ns0.CustomizationUnknownFailure_Def.__bases__)
                bases.insert(0, ns0.CustomizationFailed_Def)
                ns0.CustomizationUnknownFailure_Def.__bases__ = tuple(bases)

            ns0.CustomizationFailed_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationSysprepFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationSysprepFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationSysprepFailed_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"sysprepVersion"), aname="_sysprepVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"systemVersion"), aname="_systemVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFailed_Def not in ns0.CustomizationSysprepFailed_Def.__bases__:
                bases = list(ns0.CustomizationSysprepFailed_Def.__bases__)
                bases.insert(0, ns0.CustomizationFailed_Def)
                ns0.CustomizationSysprepFailed_Def.__bases__ = tuple(bases)

            ns0.CustomizationFailed_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationLinuxIdentityFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationLinuxIdentityFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationLinuxIdentityFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFailed_Def not in ns0.CustomizationLinuxIdentityFailed_Def.__bases__:
                bases = list(ns0.CustomizationLinuxIdentityFailed_Def.__bases__)
                bases.insert(0, ns0.CustomizationFailed_Def)
                ns0.CustomizationLinuxIdentityFailed_Def.__bases__ = tuple(bases)

            ns0.CustomizationFailed_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationNetworkSetupFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationNetworkSetupFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationNetworkSetupFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFailed_Def not in ns0.CustomizationNetworkSetupFailed_Def.__bases__:
                bases = list(ns0.CustomizationNetworkSetupFailed_Def.__bases__)
                bases.insert(0, ns0.CustomizationFailed_Def)
                ns0.CustomizationNetworkSetupFailed_Def.__bases__ = tuple(bases)

            ns0.CustomizationFailed_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LockerMisconfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LockerMisconfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LockerMisconfiguredEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.LockerMisconfiguredEvent_Def.__bases__:
                bases = list(ns0.LockerMisconfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.LockerMisconfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LockerReconfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LockerReconfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LockerReconfiguredEvent_Def.schema
            TClist = [GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"oldDatastore"), aname="_oldDatastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DatastoreEventArgument",lazy=True)(pname=(ns,"newDatastore"), aname="_newDatastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.Event_Def not in ns0.LockerReconfiguredEvent_Def.__bases__:
                bases = list(ns0.LockerReconfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.Event_Def)
                ns0.LockerReconfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.Event_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoDatastoresConfiguredEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoDatastoresConfiguredEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoDatastoresConfiguredEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.NoDatastoresConfiguredEvent_Def.__bases__:
                bases = list(ns0.NoDatastoresConfiguredEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.NoDatastoresConfiguredEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AdminPasswordNotChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AdminPasswordNotChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AdminPasswordNotChangedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.AdminPasswordNotChangedEvent_Def.__bases__:
                bases = list(ns0.AdminPasswordNotChangedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.AdminPasswordNotChangedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VimAccountPasswordChangedEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VimAccountPasswordChangedEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VimAccountPasswordChangedEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostEvent_Def not in ns0.VimAccountPasswordChangedEvent_Def.__bases__:
                bases = list(ns0.VimAccountPasswordChangedEvent_Def.__bases__)
                bases.insert(0, ns0.HostEvent_Def)
                ns0.VimAccountPasswordChangedEvent_Def.__bases__ = tuple(bases)

            ns0.HostEvent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventArgument_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.EventArgument_Def.__bases__:
                bases = list(ns0.EventArgument_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.EventArgument_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RoleEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RoleEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RoleEventArgument_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"roleId"), aname="_roleId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EventArgument_Def not in ns0.RoleEventArgument_Def.__bases__:
                bases = list(ns0.RoleEventArgument_Def.__bases__)
                bases.insert(0, ns0.EventArgument_Def)
                ns0.RoleEventArgument_Def.__bases__ = tuple(bases)

            ns0.EventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EntityEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EntityEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EntityEventArgument_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EventArgument_Def not in ns0.EntityEventArgument_Def.__bases__:
                bases = list(ns0.EntityEventArgument_Def.__bases__)
                bases.insert(0, ns0.EventArgument_Def)
                ns0.EntityEventArgument_Def.__bases__ = tuple(bases)

            ns0.EventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ManagedEntityEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ManagedEntityEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ManagedEntityEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.ManagedEntityEventArgument_Def.__bases__:
                bases = list(ns0.ManagedEntityEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.ManagedEntityEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FolderEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FolderEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FolderEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"folder"), aname="_folder", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.FolderEventArgument_Def.__bases__:
                bases = list(ns0.FolderEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.FolderEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatacenterEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatacenterEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatacenterEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datacenter"), aname="_datacenter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.DatacenterEventArgument_Def.__bases__:
                bases = list(ns0.DatacenterEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.DatacenterEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ComputeResourceEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ComputeResourceEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ComputeResourceEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"computeResource"), aname="_computeResource", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.ComputeResourceEventArgument_Def.__bases__:
                bases = list(ns0.ComputeResourceEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.ComputeResourceEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourcePoolEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourcePoolEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourcePoolEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"resourcePool"), aname="_resourcePool", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.ResourcePoolEventArgument_Def.__bases__:
                bases = list(ns0.ResourcePoolEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.ResourcePoolEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.HostEventArgument_Def.__bases__:
                bases = list(ns0.HostEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.HostEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostEventArgument_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostEventArgument")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostEventArgument_Def.schema
            TClist = [GTD("urn:vim25","HostEventArgument",lazy=True)(pname=(ns,"HostEventArgument"), aname="_HostEventArgument", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostEventArgument = []
                    return
            Holder.__name__ = "ArrayOfHostEventArgument_Holder"
            self.pyclass = Holder

    class VmEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.VmEventArgument_Def.__bases__:
                bases = list(ns0.VmEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.VmEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVmEventArgument_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVmEventArgument")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVmEventArgument_Def.schema
            TClist = [GTD("urn:vim25","VmEventArgument",lazy=True)(pname=(ns,"VmEventArgument"), aname="_VmEventArgument", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VmEventArgument = []
                    return
            Holder.__name__ = "ArrayOfVmEventArgument_Holder"
            self.pyclass = Holder

    class DatastoreEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.DatastoreEventArgument_Def.__bases__:
                bases = list(ns0.DatastoreEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.DatastoreEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlarmEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlarmEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlarmEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"alarm"), aname="_alarm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.AlarmEventArgument_Def.__bases__:
                bases = list(ns0.AlarmEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.AlarmEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskEventArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskEventArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskEventArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"scheduledTask"), aname="_scheduledTask", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.EntityEventArgument_Def not in ns0.ScheduledTaskEventArgument_Def.__bases__:
                bases = list(ns0.ScheduledTaskEventArgument_Def.__bases__)
                bases.insert(0, ns0.EntityEventArgument_Def)
                ns0.ScheduledTaskEventArgument_Def.__bases__ = tuple(bases)

            ns0.EntityEventArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EventCategory_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "EventCategory")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class EventDescriptionEventDetail_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventDescriptionEventDetail")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventDescriptionEventDetail_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"category"), aname="_category", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"formatOnDatacenter"), aname="_formatOnDatacenter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"formatOnComputeResource"), aname="_formatOnComputeResource", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"formatOnHost"), aname="_formatOnHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"formatOnVm"), aname="_formatOnVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fullFormat"), aname="_fullFormat", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.EventDescriptionEventDetail_Def.__bases__:
                bases = list(ns0.EventDescriptionEventDetail_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.EventDescriptionEventDetail_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfEventDescriptionEventDetail_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfEventDescriptionEventDetail")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfEventDescriptionEventDetail_Def.schema
            TClist = [GTD("urn:vim25","EventDescriptionEventDetail",lazy=True)(pname=(ns,"EventDescriptionEventDetail"), aname="_EventDescriptionEventDetail", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._EventDescriptionEventDetail = []
                    return
            Holder.__name__ = "ArrayOfEventDescriptionEventDetail_Holder"
            self.pyclass = Holder

    class EventDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventDescription_Def.schema
            TClist = [GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"category"), aname="_category", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","EventDescriptionEventDetail",lazy=True)(pname=(ns,"eventInfo"), aname="_eventInfo", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.EventDescription_Def.__bases__:
                bases = list(ns0.EventDescription_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.EventDescription_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EventFilterSpecRecursionOption_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "EventFilterSpecRecursionOption")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class EventFilterSpecByEntity_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventFilterSpecByEntity")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventFilterSpecByEntity_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","EventFilterSpecRecursionOption",lazy=True)(pname=(ns,"recursion"), aname="_recursion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.EventFilterSpecByEntity_Def.__bases__:
                bases = list(ns0.EventFilterSpecByEntity_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.EventFilterSpecByEntity_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EventFilterSpecByTime_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventFilterSpecByTime")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventFilterSpecByTime_Def.schema
            TClist = [ZSI.TCtimes.gDateTime(pname=(ns,"beginTime"), aname="_beginTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"endTime"), aname="_endTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.EventFilterSpecByTime_Def.__bases__:
                bases = list(ns0.EventFilterSpecByTime_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.EventFilterSpecByTime_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EventFilterSpecByUsername_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventFilterSpecByUsername")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventFilterSpecByUsername_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"systemUser"), aname="_systemUser", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userList"), aname="_userList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.EventFilterSpecByUsername_Def.__bases__:
                bases = list(ns0.EventFilterSpecByUsername_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.EventFilterSpecByUsername_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EventFilterSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "EventFilterSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.EventFilterSpec_Def.schema
            TClist = [GTD("urn:vim25","EventFilterSpecByEntity",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","EventFilterSpecByTime",lazy=True)(pname=(ns,"time"), aname="_time", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","EventFilterSpecByUsername",lazy=True)(pname=(ns,"userName"), aname="_userName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"eventChainId"), aname="_eventChainId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"alarm"), aname="_alarm", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"scheduledTask"), aname="_scheduledTask", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"disableFullMessage"), aname="_disableFullMessage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"category"), aname="_category", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.EventFilterSpec_Def.__bases__:
                bases = list(ns0.EventFilterSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.EventFilterSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReadNextEventsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReadNextEventsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReadNextEventsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxCount"), aname="_maxCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._maxCount = None
                    return
            Holder.__name__ = "ReadNextEventsRequestType_Holder"
            self.pyclass = Holder

    class ReadPreviousEventsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReadPreviousEventsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReadPreviousEventsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxCount"), aname="_maxCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._maxCount = None
                    return
            Holder.__name__ = "ReadPreviousEventsRequestType_Holder"
            self.pyclass = Holder

    class CreateCollectorForEventsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateCollectorForEventsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateCollectorForEventsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","EventFilterSpec",lazy=True)(pname=(ns,"filter"), aname="_filter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._filter = None
                    return
            Holder.__name__ = "CreateCollectorForEventsRequestType_Holder"
            self.pyclass = Holder

    class LogUserEventRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "LogUserEventRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.LogUserEventRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"msg"), aname="_msg", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._msg = None
                    return
            Holder.__name__ = "LogUserEventRequestType_Holder"
            self.pyclass = Holder

    class QueryEventsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryEventsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryEventsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","EventFilterSpec",lazy=True)(pname=(ns,"filter"), aname="_filter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._filter = None
                    return
            Holder.__name__ = "QueryEventsRequestType_Holder"
            self.pyclass = Holder

    class PostEventRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PostEventRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.PostEventRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Event",lazy=True)(pname=(ns,"eventToPost"), aname="_eventToPost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskInfo",lazy=True)(pname=(ns,"taskInfo"), aname="_taskInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._eventToPost = None
                    self._taskInfo = None
                    return
            Holder.__name__ = "PostEventRequestType_Holder"
            self.pyclass = Holder

    class AdminDisabled_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AdminDisabled")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AdminDisabled_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConfigFault_Def not in ns0.AdminDisabled_Def.__bases__:
                bases = list(ns0.AdminDisabled_Def.__bases__)
                bases.insert(0, ns0.HostConfigFault_Def)
                ns0.AdminDisabled_Def.__bases__ = tuple(bases)

            ns0.HostConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AdminNotDisabled_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AdminNotDisabled")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AdminNotDisabled_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConfigFault_Def not in ns0.AdminNotDisabled_Def.__bases__:
                bases = list(ns0.AdminNotDisabled_Def.__bases__)
                bases.insert(0, ns0.HostConfigFault_Def)
                ns0.AdminNotDisabled_Def.__bases__ = tuple(bases)

            ns0.HostConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AffinityType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AffinityType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class AffinityConfigured_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AffinityConfigured")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AffinityConfigured_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"configuredAffinity"), aname="_configuredAffinity", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.AffinityConfigured_Def.__bases__:
                bases = list(ns0.AffinityConfigured_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.AffinityConfigured_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AgentInstallFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AgentInstallFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AgentInstallFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.AgentInstallFailed_Def.__bases__:
                bases = list(ns0.AgentInstallFailed_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.AgentInstallFailed_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlreadyBeingManaged_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlreadyBeingManaged")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlreadyBeingManaged_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.AlreadyBeingManaged_Def.__bases__:
                bases = list(ns0.AlreadyBeingManaged_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.AlreadyBeingManaged_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlreadyConnected_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlreadyConnected")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlreadyConnected_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.AlreadyConnected_Def.__bases__:
                bases = list(ns0.AlreadyConnected_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.AlreadyConnected_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlreadyExists_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlreadyExists")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlreadyExists_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.AlreadyExists_Def.__bases__:
                bases = list(ns0.AlreadyExists_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.AlreadyExists_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AlreadyUpgraded_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AlreadyUpgraded")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AlreadyUpgraded_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.AlreadyUpgraded_Def.__bases__:
                bases = list(ns0.AlreadyUpgraded_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.AlreadyUpgraded_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ApplicationQuiesceFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ApplicationQuiesceFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ApplicationQuiesceFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.ApplicationQuiesceFault_Def.__bases__:
                bases = list(ns0.ApplicationQuiesceFault_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.ApplicationQuiesceFault_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AuthMinimumAdminPermission_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AuthMinimumAdminPermission")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AuthMinimumAdminPermission_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.AuthMinimumAdminPermission_Def.__bases__:
                bases = list(ns0.AuthMinimumAdminPermission_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.AuthMinimumAdminPermission_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotAccessFile_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotAccessFile")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotAccessFile_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.CannotAccessFile_Def.__bases__:
                bases = list(ns0.CannotAccessFile_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.CannotAccessFile_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotAccessLocalSource_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotAccessLocalSource")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotAccessLocalSource_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.CannotAccessLocalSource_Def.__bases__:
                bases = list(ns0.CannotAccessLocalSource_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.CannotAccessLocalSource_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotAccessNetwork_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotAccessNetwork")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotAccessNetwork_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessVmDevice_Def not in ns0.CannotAccessNetwork_Def.__bases__:
                bases = list(ns0.CannotAccessNetwork_Def.__bases__)
                bases.insert(0, ns0.CannotAccessVmDevice_Def)
                ns0.CannotAccessNetwork_Def.__bases__ = tuple(bases)

            ns0.CannotAccessVmDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotAccessVmComponent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotAccessVmComponent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotAccessVmComponent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.CannotAccessVmComponent_Def.__bases__:
                bases = list(ns0.CannotAccessVmComponent_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.CannotAccessVmComponent_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotAccessVmConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotAccessVmConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotAccessVmConfig_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessVmComponent_Def not in ns0.CannotAccessVmConfig_Def.__bases__:
                bases = list(ns0.CannotAccessVmConfig_Def.__bases__)
                bases.insert(0, ns0.CannotAccessVmComponent_Def)
                ns0.CannotAccessVmConfig_Def.__bases__ = tuple(bases)

            ns0.CannotAccessVmComponent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotAccessVmDevice_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotAccessVmDevice")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotAccessVmDevice_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"backing"), aname="_backing", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"connected"), aname="_connected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessVmComponent_Def not in ns0.CannotAccessVmDevice_Def.__bases__:
                bases = list(ns0.CannotAccessVmDevice_Def.__bases__)
                bases.insert(0, ns0.CannotAccessVmComponent_Def)
                ns0.CannotAccessVmDevice_Def.__bases__ = tuple(bases)

            ns0.CannotAccessVmComponent_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotAccessVmDisk_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotAccessVmDisk")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotAccessVmDisk_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessVmDevice_Def not in ns0.CannotAccessVmDisk_Def.__bases__:
                bases = list(ns0.CannotAccessVmDisk_Def.__bases__)
                bases.insert(0, ns0.CannotAccessVmDevice_Def)
                ns0.CannotAccessVmDisk_Def.__bases__ = tuple(bases)

            ns0.CannotAccessVmDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotCreateFile_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotCreateFile")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotCreateFile_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.CannotCreateFile_Def.__bases__:
                bases = list(ns0.CannotCreateFile_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.CannotCreateFile_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotDecryptPasswords_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotDecryptPasswords")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotDecryptPasswords_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.CannotDecryptPasswords_Def.__bases__:
                bases = list(ns0.CannotDecryptPasswords_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.CannotDecryptPasswords_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotDeleteFile_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotDeleteFile")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotDeleteFile_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.CannotDeleteFile_Def.__bases__:
                bases = list(ns0.CannotDeleteFile_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.CannotDeleteFile_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotDisableSnapshot_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotDisableSnapshot")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotDisableSnapshot_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.CannotDisableSnapshot_Def.__bases__:
                bases = list(ns0.CannotDisableSnapshot_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.CannotDisableSnapshot_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CannotModifyConfigCpuRequirements_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CannotModifyConfigCpuRequirements")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CannotModifyConfigCpuRequirements_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.CannotModifyConfigCpuRequirements_Def.__bases__:
                bases = list(ns0.CannotModifyConfigCpuRequirements_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.CannotModifyConfigCpuRequirements_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ConcurrentAccess_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ConcurrentAccess")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ConcurrentAccess_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.ConcurrentAccess_Def.__bases__:
                bases = list(ns0.ConcurrentAccess_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.ConcurrentAccess_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CpuCompatibilityUnknown_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CpuCompatibilityUnknown")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CpuCompatibilityUnknown_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CpuIncompatible_Def not in ns0.CpuCompatibilityUnknown_Def.__bases__:
                bases = list(ns0.CpuCompatibilityUnknown_Def.__bases__)
                bases.insert(0, ns0.CpuIncompatible_Def)
                ns0.CpuCompatibilityUnknown_Def.__bases__ = tuple(bases)

            ns0.CpuIncompatible_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CpuIncompatible_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CpuIncompatible")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CpuIncompatible_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"level"), aname="_level", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"registerName"), aname="_registerName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"registerBits"), aname="_registerBits", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"desiredBits"), aname="_desiredBits", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.CpuIncompatible_Def.__bases__:
                bases = list(ns0.CpuIncompatible_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.CpuIncompatible_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CpuIncompatible1ECX_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CpuIncompatible1ECX")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CpuIncompatible1ECX_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"sse3"), aname="_sse3", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"ssse3"), aname="_ssse3", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sse41"), aname="_sse41", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sse42"), aname="_sse42", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"other"), aname="_other", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"otherOnly"), aname="_otherOnly", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CpuIncompatible_Def not in ns0.CpuIncompatible1ECX_Def.__bases__:
                bases = list(ns0.CpuIncompatible1ECX_Def.__bases__)
                bases.insert(0, ns0.CpuIncompatible_Def)
                ns0.CpuIncompatible1ECX_Def.__bases__ = tuple(bases)

            ns0.CpuIncompatible_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CpuIncompatible81EDX_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CpuIncompatible81EDX")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CpuIncompatible81EDX_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"nx"), aname="_nx", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"ffxsr"), aname="_ffxsr", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"rdtscp"), aname="_rdtscp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"lm"), aname="_lm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"other"), aname="_other", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"otherOnly"), aname="_otherOnly", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CpuIncompatible_Def not in ns0.CpuIncompatible81EDX_Def.__bases__:
                bases = list(ns0.CpuIncompatible81EDX_Def.__bases__)
                bases.insert(0, ns0.CpuIncompatible_Def)
                ns0.CpuIncompatible81EDX_Def.__bases__ = tuple(bases)

            ns0.CpuIncompatible_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.CustomizationFault_Def.__bases__:
                bases = list(ns0.CustomizationFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.CustomizationFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationPending_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationPending")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationPending_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.CustomizationPending_Def.__bases__:
                bases = list(ns0.CustomizationPending_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.CustomizationPending_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DasConfigFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DasConfigFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DasConfigFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.DasConfigFault_Def.__bases__:
                bases = list(ns0.DasConfigFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.DasConfigFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatabaseError_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatabaseError")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatabaseError_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RuntimeFault_Def not in ns0.DatabaseError_Def.__bases__:
                bases = list(ns0.DatabaseError_Def.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.DatabaseError_Def.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatacenterMismatchArgument_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatacenterMismatchArgument")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatacenterMismatchArgument_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"inputDatacenter"), aname="_inputDatacenter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DatacenterMismatchArgument_Def.__bases__:
                bases = list(ns0.DatacenterMismatchArgument_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DatacenterMismatchArgument_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfDatacenterMismatchArgument_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfDatacenterMismatchArgument")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfDatacenterMismatchArgument_Def.schema
            TClist = [GTD("urn:vim25","DatacenterMismatchArgument",lazy=True)(pname=(ns,"DatacenterMismatchArgument"), aname="_DatacenterMismatchArgument", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._DatacenterMismatchArgument = []
                    return
            Holder.__name__ = "ArrayOfDatacenterMismatchArgument_Holder"
            self.pyclass = Holder

    class DatacenterMismatch_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatacenterMismatch")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatacenterMismatch_Def.schema
            TClist = [GTD("urn:vim25","DatacenterMismatchArgument",lazy=True)(pname=(ns,"invalidArgument"), aname="_invalidArgument", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"expectedDatacenter"), aname="_expectedDatacenter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.DatacenterMismatch_Def.__bases__:
                bases = list(ns0.DatacenterMismatch_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.DatacenterMismatch_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DatastoreNotWritableOnHost_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreNotWritableOnHost")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreNotWritableOnHost_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDatastore_Def not in ns0.DatastoreNotWritableOnHost_Def.__bases__:
                bases = list(ns0.DatastoreNotWritableOnHost_Def.__bases__)
                bases.insert(0, ns0.InvalidDatastore_Def)
                ns0.DatastoreNotWritableOnHost_Def.__bases__ = tuple(bases)

            ns0.InvalidDatastore_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DestinationSwitchFull_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DestinationSwitchFull")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DestinationSwitchFull_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessNetwork_Def not in ns0.DestinationSwitchFull_Def.__bases__:
                bases = list(ns0.DestinationSwitchFull_Def.__bases__)
                bases.insert(0, ns0.CannotAccessNetwork_Def)
                ns0.DestinationSwitchFull_Def.__bases__ = tuple(bases)

            ns0.CannotAccessNetwork_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DeviceBackingNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DeviceBackingNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DeviceBackingNotSupported_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"backing"), aname="_backing", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.DeviceBackingNotSupported_Def.__bases__:
                bases = list(ns0.DeviceBackingNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.DeviceBackingNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DeviceControllerNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DeviceControllerNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DeviceControllerNotSupported_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"controller"), aname="_controller", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.DeviceControllerNotSupported_Def.__bases__:
                bases = list(ns0.DeviceControllerNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.DeviceControllerNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DeviceNotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DeviceNotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DeviceNotFound_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDeviceSpec_Def not in ns0.DeviceNotFound_Def.__bases__:
                bases = list(ns0.DeviceNotFound_Def.__bases__)
                bases.insert(0, ns0.InvalidDeviceSpec_Def)
                ns0.DeviceNotFound_Def.__bases__ = tuple(bases)

            ns0.InvalidDeviceSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DeviceNotSupportedReason_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DeviceNotSupportedReason")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class DeviceNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DeviceNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DeviceNotSupported_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"reason"), aname="_reason", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.DeviceNotSupported_Def.__bases__:
                bases = list(ns0.DeviceNotSupported_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.DeviceNotSupported_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DisableAdminNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DisableAdminNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DisableAdminNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConfigFault_Def not in ns0.DisableAdminNotSupported_Def.__bases__:
                bases = list(ns0.DisableAdminNotSupported_Def.__bases__)
                bases.insert(0, ns0.HostConfigFault_Def)
                ns0.DisableAdminNotSupported_Def.__bases__ = tuple(bases)

            ns0.HostConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DisallowedDiskModeChange_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DisallowedDiskModeChange")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DisallowedDiskModeChange_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDeviceSpec_Def not in ns0.DisallowedDiskModeChange_Def.__bases__:
                bases = list(ns0.DisallowedDiskModeChange_Def.__bases__)
                bases.insert(0, ns0.InvalidDeviceSpec_Def)
                ns0.DisallowedDiskModeChange_Def.__bases__ = tuple(bases)

            ns0.InvalidDeviceSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DisallowedMigrationDeviceAttached_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DisallowedMigrationDeviceAttached")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DisallowedMigrationDeviceAttached_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.DisallowedMigrationDeviceAttached_Def.__bases__:
                bases = list(ns0.DisallowedMigrationDeviceAttached_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.DisallowedMigrationDeviceAttached_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DiskNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DiskNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DiskNotSupported_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"disk"), aname="_disk", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.DiskNotSupported_Def.__bases__:
                bases = list(ns0.DiskNotSupported_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.DiskNotSupported_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DuplicateName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DuplicateName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DuplicateName_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"object"), aname="_object", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.DuplicateName_Def.__bases__:
                bases = list(ns0.DuplicateName_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.DuplicateName_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ExpiredAddonLicense_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExpiredAddonLicense")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExpiredAddonLicense_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ExpiredFeatureLicense_Def not in ns0.ExpiredAddonLicense_Def.__bases__:
                bases = list(ns0.ExpiredAddonLicense_Def.__bases__)
                bases.insert(0, ns0.ExpiredFeatureLicense_Def)
                ns0.ExpiredAddonLicense_Def.__bases__ = tuple(bases)

            ns0.ExpiredFeatureLicense_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ExpiredEditionLicense_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExpiredEditionLicense")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExpiredEditionLicense_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ExpiredFeatureLicense_Def not in ns0.ExpiredEditionLicense_Def.__bases__:
                bases = list(ns0.ExpiredEditionLicense_Def.__bases__)
                bases.insert(0, ns0.ExpiredFeatureLicense_Def)
                ns0.ExpiredEditionLicense_Def.__bases__ = tuple(bases)

            ns0.ExpiredFeatureLicense_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ExpiredFeatureLicense_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExpiredFeatureLicense")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExpiredFeatureLicense_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"feature"), aname="_feature", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"count"), aname="_count", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"expirationDate"), aname="_expirationDate", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughLicenses_Def not in ns0.ExpiredFeatureLicense_Def.__bases__:
                bases = list(ns0.ExpiredFeatureLicense_Def.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.ExpiredFeatureLicense_Def.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ExtendedFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ExtendedFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ExtendedFault_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"faultTypeId"), aname="_faultTypeId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","KeyValue",lazy=True)(pname=(ns,"data"), aname="_data", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.ExtendedFault_Def.__bases__:
                bases = list(ns0.ExtendedFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.ExtendedFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileAlreadyExists_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileAlreadyExists")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileAlreadyExists_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.FileAlreadyExists_Def.__bases__:
                bases = list(ns0.FileAlreadyExists_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.FileAlreadyExists_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileBackedPortNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileBackedPortNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileBackedPortNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.FileBackedPortNotSupported_Def.__bases__:
                bases = list(ns0.FileBackedPortNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.FileBackedPortNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileFault_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"file"), aname="_file", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.FileFault_Def.__bases__:
                bases = list(ns0.FileFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.FileFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileLocked_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileLocked")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileLocked_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.FileLocked_Def.__bases__:
                bases = list(ns0.FileLocked_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.FileLocked_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileNotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileNotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileNotFound_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.FileNotFound_Def.__bases__:
                bases = list(ns0.FileNotFound_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.FileNotFound_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileNotWritable_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileNotWritable")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileNotWritable_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.FileNotWritable_Def.__bases__:
                bases = list(ns0.FileNotWritable_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.FileNotWritable_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileTooLarge_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileTooLarge")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileTooLarge_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"fileSize"), aname="_fileSize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"maxFileSize"), aname="_maxFileSize", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.FileTooLarge_Def.__bases__:
                bases = list(ns0.FileTooLarge_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.FileTooLarge_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FilesystemQuiesceFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FilesystemQuiesceFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FilesystemQuiesceFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.FilesystemQuiesceFault_Def.__bases__:
                bases = list(ns0.FilesystemQuiesceFault_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.FilesystemQuiesceFault_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FullStorageVMotionNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FullStorageVMotionNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FullStorageVMotionNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFeatureNotSupported_Def not in ns0.FullStorageVMotionNotSupported_Def.__bases__:
                bases = list(ns0.FullStorageVMotionNotSupported_Def.__bases__)
                bases.insert(0, ns0.MigrationFeatureNotSupported_Def)
                ns0.FullStorageVMotionNotSupported_Def.__bases__ = tuple(bases)

            ns0.MigrationFeatureNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GenericDrsFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GenericDrsFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GenericDrsFault_Def.schema
            TClist = [GTD("urn:vim25","MethodFault",lazy=True)(pname=(ns,"hostFaults"), aname="_hostFaults", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.GenericDrsFault_Def.__bases__:
                bases = list(ns0.GenericDrsFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.GenericDrsFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class GenericVmConfigFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GenericVmConfigFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GenericVmConfigFault_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"reason"), aname="_reason", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.GenericVmConfigFault_Def.__bases__:
                bases = list(ns0.GenericVmConfigFault_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.GenericVmConfigFault_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HAErrorsAtDest_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HAErrorsAtDest")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HAErrorsAtDest_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.HAErrorsAtDest_Def.__bases__:
                bases = list(ns0.HAErrorsAtDest_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.HAErrorsAtDest_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConfigFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConfigFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConfigFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.HostConfigFault_Def.__bases__:
                bases = list(ns0.HostConfigFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.HostConfigFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConnectFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConnectFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConnectFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.HostConnectFault_Def.__bases__:
                bases = list(ns0.HostConnectFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.HostConnectFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInventoryFull_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInventoryFull")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInventoryFull_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"capacity"), aname="_capacity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughLicenses_Def not in ns0.HostInventoryFull_Def.__bases__:
                bases = list(ns0.HostInventoryFull_Def.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.HostInventoryFull_Def.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostPowerOpFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPowerOpFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPowerOpFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.HostPowerOpFailed_Def.__bases__:
                bases = list(ns0.HostPowerOpFailed_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.HostPowerOpFailed_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HotSnapshotMoveNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HotSnapshotMoveNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HotSnapshotMoveNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotCopyNotSupported_Def not in ns0.HotSnapshotMoveNotSupported_Def.__bases__:
                bases = list(ns0.HotSnapshotMoveNotSupported_Def.__bases__)
                bases.insert(0, ns0.SnapshotCopyNotSupported_Def)
                ns0.HotSnapshotMoveNotSupported_Def.__bases__ = tuple(bases)

            ns0.SnapshotCopyNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IDEDiskNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IDEDiskNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IDEDiskNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DiskNotSupported_Def not in ns0.IDEDiskNotSupported_Def.__bases__:
                bases = list(ns0.IDEDiskNotSupported_Def.__bases__)
                bases.insert(0, ns0.DiskNotSupported_Def)
                ns0.IDEDiskNotSupported_Def.__bases__ = tuple(bases)

            ns0.DiskNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InaccessibleDatastore_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InaccessibleDatastore")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InaccessibleDatastore_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDatastore_Def not in ns0.InaccessibleDatastore_Def.__bases__:
                bases = list(ns0.InaccessibleDatastore_Def.__bases__)
                bases.insert(0, ns0.InvalidDatastore_Def)
                ns0.InaccessibleDatastore_Def.__bases__ = tuple(bases)

            ns0.InvalidDatastore_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IncompatibleDefaultDevice_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IncompatibleDefaultDevice")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IncompatibleDefaultDevice_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.IncompatibleDefaultDevice_Def.__bases__:
                bases = list(ns0.IncompatibleDefaultDevice_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.IncompatibleDefaultDevice_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IncompatibleSetting_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IncompatibleSetting")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IncompatibleSetting_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"conflictingProperty"), aname="_conflictingProperty", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidArgument_Def not in ns0.IncompatibleSetting_Def.__bases__:
                bases = list(ns0.IncompatibleSetting_Def.__bases__)
                bases.insert(0, ns0.InvalidArgument_Def)
                ns0.IncompatibleSetting_Def.__bases__ = tuple(bases)

            ns0.InvalidArgument_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IncorrectFileType_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IncorrectFileType")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IncorrectFileType_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.IncorrectFileType_Def.__bases__:
                bases = list(ns0.IncorrectFileType_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.IncorrectFileType_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IncorrectHostInformation_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IncorrectHostInformation")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IncorrectHostInformation_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughLicenses_Def not in ns0.IncorrectHostInformation_Def.__bases__:
                bases = list(ns0.IncorrectHostInformation_Def.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.IncorrectHostInformation_Def.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IndependentDiskVMotionNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IndependentDiskVMotionNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IndependentDiskVMotionNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFeatureNotSupported_Def not in ns0.IndependentDiskVMotionNotSupported_Def.__bases__:
                bases = list(ns0.IndependentDiskVMotionNotSupported_Def.__bases__)
                bases.insert(0, ns0.MigrationFeatureNotSupported_Def)
                ns0.IndependentDiskVMotionNotSupported_Def.__bases__ = tuple(bases)

            ns0.MigrationFeatureNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InsufficientCpuResourcesFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InsufficientCpuResourcesFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InsufficientCpuResourcesFault_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"unreserved"), aname="_unreserved", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"requested"), aname="_requested", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InsufficientResourcesFault_Def not in ns0.InsufficientCpuResourcesFault_Def.__bases__:
                bases = list(ns0.InsufficientCpuResourcesFault_Def.__bases__)
                bases.insert(0, ns0.InsufficientResourcesFault_Def)
                ns0.InsufficientCpuResourcesFault_Def.__bases__ = tuple(bases)

            ns0.InsufficientResourcesFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InsufficientFailoverResourcesFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InsufficientFailoverResourcesFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InsufficientFailoverResourcesFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InsufficientResourcesFault_Def not in ns0.InsufficientFailoverResourcesFault_Def.__bases__:
                bases = list(ns0.InsufficientFailoverResourcesFault_Def.__bases__)
                bases.insert(0, ns0.InsufficientResourcesFault_Def)
                ns0.InsufficientFailoverResourcesFault_Def.__bases__ = tuple(bases)

            ns0.InsufficientResourcesFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InsufficientHostCapacityFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InsufficientHostCapacityFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InsufficientHostCapacityFault_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InsufficientResourcesFault_Def not in ns0.InsufficientHostCapacityFault_Def.__bases__:
                bases = list(ns0.InsufficientHostCapacityFault_Def.__bases__)
                bases.insert(0, ns0.InsufficientResourcesFault_Def)
                ns0.InsufficientHostCapacityFault_Def.__bases__ = tuple(bases)

            ns0.InsufficientResourcesFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InsufficientMemoryResourcesFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InsufficientMemoryResourcesFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InsufficientMemoryResourcesFault_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"unreserved"), aname="_unreserved", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"requested"), aname="_requested", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InsufficientResourcesFault_Def not in ns0.InsufficientMemoryResourcesFault_Def.__bases__:
                bases = list(ns0.InsufficientMemoryResourcesFault_Def.__bases__)
                bases.insert(0, ns0.InsufficientResourcesFault_Def)
                ns0.InsufficientMemoryResourcesFault_Def.__bases__ = tuple(bases)

            ns0.InsufficientResourcesFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InsufficientPerCpuCapacity_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InsufficientPerCpuCapacity")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InsufficientPerCpuCapacity_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InsufficientHostCapacityFault_Def not in ns0.InsufficientPerCpuCapacity_Def.__bases__:
                bases = list(ns0.InsufficientPerCpuCapacity_Def.__bases__)
                bases.insert(0, ns0.InsufficientHostCapacityFault_Def)
                ns0.InsufficientPerCpuCapacity_Def.__bases__ = tuple(bases)

            ns0.InsufficientHostCapacityFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InsufficientResourcesFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InsufficientResourcesFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InsufficientResourcesFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InsufficientResourcesFault_Def.__bases__:
                bases = list(ns0.InsufficientResourcesFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InsufficientResourcesFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidAffinitySettingFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidAffinitySettingFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidAffinitySettingFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidAffinitySettingFault_Def.__bases__:
                bases = list(ns0.InvalidAffinitySettingFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidAffinitySettingFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidBundle_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidBundle")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidBundle_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PlatformConfigFault_Def not in ns0.InvalidBundle_Def.__bases__:
                bases = list(ns0.InvalidBundle_Def.__bases__)
                bases.insert(0, ns0.PlatformConfigFault_Def)
                ns0.InvalidBundle_Def.__bases__ = tuple(bases)

            ns0.PlatformConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidController_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"controllerKey"), aname="_controllerKey", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDeviceSpec_Def not in ns0.InvalidController_Def.__bases__:
                bases = list(ns0.InvalidController_Def.__bases__)
                bases.insert(0, ns0.InvalidDeviceSpec_Def)
                ns0.InvalidController_Def.__bases__ = tuple(bases)

            ns0.InvalidDeviceSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidDatastore_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidDatastore")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidDatastore_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidDatastore_Def.__bases__:
                bases = list(ns0.InvalidDatastore_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidDatastore_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidDatastorePath_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidDatastorePath")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidDatastorePath_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"datastorePath"), aname="_datastorePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDatastore_Def not in ns0.InvalidDatastorePath_Def.__bases__:
                bases = list(ns0.InvalidDatastorePath_Def.__bases__)
                bases.insert(0, ns0.InvalidDatastore_Def)
                ns0.InvalidDatastorePath_Def.__bases__ = tuple(bases)

            ns0.InvalidDatastore_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidDeviceBacking_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidDeviceBacking")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidDeviceBacking_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDeviceSpec_Def not in ns0.InvalidDeviceBacking_Def.__bases__:
                bases = list(ns0.InvalidDeviceBacking_Def.__bases__)
                bases.insert(0, ns0.InvalidDeviceSpec_Def)
                ns0.InvalidDeviceBacking_Def.__bases__ = tuple(bases)

            ns0.InvalidDeviceSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidDeviceOperation_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidDeviceOperation")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidDeviceOperation_Def.schema
            TClist = [GTD("urn:vim25","VirtualDeviceConfigSpecOperation",lazy=True)(pname=(ns,"badOp"), aname="_badOp", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceConfigSpecFileOperation",lazy=True)(pname=(ns,"badFileOp"), aname="_badFileOp", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDeviceSpec_Def not in ns0.InvalidDeviceOperation_Def.__bases__:
                bases = list(ns0.InvalidDeviceOperation_Def.__bases__)
                bases.insert(0, ns0.InvalidDeviceSpec_Def)
                ns0.InvalidDeviceOperation_Def.__bases__ = tuple(bases)

            ns0.InvalidDeviceSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidDeviceSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidDeviceSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidDeviceSpec_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"deviceIndex"), aname="_deviceIndex", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidVmConfig_Def not in ns0.InvalidDeviceSpec_Def.__bases__:
                bases = list(ns0.InvalidDeviceSpec_Def.__bases__)
                bases.insert(0, ns0.InvalidVmConfig_Def)
                ns0.InvalidDeviceSpec_Def.__bases__ = tuple(bases)

            ns0.InvalidVmConfig_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidDiskFormat_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidDiskFormat")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidDiskFormat_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidFormat_Def not in ns0.InvalidDiskFormat_Def.__bases__:
                bases = list(ns0.InvalidDiskFormat_Def.__bases__)
                bases.insert(0, ns0.InvalidFormat_Def)
                ns0.InvalidDiskFormat_Def.__bases__ = tuple(bases)

            ns0.InvalidFormat_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidEditionLicense_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidEditionLicense")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidEditionLicense_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"feature"), aname="_feature", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughLicenses_Def not in ns0.InvalidEditionLicense_Def.__bases__:
                bases = list(ns0.InvalidEditionLicense_Def.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.InvalidEditionLicense_Def.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidEvent_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidEvent")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidEvent_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidEvent_Def.__bases__:
                bases = list(ns0.InvalidEvent_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidEvent_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidFolder_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidFolder")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidFolder_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"target"), aname="_target", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidFolder_Def.__bases__:
                bases = list(ns0.InvalidFolder_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidFolder_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidFormat_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidFormat")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidFormat_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.InvalidFormat_Def.__bases__:
                bases = list(ns0.InvalidFormat_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.InvalidFormat_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidHostState_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidHostState")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidHostState_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidState_Def not in ns0.InvalidHostState_Def.__bases__:
                bases = list(ns0.InvalidHostState_Def.__bases__)
                bases.insert(0, ns0.InvalidState_Def)
                ns0.InvalidHostState_Def.__bases__ = tuple(bases)

            ns0.InvalidState_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidLicense_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidLicense")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidLicense_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"licenseContent"), aname="_licenseContent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidLicense_Def.__bases__:
                bases = list(ns0.InvalidLicense_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidLicense_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidLocale_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidLocale")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidLocale_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidLocale_Def.__bases__:
                bases = list(ns0.InvalidLocale_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidLocale_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidLogin_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidLogin")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidLogin_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidLogin_Def.__bases__:
                bases = list(ns0.InvalidLogin_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidLogin_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidName_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidName_Def.__bases__:
                bases = list(ns0.InvalidName_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidName_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidPowerState_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidPowerState")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidPowerState_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachinePowerState",lazy=True)(pname=(ns,"requestedState"), aname="_requestedState", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachinePowerState",lazy=True)(pname=(ns,"existingState"), aname="_existingState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidState_Def not in ns0.InvalidPowerState_Def.__bases__:
                bases = list(ns0.InvalidPowerState_Def.__bases__)
                bases.insert(0, ns0.InvalidState_Def)
                ns0.InvalidPowerState_Def.__bases__ = tuple(bases)

            ns0.InvalidState_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidPrivilege_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidPrivilege")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidPrivilege_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"privilege"), aname="_privilege", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidPrivilege_Def.__bases__:
                bases = list(ns0.InvalidPrivilege_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidPrivilege_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidResourcePoolStructureFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidResourcePoolStructureFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidResourcePoolStructureFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InsufficientResourcesFault_Def not in ns0.InvalidResourcePoolStructureFault_Def.__bases__:
                bases = list(ns0.InvalidResourcePoolStructureFault_Def.__bases__)
                bases.insert(0, ns0.InsufficientResourcesFault_Def)
                ns0.InvalidResourcePoolStructureFault_Def.__bases__ = tuple(bases)

            ns0.InsufficientResourcesFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidSnapshotFormat_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidSnapshotFormat")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidSnapshotFormat_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidFormat_Def not in ns0.InvalidSnapshotFormat_Def.__bases__:
                bases = list(ns0.InvalidSnapshotFormat_Def.__bases__)
                bases.insert(0, ns0.InvalidFormat_Def)
                ns0.InvalidSnapshotFormat_Def.__bases__ = tuple(bases)

            ns0.InvalidFormat_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidState_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidState")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidState_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.InvalidState_Def.__bases__:
                bases = list(ns0.InvalidState_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.InvalidState_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InvalidVmConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "InvalidVmConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.InvalidVmConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"property"), aname="_property", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.InvalidVmConfig_Def.__bases__:
                bases = list(ns0.InvalidVmConfig_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.InvalidVmConfig_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IpHostnameGeneratorError_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IpHostnameGeneratorError")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IpHostnameGeneratorError_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.IpHostnameGeneratorError_Def.__bases__:
                bases = list(ns0.IpHostnameGeneratorError_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.IpHostnameGeneratorError_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LegacyNetworkInterfaceInUse_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LegacyNetworkInterfaceInUse")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LegacyNetworkInterfaceInUse_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessNetwork_Def not in ns0.LegacyNetworkInterfaceInUse_Def.__bases__:
                bases = list(ns0.LegacyNetworkInterfaceInUse_Def.__bases__)
                bases.insert(0, ns0.CannotAccessNetwork_Def)
                ns0.LegacyNetworkInterfaceInUse_Def.__bases__ = tuple(bases)

            ns0.CannotAccessNetwork_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseRestricted_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseRestricted")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseRestricted_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughLicenses_Def not in ns0.LicenseRestricted_Def.__bases__:
                bases = list(ns0.LicenseRestricted_Def.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.LicenseRestricted_Def.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseServerUnavailable_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseServerUnavailable")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseServerUnavailable_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"licenseServer"), aname="_licenseServer", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.LicenseServerUnavailable_Def.__bases__:
                bases = list(ns0.LicenseServerUnavailable_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.LicenseServerUnavailable_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LicenseSourceUnavailable_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LicenseSourceUnavailable")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LicenseSourceUnavailable_Def.schema
            TClist = [GTD("urn:vim25","LicenseSource",lazy=True)(pname=(ns,"licenseSource"), aname="_licenseSource", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughLicenses_Def not in ns0.LicenseSourceUnavailable_Def.__bases__:
                bases = list(ns0.LicenseSourceUnavailable_Def.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.LicenseSourceUnavailable_Def.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LinuxVolumeNotClean_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LinuxVolumeNotClean")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LinuxVolumeNotClean_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.LinuxVolumeNotClean_Def.__bases__:
                bases = list(ns0.LinuxVolumeNotClean_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.LinuxVolumeNotClean_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LogBundlingFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LogBundlingFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LogBundlingFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.LogBundlingFailed_Def.__bases__:
                bases = list(ns0.LogBundlingFailed_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.LogBundlingFailed_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MaintenanceModeFileMove_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MaintenanceModeFileMove")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MaintenanceModeFileMove_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.MaintenanceModeFileMove_Def.__bases__:
                bases = list(ns0.MaintenanceModeFileMove_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.MaintenanceModeFileMove_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MemorySizeNotRecommended_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MemorySizeNotRecommended")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MemorySizeNotRecommended_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"memorySizeMB"), aname="_memorySizeMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"minMemorySizeMB"), aname="_minMemorySizeMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxMemorySizeMB"), aname="_maxMemorySizeMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.MemorySizeNotRecommended_Def.__bases__:
                bases = list(ns0.MemorySizeNotRecommended_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.MemorySizeNotRecommended_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MemorySizeNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MemorySizeNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MemorySizeNotSupported_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"memorySizeMB"), aname="_memorySizeMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"minMemorySizeMB"), aname="_minMemorySizeMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxMemorySizeMB"), aname="_maxMemorySizeMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.MemorySizeNotSupported_Def.__bases__:
                bases = list(ns0.MemorySizeNotSupported_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.MemorySizeNotSupported_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MemorySnapshotOnIndependentDisk_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MemorySnapshotOnIndependentDisk")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MemorySnapshotOnIndependentDisk_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.MemorySnapshotOnIndependentDisk_Def.__bases__:
                bases = list(ns0.MemorySnapshotOnIndependentDisk_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.MemorySnapshotOnIndependentDisk_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.MigrationFault_Def.__bases__:
                bases = list(ns0.MigrationFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.MigrationFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MigrationFeatureNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MigrationFeatureNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MigrationFeatureNotSupported_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"atSourceHost"), aname="_atSourceHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"failedHostName"), aname="_failedHostName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"failedHost"), aname="_failedHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.MigrationFeatureNotSupported_Def.__bases__:
                bases = list(ns0.MigrationFeatureNotSupported_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.MigrationFeatureNotSupported_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MismatchedBundle_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MismatchedBundle")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MismatchedBundle_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"bundleUuid"), aname="_bundleUuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"hostUuid"), aname="_hostUuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"bundleBuildNumber"), aname="_bundleBuildNumber", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"hostBuildNumber"), aname="_hostBuildNumber", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.MismatchedBundle_Def.__bases__:
                bases = list(ns0.MismatchedBundle_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.MismatchedBundle_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MismatchedNetworkPolicies_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MismatchedNetworkPolicies")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MismatchedNetworkPolicies_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"backing"), aname="_backing", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"connected"), aname="_connected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.MismatchedNetworkPolicies_Def.__bases__:
                bases = list(ns0.MismatchedNetworkPolicies_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.MismatchedNetworkPolicies_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MismatchedVMotionNetworkNames_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MismatchedVMotionNetworkNames")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MismatchedVMotionNetworkNames_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"sourceNetwork"), aname="_sourceNetwork", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"destNetwork"), aname="_destNetwork", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.MismatchedVMotionNetworkNames_Def.__bases__:
                bases = list(ns0.MismatchedVMotionNetworkNames_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.MismatchedVMotionNetworkNames_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MissingController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MissingController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MissingController_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidDeviceSpec_Def not in ns0.MissingController_Def.__bases__:
                bases = list(ns0.MissingController_Def.__bases__)
                bases.insert(0, ns0.InvalidDeviceSpec_Def)
                ns0.MissingController_Def.__bases__ = tuple(bases)

            ns0.InvalidDeviceSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MissingLinuxCustResources_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MissingLinuxCustResources")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MissingLinuxCustResources_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.MissingLinuxCustResources_Def.__bases__:
                bases = list(ns0.MissingLinuxCustResources_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.MissingLinuxCustResources_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MissingWindowsCustResources_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MissingWindowsCustResources")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MissingWindowsCustResources_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.MissingWindowsCustResources_Def.__bases__:
                bases = list(ns0.MissingWindowsCustResources_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.MissingWindowsCustResources_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MountError_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MountError")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MountError_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"diskIndex"), aname="_diskIndex", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.MountError_Def.__bases__:
                bases = list(ns0.MountError_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.MountError_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MultipleSnapshotsNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MultipleSnapshotsNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MultipleSnapshotsNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.MultipleSnapshotsNotSupported_Def.__bases__:
                bases = list(ns0.MultipleSnapshotsNotSupported_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.MultipleSnapshotsNotSupported_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NetworkCopyFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NetworkCopyFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NetworkCopyFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.NetworkCopyFault_Def.__bases__:
                bases = list(ns0.NetworkCopyFault_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.NetworkCopyFault_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NetworksMayNotBeTheSame_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NetworksMayNotBeTheSame")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NetworksMayNotBeTheSame_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.NetworksMayNotBeTheSame_Def.__bases__:
                bases = list(ns0.NetworksMayNotBeTheSame_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.NetworksMayNotBeTheSame_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NicSettingMismatch_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NicSettingMismatch")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NicSettingMismatch_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"numberOfNicsInSpec"), aname="_numberOfNicsInSpec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numberOfNicsInVM"), aname="_numberOfNicsInVM", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.NicSettingMismatch_Def.__bases__:
                bases = list(ns0.NicSettingMismatch_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.NicSettingMismatch_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoActiveHostInCluster_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoActiveHostInCluster")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoActiveHostInCluster_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"computeResource"), aname="_computeResource", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidState_Def not in ns0.NoActiveHostInCluster_Def.__bases__:
                bases = list(ns0.NoActiveHostInCluster_Def.__bases__)
                bases.insert(0, ns0.InvalidState_Def)
                ns0.NoActiveHostInCluster_Def.__bases__ = tuple(bases)

            ns0.InvalidState_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoClientCertificate_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoClientCertificate")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoClientCertificate_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.NoClientCertificate_Def.__bases__:
                bases = list(ns0.NoClientCertificate_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.NoClientCertificate_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoDiskFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoDiskFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoDiskFound_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.NoDiskFound_Def.__bases__:
                bases = list(ns0.NoDiskFound_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.NoDiskFound_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoDiskSpace_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoDiskSpace")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoDiskSpace_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileFault_Def not in ns0.NoDiskSpace_Def.__bases__:
                bases = list(ns0.NoDiskSpace_Def.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.NoDiskSpace_Def.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoDisksToCustomize_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoDisksToCustomize")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoDisksToCustomize_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.NoDisksToCustomize_Def.__bases__:
                bases = list(ns0.NoDisksToCustomize_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.NoDisksToCustomize_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoGateway_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoGateway")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoGateway_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConfigFault_Def not in ns0.NoGateway_Def.__bases__:
                bases = list(ns0.NoGateway_Def.__bases__)
                bases.insert(0, ns0.HostConfigFault_Def)
                ns0.NoGateway_Def.__bases__ = tuple(bases)

            ns0.HostConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoGuestHeartbeat_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoGuestHeartbeat")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoGuestHeartbeat_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.NoGuestHeartbeat_Def.__bases__:
                bases = list(ns0.NoGuestHeartbeat_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.NoGuestHeartbeat_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoHost_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoHost")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoHost_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.NoHost_Def.__bases__:
                bases = list(ns0.NoHost_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.NoHost_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoPeerHostFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoPeerHostFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoPeerHostFound_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostPowerOpFailed_Def not in ns0.NoPeerHostFound_Def.__bases__:
                bases = list(ns0.NoPeerHostFound_Def.__bases__)
                bases.insert(0, ns0.HostPowerOpFailed_Def)
                ns0.NoPeerHostFound_Def.__bases__ = tuple(bases)

            ns0.HostPowerOpFailed_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoPermission_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoPermission")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoPermission_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"object"), aname="_object", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"privilegeId"), aname="_privilegeId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SecurityError_Def not in ns0.NoPermission_Def.__bases__:
                bases = list(ns0.NoPermission_Def.__bases__)
                bases.insert(0, ns0.SecurityError_Def)
                ns0.NoPermission_Def.__bases__ = tuple(bases)

            ns0.SecurityError_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoPermissionOnHost_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoPermissionOnHost")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoPermissionOnHost_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.NoPermissionOnHost_Def.__bases__:
                bases = list(ns0.NoPermissionOnHost_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.NoPermissionOnHost_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoSubjectName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoSubjectName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoSubjectName_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.NoSubjectName_Def.__bases__:
                bases = list(ns0.NoSubjectName_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.NoSubjectName_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NoVirtualNic_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NoVirtualNic")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NoVirtualNic_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConfigFault_Def not in ns0.NoVirtualNic_Def.__bases__:
                bases = list(ns0.NoVirtualNic_Def.__bases__)
                bases.insert(0, ns0.HostConfigFault_Def)
                ns0.NoVirtualNic_Def.__bases__ = tuple(bases)

            ns0.HostConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NonHomeRDMVMotionNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NonHomeRDMVMotionNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NonHomeRDMVMotionNotSupported_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFeatureNotSupported_Def not in ns0.NonHomeRDMVMotionNotSupported_Def.__bases__:
                bases = list(ns0.NonHomeRDMVMotionNotSupported_Def.__bases__)
                bases.insert(0, ns0.MigrationFeatureNotSupported_Def)
                ns0.NonHomeRDMVMotionNotSupported_Def.__bases__ = tuple(bases)

            ns0.MigrationFeatureNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NonPersistentDisksNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NonPersistentDisksNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NonPersistentDisksNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.NonPersistentDisksNotSupported_Def.__bases__:
                bases = list(ns0.NonPersistentDisksNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.NonPersistentDisksNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotAuthenticated_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotAuthenticated")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotAuthenticated_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NoPermission_Def not in ns0.NotAuthenticated_Def.__bases__:
                bases = list(ns0.NotAuthenticated_Def.__bases__)
                bases.insert(0, ns0.NoPermission_Def)
                ns0.NotAuthenticated_Def.__bases__ = tuple(bases)

            ns0.NoPermission_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotEnoughCpus_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotEnoughCpus")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotEnoughCpus_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"numCpuDest"), aname="_numCpuDest", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numCpuVm"), aname="_numCpuVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.NotEnoughCpus_Def.__bases__:
                bases = list(ns0.NotEnoughCpus_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.NotEnoughCpus_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotEnoughLogicalCpus_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotEnoughLogicalCpus")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotEnoughLogicalCpus_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughCpus_Def not in ns0.NotEnoughLogicalCpus_Def.__bases__:
                bases = list(ns0.NotEnoughLogicalCpus_Def.__bases__)
                bases.insert(0, ns0.NotEnoughCpus_Def)
                ns0.NotEnoughLogicalCpus_Def.__bases__ = tuple(bases)

            ns0.NotEnoughCpus_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotFound_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.NotFound_Def.__bases__:
                bases = list(ns0.NotFound_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.NotFound_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NotSupportedHost_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NotSupportedHost")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NotSupportedHost_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"productName"), aname="_productName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"productVersion"), aname="_productVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.NotSupportedHost_Def.__bases__:
                bases = list(ns0.NotSupportedHost_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.NotSupportedHost_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NumVirtualCpusNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NumVirtualCpusNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NumVirtualCpusNotSupported_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"maxSupportedVcpusDest"), aname="_maxSupportedVcpusDest", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numCpuVm"), aname="_numCpuVm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.NumVirtualCpusNotSupported_Def.__bases__:
                bases = list(ns0.NumVirtualCpusNotSupported_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.NumVirtualCpusNotSupported_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class OutOfBounds_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "OutOfBounds")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.OutOfBounds_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"argumentName"), aname="_argumentName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.OutOfBounds_Def.__bases__:
                bases = list(ns0.OutOfBounds_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.OutOfBounds_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchAlreadyInstalled_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchAlreadyInstalled")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchAlreadyInstalled_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PatchNotApplicable_Def not in ns0.PatchAlreadyInstalled_Def.__bases__:
                bases = list(ns0.PatchAlreadyInstalled_Def.__bases__)
                bases.insert(0, ns0.PatchNotApplicable_Def)
                ns0.PatchAlreadyInstalled_Def.__bases__ = tuple(bases)

            ns0.PatchNotApplicable_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchBinariesNotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchBinariesNotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchBinariesNotFound_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"patchID"), aname="_patchID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"binary"), aname="_binary", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.PatchBinariesNotFound_Def.__bases__:
                bases = list(ns0.PatchBinariesNotFound_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.PatchBinariesNotFound_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchInstallFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchInstallFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchInstallFailed_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"rolledBack"), aname="_rolledBack", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PlatformConfigFault_Def not in ns0.PatchInstallFailed_Def.__bases__:
                bases = list(ns0.PatchInstallFailed_Def.__bases__)
                bases.insert(0, ns0.PlatformConfigFault_Def)
                ns0.PatchInstallFailed_Def.__bases__ = tuple(bases)

            ns0.PlatformConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchIntegrityError_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchIntegrityError")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchIntegrityError_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PlatformConfigFault_Def not in ns0.PatchIntegrityError_Def.__bases__:
                bases = list(ns0.PatchIntegrityError_Def.__bases__)
                bases.insert(0, ns0.PlatformConfigFault_Def)
                ns0.PatchIntegrityError_Def.__bases__ = tuple(bases)

            ns0.PlatformConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchMetadataCorrupted_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchMetadataCorrupted")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchMetadataCorrupted_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PatchMetadataInvalid_Def not in ns0.PatchMetadataCorrupted_Def.__bases__:
                bases = list(ns0.PatchMetadataCorrupted_Def.__bases__)
                bases.insert(0, ns0.PatchMetadataInvalid_Def)
                ns0.PatchMetadataCorrupted_Def.__bases__ = tuple(bases)

            ns0.PatchMetadataInvalid_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchMetadataInvalid_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchMetadataInvalid")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchMetadataInvalid_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"patchID"), aname="_patchID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"metaData"), aname="_metaData", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.PatchMetadataInvalid_Def.__bases__:
                bases = list(ns0.PatchMetadataInvalid_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.PatchMetadataInvalid_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchMetadataNotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchMetadataNotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchMetadataNotFound_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PatchMetadataInvalid_Def not in ns0.PatchMetadataNotFound_Def.__bases__:
                bases = list(ns0.PatchMetadataNotFound_Def.__bases__)
                bases.insert(0, ns0.PatchMetadataInvalid_Def)
                ns0.PatchMetadataNotFound_Def.__bases__ = tuple(bases)

            ns0.PatchMetadataInvalid_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchMissingDependencies_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchMissingDependencies")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchMissingDependencies_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"prerequisitePatch"), aname="_prerequisitePatch", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"prerequisiteLib"), aname="_prerequisiteLib", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PatchNotApplicable_Def not in ns0.PatchMissingDependencies_Def.__bases__:
                bases = list(ns0.PatchMissingDependencies_Def.__bases__)
                bases.insert(0, ns0.PatchNotApplicable_Def)
                ns0.PatchMissingDependencies_Def.__bases__ = tuple(bases)

            ns0.PatchNotApplicable_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchNotApplicable_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchNotApplicable")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchNotApplicable_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"patchID"), aname="_patchID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.PatchNotApplicable_Def.__bases__:
                bases = list(ns0.PatchNotApplicable_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.PatchNotApplicable_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PatchSuperseded_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PatchSuperseded")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PatchSuperseded_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"supersede"), aname="_supersede", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PatchNotApplicable_Def not in ns0.PatchSuperseded_Def.__bases__:
                bases = list(ns0.PatchSuperseded_Def.__bases__)
                bases.insert(0, ns0.PatchNotApplicable_Def)
                ns0.PatchSuperseded_Def.__bases__ = tuple(bases)

            ns0.PatchNotApplicable_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PhysCompatRDMNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysCompatRDMNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysCompatRDMNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RDMNotSupported_Def not in ns0.PhysCompatRDMNotSupported_Def.__bases__:
                bases = list(ns0.PhysCompatRDMNotSupported_Def.__bases__)
                bases.insert(0, ns0.RDMNotSupported_Def)
                ns0.PhysCompatRDMNotSupported_Def.__bases__ = tuple(bases)

            ns0.RDMNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PlatformConfigFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PlatformConfigFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PlatformConfigFault_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"text"), aname="_text", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConfigFault_Def not in ns0.PlatformConfigFault_Def.__bases__:
                bases = list(ns0.PlatformConfigFault_Def.__bases__)
                bases.insert(0, ns0.HostConfigFault_Def)
                ns0.PlatformConfigFault_Def.__bases__ = tuple(bases)

            ns0.HostConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RDMNotPreserved_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RDMNotPreserved")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RDMNotPreserved_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.RDMNotPreserved_Def.__bases__:
                bases = list(ns0.RDMNotPreserved_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.RDMNotPreserved_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RDMNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RDMNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RDMNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.RDMNotSupported_Def.__bases__:
                bases = list(ns0.RDMNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.RDMNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RDMNotSupportedOnDatastore_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RDMNotSupportedOnDatastore")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RDMNotSupportedOnDatastore_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"datastoreName"), aname="_datastoreName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.RDMNotSupportedOnDatastore_Def.__bases__:
                bases = list(ns0.RDMNotSupportedOnDatastore_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.RDMNotSupportedOnDatastore_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RDMPointsToInaccessibleDisk_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RDMPointsToInaccessibleDisk")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RDMPointsToInaccessibleDisk_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessVmDisk_Def not in ns0.RDMPointsToInaccessibleDisk_Def.__bases__:
                bases = list(ns0.RDMPointsToInaccessibleDisk_Def.__bases__)
                bases.insert(0, ns0.CannotAccessVmDisk_Def)
                ns0.RDMPointsToInaccessibleDisk_Def.__bases__ = tuple(bases)

            ns0.CannotAccessVmDisk_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RawDiskNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RawDiskNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RawDiskNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.RawDiskNotSupported_Def.__bases__:
                bases = list(ns0.RawDiskNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.RawDiskNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReadOnlyDisksWithLegacyDestination_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ReadOnlyDisksWithLegacyDestination")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ReadOnlyDisksWithLegacyDestination_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"roDiskCount"), aname="_roDiskCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"timeoutDanger"), aname="_timeoutDanger", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.ReadOnlyDisksWithLegacyDestination_Def.__bases__:
                bases = list(ns0.ReadOnlyDisksWithLegacyDestination_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.ReadOnlyDisksWithLegacyDestination_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RebootRequired_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RebootRequired")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RebootRequired_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"patch"), aname="_patch", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.RebootRequired_Def.__bases__:
                bases = list(ns0.RebootRequired_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.RebootRequired_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RemoteDeviceNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RemoteDeviceNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RemoteDeviceNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.RemoteDeviceNotSupported_Def.__bases__:
                bases = list(ns0.RemoteDeviceNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.RemoteDeviceNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RemoveFailed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RemoveFailed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RemoveFailed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.RemoveFailed_Def.__bases__:
                bases = list(ns0.RemoveFailed_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.RemoveFailed_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ResourceInUse_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ResourceInUse")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ResourceInUse_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.ResourceInUse_Def.__bases__:
                bases = list(ns0.ResourceInUse_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.ResourceInUse_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RestrictedVersion_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RestrictedVersion")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RestrictedVersion_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SecurityError_Def not in ns0.RestrictedVersion_Def.__bases__:
                bases = list(ns0.RestrictedVersion_Def.__bases__)
                bases.insert(0, ns0.SecurityError_Def)
                ns0.RestrictedVersion_Def.__bases__ = tuple(bases)

            ns0.SecurityError_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RuleViolation_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RuleViolation")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RuleViolation_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.RuleViolation_Def.__bases__:
                bases = list(ns0.RuleViolation_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.RuleViolation_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SSLVerifyFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SSLVerifyFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SSLVerifyFault_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"selfSigned"), aname="_selfSigned", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"thumbprint"), aname="_thumbprint", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.SSLVerifyFault_Def.__bases__:
                bases = list(ns0.SSLVerifyFault_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.SSLVerifyFault_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SSPIChallenge_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SSPIChallenge")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SSPIChallenge_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"base64Token"), aname="_base64Token", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.SSPIChallenge_Def.__bases__:
                bases = list(ns0.SSPIChallenge_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.SSPIChallenge_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SharedBusControllerNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SharedBusControllerNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SharedBusControllerNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.SharedBusControllerNotSupported_Def.__bases__:
                bases = list(ns0.SharedBusControllerNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.SharedBusControllerNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotCloneNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotCloneNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotCloneNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotCopyNotSupported_Def not in ns0.SnapshotCloneNotSupported_Def.__bases__:
                bases = list(ns0.SnapshotCloneNotSupported_Def.__bases__)
                bases.insert(0, ns0.SnapshotCopyNotSupported_Def)
                ns0.SnapshotCloneNotSupported_Def.__bases__ = tuple(bases)

            ns0.SnapshotCopyNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotCopyNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotCopyNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotCopyNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.SnapshotCopyNotSupported_Def.__bases__:
                bases = list(ns0.SnapshotCopyNotSupported_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.SnapshotCopyNotSupported_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotDisabled_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotDisabled")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotDisabled_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.SnapshotDisabled_Def.__bases__:
                bases = list(ns0.SnapshotDisabled_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.SnapshotDisabled_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.SnapshotFault_Def.__bases__:
                bases = list(ns0.SnapshotFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.SnapshotFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotIncompatibleDeviceInVm_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotIncompatibleDeviceInVm")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotIncompatibleDeviceInVm_Def.schema
            TClist = [GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"fault"), aname="_fault", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.SnapshotIncompatibleDeviceInVm_Def.__bases__:
                bases = list(ns0.SnapshotIncompatibleDeviceInVm_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.SnapshotIncompatibleDeviceInVm_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotLocked_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotLocked")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotLocked_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.SnapshotLocked_Def.__bases__:
                bases = list(ns0.SnapshotLocked_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.SnapshotLocked_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotMoveFromNonHomeNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotMoveFromNonHomeNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotMoveFromNonHomeNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotCopyNotSupported_Def not in ns0.SnapshotMoveFromNonHomeNotSupported_Def.__bases__:
                bases = list(ns0.SnapshotMoveFromNonHomeNotSupported_Def.__bases__)
                bases.insert(0, ns0.SnapshotCopyNotSupported_Def)
                ns0.SnapshotMoveFromNonHomeNotSupported_Def.__bases__ = tuple(bases)

            ns0.SnapshotCopyNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotMoveNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotMoveNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotMoveNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotCopyNotSupported_Def not in ns0.SnapshotMoveNotSupported_Def.__bases__:
                bases = list(ns0.SnapshotMoveNotSupported_Def.__bases__)
                bases.insert(0, ns0.SnapshotCopyNotSupported_Def)
                ns0.SnapshotMoveNotSupported_Def.__bases__ = tuple(bases)

            ns0.SnapshotCopyNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotMoveToNonHomeNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotMoveToNonHomeNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotMoveToNonHomeNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotCopyNotSupported_Def not in ns0.SnapshotMoveToNonHomeNotSupported_Def.__bases__:
                bases = list(ns0.SnapshotMoveToNonHomeNotSupported_Def.__bases__)
                bases.insert(0, ns0.SnapshotCopyNotSupported_Def)
                ns0.SnapshotMoveToNonHomeNotSupported_Def.__bases__ = tuple(bases)

            ns0.SnapshotCopyNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotNoChange_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotNoChange")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotNoChange_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.SnapshotNoChange_Def.__bases__:
                bases = list(ns0.SnapshotNoChange_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.SnapshotNoChange_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SnapshotRevertIssue_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SnapshotRevertIssue")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SnapshotRevertIssue_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"snapshotName"), aname="_snapshotName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Event",lazy=True)(pname=(ns,"event"), aname="_event", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"errors"), aname="_errors", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.SnapshotRevertIssue_Def.__bases__:
                bases = list(ns0.SnapshotRevertIssue_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.SnapshotRevertIssue_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SuspendedRelocateNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SuspendedRelocateNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SuspendedRelocateNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.SuspendedRelocateNotSupported_Def.__bases__:
                bases = list(ns0.SuspendedRelocateNotSupported_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.SuspendedRelocateNotSupported_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SwapDatastoreNotWritableOnHost_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SwapDatastoreNotWritableOnHost")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SwapDatastoreNotWritableOnHost_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatastoreNotWritableOnHost_Def not in ns0.SwapDatastoreNotWritableOnHost_Def.__bases__:
                bases = list(ns0.SwapDatastoreNotWritableOnHost_Def.__bases__)
                bases.insert(0, ns0.DatastoreNotWritableOnHost_Def)
                ns0.SwapDatastoreNotWritableOnHost_Def.__bases__ = tuple(bases)

            ns0.DatastoreNotWritableOnHost_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SwapDatastoreUnset_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SwapDatastoreUnset")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SwapDatastoreUnset_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.SwapDatastoreUnset_Def.__bases__:
                bases = list(ns0.SwapDatastoreUnset_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.SwapDatastoreUnset_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class SwapPlacementOverrideNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "SwapPlacementOverrideNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.SwapPlacementOverrideNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidVmConfig_Def not in ns0.SwapPlacementOverrideNotSupported_Def.__bases__:
                bases = list(ns0.SwapPlacementOverrideNotSupported_Def.__bases__)
                bases.insert(0, ns0.InvalidVmConfig_Def)
                ns0.SwapPlacementOverrideNotSupported_Def.__bases__ = tuple(bases)

            ns0.InvalidVmConfig_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TaskInProgress_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskInProgress")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskInProgress_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"task"), aname="_task", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.TaskInProgress_Def.__bases__:
                bases = list(ns0.TaskInProgress_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.TaskInProgress_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class Timedout_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "Timedout")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.Timedout_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.Timedout_Def.__bases__:
                bases = list(ns0.Timedout_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.Timedout_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TooManyConsecutiveOverrides_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TooManyConsecutiveOverrides")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TooManyConsecutiveOverrides_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.TooManyConsecutiveOverrides_Def.__bases__:
                bases = list(ns0.TooManyConsecutiveOverrides_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.TooManyConsecutiveOverrides_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TooManyDevices_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TooManyDevices")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TooManyDevices_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidVmConfig_Def not in ns0.TooManyDevices_Def.__bases__:
                bases = list(ns0.TooManyDevices_Def.__bases__)
                bases.insert(0, ns0.InvalidVmConfig_Def)
                ns0.TooManyDevices_Def.__bases__ = tuple(bases)

            ns0.InvalidVmConfig_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TooManyDisksOnLegacyHost_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TooManyDisksOnLegacyHost")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TooManyDisksOnLegacyHost_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"diskCount"), aname="_diskCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"timeoutDanger"), aname="_timeoutDanger", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.TooManyDisksOnLegacyHost_Def.__bases__:
                bases = list(ns0.TooManyDisksOnLegacyHost_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.TooManyDisksOnLegacyHost_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TooManyHosts_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TooManyHosts")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TooManyHosts_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectFault_Def not in ns0.TooManyHosts_Def.__bases__:
                bases = list(ns0.TooManyHosts_Def.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.TooManyHosts_Def.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TooManySnapshotLevels_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TooManySnapshotLevels")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TooManySnapshotLevels_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.SnapshotFault_Def not in ns0.TooManySnapshotLevels_Def.__bases__:
                bases = list(ns0.TooManySnapshotLevels_Def.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.TooManySnapshotLevels_Def.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ToolsUnavailable_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ToolsUnavailable")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ToolsUnavailable_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.ToolsUnavailable_Def.__bases__:
                bases = list(ns0.ToolsUnavailable_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.ToolsUnavailable_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UncommittedUndoableDisk_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UncommittedUndoableDisk")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UncommittedUndoableDisk_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.UncommittedUndoableDisk_Def.__bases__:
                bases = list(ns0.UncommittedUndoableDisk_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.UncommittedUndoableDisk_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UncustomizableGuest_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UncustomizableGuest")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UncustomizableGuest_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"uncustomizableGuestOS"), aname="_uncustomizableGuestOS", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.UncustomizableGuest_Def.__bases__:
                bases = list(ns0.UncustomizableGuest_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.UncustomizableGuest_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnexpectedCustomizationFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnexpectedCustomizationFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnexpectedCustomizationFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.UnexpectedCustomizationFault_Def.__bases__:
                bases = list(ns0.UnexpectedCustomizationFault_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.UnexpectedCustomizationFault_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnrecognizedHost_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnrecognizedHost")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnrecognizedHost_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"hostName"), aname="_hostName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.UnrecognizedHost_Def.__bases__:
                bases = list(ns0.UnrecognizedHost_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.UnrecognizedHost_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnsharedSwapVMotionNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnsharedSwapVMotionNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnsharedSwapVMotionNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFeatureNotSupported_Def not in ns0.UnsharedSwapVMotionNotSupported_Def.__bases__:
                bases = list(ns0.UnsharedSwapVMotionNotSupported_Def.__bases__)
                bases.insert(0, ns0.MigrationFeatureNotSupported_Def)
                ns0.UnsharedSwapVMotionNotSupported_Def.__bases__ = tuple(bases)

            ns0.MigrationFeatureNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnsupportedDatastore_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnsupportedDatastore")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnsupportedDatastore_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.UnsupportedDatastore_Def.__bases__:
                bases = list(ns0.UnsupportedDatastore_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.UnsupportedDatastore_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnsupportedGuest_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnsupportedGuest")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnsupportedGuest_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"unsupportedGuestOS"), aname="_unsupportedGuestOS", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidVmConfig_Def not in ns0.UnsupportedGuest_Def.__bases__:
                bases = list(ns0.UnsupportedGuest_Def.__bases__)
                bases.insert(0, ns0.InvalidVmConfig_Def)
                ns0.UnsupportedGuest_Def.__bases__ = tuple(bases)

            ns0.InvalidVmConfig_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UnsupportedVmxLocation_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UnsupportedVmxLocation")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UnsupportedVmxLocation_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.UnsupportedVmxLocation_Def.__bases__:
                bases = list(ns0.UnsupportedVmxLocation_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.UnsupportedVmxLocation_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UserNotFound_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "UserNotFound")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.UserNotFound_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"principal"), aname="_principal", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"unresolved"), aname="_unresolved", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.UserNotFound_Def.__bases__:
                bases = list(ns0.UserNotFound_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.UserNotFound_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMINotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMINotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMINotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.VMINotSupported_Def.__bases__:
                bases = list(ns0.VMINotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.VMINotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMOnVirtualIntranet_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMOnVirtualIntranet")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMOnVirtualIntranet_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CannotAccessNetwork_Def not in ns0.VMOnVirtualIntranet_Def.__bases__:
                bases = list(ns0.VMOnVirtualIntranet_Def.__bases__)
                bases.insert(0, ns0.CannotAccessNetwork_Def)
                ns0.VMOnVirtualIntranet_Def.__bases__ = tuple(bases)

            ns0.CannotAccessNetwork_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionInterfaceIssue_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionInterfaceIssue")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionInterfaceIssue_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"atSourceHost"), aname="_atSourceHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"failedHost"), aname="_failedHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"failedHostEntity"), aname="_failedHostEntity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.VMotionInterfaceIssue_Def.__bases__:
                bases = list(ns0.VMotionInterfaceIssue_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.VMotionInterfaceIssue_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionLinkCapacityLow_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionLinkCapacityLow")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionLinkCapacityLow_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"network"), aname="_network", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VMotionInterfaceIssue_Def not in ns0.VMotionLinkCapacityLow_Def.__bases__:
                bases = list(ns0.VMotionLinkCapacityLow_Def.__bases__)
                bases.insert(0, ns0.VMotionInterfaceIssue_Def)
                ns0.VMotionLinkCapacityLow_Def.__bases__ = tuple(bases)

            ns0.VMotionInterfaceIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionLinkDown_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionLinkDown")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionLinkDown_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"network"), aname="_network", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VMotionInterfaceIssue_Def not in ns0.VMotionLinkDown_Def.__bases__:
                bases = list(ns0.VMotionLinkDown_Def.__bases__)
                bases.insert(0, ns0.VMotionInterfaceIssue_Def)
                ns0.VMotionLinkDown_Def.__bases__ = tuple(bases)

            ns0.VMotionInterfaceIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionNotConfigured_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionNotConfigured")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionNotConfigured_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VMotionInterfaceIssue_Def not in ns0.VMotionNotConfigured_Def.__bases__:
                bases = list(ns0.VMotionNotConfigured_Def.__bases__)
                bases.insert(0, ns0.VMotionInterfaceIssue_Def)
                ns0.VMotionNotConfigured_Def.__bases__ = tuple(bases)

            ns0.VMotionInterfaceIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionNotLicensed_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionNotLicensed")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionNotLicensed_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VMotionInterfaceIssue_Def not in ns0.VMotionNotLicensed_Def.__bases__:
                bases = list(ns0.VMotionNotLicensed_Def.__bases__)
                bases.insert(0, ns0.VMotionInterfaceIssue_Def)
                ns0.VMotionNotLicensed_Def.__bases__ = tuple(bases)

            ns0.VMotionInterfaceIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VMotionInterfaceIssue_Def not in ns0.VMotionNotSupported_Def.__bases__:
                bases = list(ns0.VMotionNotSupported_Def.__bases__)
                bases.insert(0, ns0.VMotionInterfaceIssue_Def)
                ns0.VMotionNotSupported_Def.__bases__ = tuple(bases)

            ns0.VMotionInterfaceIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VMotionProtocolIncompatible_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VMotionProtocolIncompatible")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VMotionProtocolIncompatible_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.VMotionProtocolIncompatible_Def.__bases__:
                bases = list(ns0.VMotionProtocolIncompatible_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.VMotionProtocolIncompatible_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VimFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VimFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VimFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MethodFault_Def not in ns0.VimFault_Def.__bases__:
                bases = list(ns0.VimFault_Def.__bases__)
                bases.insert(0, ns0.MethodFault_Def)
                ns0.VimFault_Def.__bases__ = tuple(bases)

            ns0.MethodFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEthernetCardNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEthernetCardNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DeviceNotSupported_Def not in ns0.VirtualEthernetCardNotSupported_Def.__bases__:
                bases = list(ns0.VirtualEthernetCardNotSupported_Def.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.VirtualEthernetCardNotSupported_Def.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualHardwareCompatibilityIssue_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualHardwareCompatibilityIssue")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualHardwareCompatibilityIssue_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFault_Def not in ns0.VirtualHardwareCompatibilityIssue_Def.__bases__:
                bases = list(ns0.VirtualHardwareCompatibilityIssue_Def.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.VirtualHardwareCompatibilityIssue_Def.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualHardwareVersionNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualHardwareVersionNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualHardwareVersionNotSupported_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"hostName"), aname="_hostName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.VirtualHardwareVersionNotSupported_Def.__bases__:
                bases = list(ns0.VirtualHardwareVersionNotSupported_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.VirtualHardwareVersionNotSupported_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmConfigFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmConfigFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmConfigFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.VmConfigFault_Def.__bases__:
                bases = list(ns0.VmConfigFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.VmConfigFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmLimitLicense_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmLimitLicense")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmLimitLicense_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"limit"), aname="_limit", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.NotEnoughLicenses_Def not in ns0.VmLimitLicense_Def.__bases__:
                bases = list(ns0.VmLimitLicense_Def.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.VmLimitLicense_Def.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmToolsUpgradeFault_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmToolsUpgradeFault")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmToolsUpgradeFault_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VimFault_Def not in ns0.VmToolsUpgradeFault_Def.__bases__:
                bases = list(ns0.VmToolsUpgradeFault_Def.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.VmToolsUpgradeFault_Def.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmWwnConflict_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmWwnConflict")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmWwnConflict_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"wwn"), aname="_wwn", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.InvalidVmConfig_Def not in ns0.VmWwnConflict_Def.__bases__:
                bases = list(ns0.VmWwnConflict_Def.__bases__)
                bases.insert(0, ns0.InvalidVmConfig_Def)
                ns0.VmWwnConflict_Def.__bases__ = tuple(bases)

            ns0.InvalidVmConfig_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmotionInterfaceNotEnabled_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmotionInterfaceNotEnabled")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmotionInterfaceNotEnabled_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostPowerOpFailed_Def not in ns0.VmotionInterfaceNotEnabled_Def.__bases__:
                bases = list(ns0.VmotionInterfaceNotEnabled_Def.__bases__)
                bases.insert(0, ns0.HostPowerOpFailed_Def)
                ns0.VmotionInterfaceNotEnabled_Def.__bases__ = tuple(bases)

            ns0.HostPowerOpFailed_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VolumeEditorError_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VolumeEditorError")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VolumeEditorError_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationFault_Def not in ns0.VolumeEditorError_Def.__bases__:
                bases = list(ns0.VolumeEditorError_Def.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.VolumeEditorError_Def.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class WakeOnLanNotSupported_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "WakeOnLanNotSupported")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.WakeOnLanNotSupported_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.WakeOnLanNotSupported_Def.__bases__:
                bases = list(ns0.WakeOnLanNotSupported_Def.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.WakeOnLanNotSupported_Def.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class WakeOnLanNotSupportedByVmotionNIC_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "WakeOnLanNotSupportedByVmotionNIC")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.WakeOnLanNotSupportedByVmotionNIC_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostPowerOpFailed_Def not in ns0.WakeOnLanNotSupportedByVmotionNIC_Def.__bases__:
                bases = list(ns0.WakeOnLanNotSupportedByVmotionNIC_Def.__bases__)
                bases.insert(0, ns0.HostPowerOpFailed_Def)
                ns0.WakeOnLanNotSupportedByVmotionNIC_Def.__bases__ = tuple(bases)

            ns0.HostPowerOpFailed_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class WillModifyConfigCpuRequirements_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "WillModifyConfigCpuRequirements")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.WillModifyConfigCpuRequirements_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MigrationFault_Def not in ns0.WillModifyConfigCpuRequirements_Def.__bases__:
                bases = list(ns0.WillModifyConfigCpuRequirements_Def.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.WillModifyConfigCpuRequirements_Def.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AutoStartAction_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AutoStartAction")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class AutoStartDefaults_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AutoStartDefaults")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AutoStartDefaults_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"startDelay"), aname="_startDelay", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"stopDelay"), aname="_stopDelay", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"waitForHeartbeat"), aname="_waitForHeartbeat", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"stopAction"), aname="_stopAction", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AutoStartDefaults_Def.__bases__:
                bases = list(ns0.AutoStartDefaults_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AutoStartDefaults_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AutoStartWaitHeartbeatSetting_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AutoStartWaitHeartbeatSetting")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class AutoStartPowerInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AutoStartPowerInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AutoStartPowerInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"startOrder"), aname="_startOrder", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"startDelay"), aname="_startDelay", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AutoStartWaitHeartbeatSetting",lazy=True)(pname=(ns,"waitForHeartbeat"), aname="_waitForHeartbeat", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"startAction"), aname="_startAction", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"stopDelay"), aname="_stopDelay", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"stopAction"), aname="_stopAction", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.AutoStartPowerInfo_Def.__bases__:
                bases = list(ns0.AutoStartPowerInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.AutoStartPowerInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfAutoStartPowerInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfAutoStartPowerInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfAutoStartPowerInfo_Def.schema
            TClist = [GTD("urn:vim25","AutoStartPowerInfo",lazy=True)(pname=(ns,"AutoStartPowerInfo"), aname="_AutoStartPowerInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._AutoStartPowerInfo = []
                    return
            Holder.__name__ = "ArrayOfAutoStartPowerInfo_Holder"
            self.pyclass = Holder

    class HostAutoStartManagerConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostAutoStartManagerConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostAutoStartManagerConfig_Def.schema
            TClist = [GTD("urn:vim25","AutoStartDefaults",lazy=True)(pname=(ns,"defaults"), aname="_defaults", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AutoStartPowerInfo",lazy=True)(pname=(ns,"powerInfo"), aname="_powerInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostAutoStartManagerConfig_Def.__bases__:
                bases = list(ns0.HostAutoStartManagerConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostAutoStartManagerConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReconfigureAutostartRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureAutostartRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureAutostartRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostAutoStartManagerConfig",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "ReconfigureAutostartRequestType_Holder"
            self.pyclass = Holder

    class AutoStartPowerOnRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AutoStartPowerOnRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AutoStartPowerOnRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "AutoStartPowerOnRequestType_Holder"
            self.pyclass = Holder

    class AutoStartPowerOffRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AutoStartPowerOffRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AutoStartPowerOffRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "AutoStartPowerOffRequestType_Holder"
            self.pyclass = Holder

    class HostBootDeviceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostBootDeviceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostBootDeviceInfo_Def.schema
            TClist = [GTD("urn:vim25","HostBootDevice",lazy=True)(pname=(ns,"bootDevices"), aname="_bootDevices", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"currentBootDeviceKey"), aname="_currentBootDeviceKey", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostBootDeviceInfo_Def.__bases__:
                bases = list(ns0.HostBootDeviceInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostBootDeviceInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostBootDevice_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostBootDevice")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostBootDevice_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostBootDevice_Def.__bases__:
                bases = list(ns0.HostBootDevice_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostBootDevice_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostBootDevice_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostBootDevice")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostBootDevice_Def.schema
            TClist = [GTD("urn:vim25","HostBootDevice",lazy=True)(pname=(ns,"HostBootDevice"), aname="_HostBootDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostBootDevice = []
                    return
            Holder.__name__ = "ArrayOfHostBootDevice_Holder"
            self.pyclass = Holder

    class QueryBootDevicesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryBootDevicesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryBootDevicesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "QueryBootDevicesRequestType_Holder"
            self.pyclass = Holder

    class UpdateBootDeviceRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateBootDeviceRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateBootDeviceRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._key = None
                    return
            Holder.__name__ = "UpdateBootDeviceRequestType_Holder"
            self.pyclass = Holder

    class HostCapability_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCapability")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCapability_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"recursiveResourcePoolsSupported"), aname="_recursiveResourcePoolsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"cpuMemoryResourceConfigurationSupported"), aname="_cpuMemoryResourceConfigurationSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"rebootSupported"), aname="_rebootSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"shutdownSupported"), aname="_shutdownSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmotionSupported"), aname="_vmotionSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"standbySupported"), aname="_standbySupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxSupportedVMs"), aname="_maxSupportedVMs", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxRunningVMs"), aname="_maxRunningVMs", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxSupportedVcpus"), aname="_maxSupportedVcpus", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"datastorePrincipalSupported"), aname="_datastorePrincipalSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sanSupported"), aname="_sanSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"nfsSupported"), aname="_nfsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"iscsiSupported"), aname="_iscsiSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vlanTaggingSupported"), aname="_vlanTaggingSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"nicTeamingSupported"), aname="_nicTeamingSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"highGuestMemSupported"), aname="_highGuestMemSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"maintenanceModeSupported"), aname="_maintenanceModeSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"suspendedRelocateSupported"), aname="_suspendedRelocateSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"restrictedSnapshotRelocateSupported"), aname="_restrictedSnapshotRelocateSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"perVmSwapFiles"), aname="_perVmSwapFiles", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"localSwapDatastoreSupported"), aname="_localSwapDatastoreSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"unsharedSwapVMotionSupported"), aname="_unsharedSwapVMotionSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"backgroundSnapshotsSupported"), aname="_backgroundSnapshotsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"preAssignedPCIUnitNumbersSupported"), aname="_preAssignedPCIUnitNumbersSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"screenshotSupported"), aname="_screenshotSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"scaledScreenshotSupported"), aname="_scaledScreenshotSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostCapability_Def.__bases__:
                bases = list(ns0.HostCapability_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostCapability_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConfigChangeMode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostConfigChangeMode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostConfigChangeOperation_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostConfigChangeOperation")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostConfigChange_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConfigChange")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConfigChange_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostConfigChange_Def.__bases__:
                bases = list(ns0.HostConfigChange_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostConfigChange_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConfigInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AboutInfo",lazy=True)(pname=(ns,"product"), aname="_product", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostHyperThreadScheduleInfo",lazy=True)(pname=(ns,"hyperThread"), aname="_hyperThread", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ServiceConsoleReservationInfo",lazy=True)(pname=(ns,"consoleReservation"), aname="_consoleReservation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineMemoryReservationInfo",lazy=True)(pname=(ns,"virtualMachineReservation"), aname="_virtualMachineReservation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostStorageDeviceInfo",lazy=True)(pname=(ns,"storageDevice"), aname="_storageDevice", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFileSystemVolumeInfo",lazy=True)(pname=(ns,"fileSystemVolume"), aname="_fileSystemVolume", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetworkInfo",lazy=True)(pname=(ns,"network"), aname="_network", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVMotionInfo",lazy=True)(pname=(ns,"vmotion"), aname="_vmotion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetCapabilities",lazy=True)(pname=(ns,"capabilities"), aname="_capabilities", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDatastoreSystemCapabilities",lazy=True)(pname=(ns,"datastoreCapabilities"), aname="_datastoreCapabilities", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetOffloadCapabilities",lazy=True)(pname=(ns,"offloadCapabilities"), aname="_offloadCapabilities", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostServiceInfo",lazy=True)(pname=(ns,"service"), aname="_service", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFirewallInfo",lazy=True)(pname=(ns,"firewall"), aname="_firewall", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostAutoStartManagerConfig",lazy=True)(pname=(ns,"autoStart"), aname="_autoStart", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiagnosticPartition",lazy=True)(pname=(ns,"activeDiagnosticPartition"), aname="_activeDiagnosticPartition", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"option"), aname="_option", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionDef",lazy=True)(pname=(ns,"optionDef"), aname="_optionDef", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"datastorePrincipal"), aname="_datastorePrincipal", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"localSwapDatastore"), aname="_localSwapDatastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSystemResourceInfo",lazy=True)(pname=(ns,"systemResources"), aname="_systemResources", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDateTimeInfo",lazy=True)(pname=(ns,"dateTimeInfo"), aname="_dateTimeInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFlagInfo",lazy=True)(pname=(ns,"flags"), aname="_flags", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"adminDisabled"), aname="_adminDisabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostConfigInfo_Def.__bases__:
                bases = list(ns0.HostConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConfigManager_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConfigManager")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConfigManager_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"cpuScheduler"), aname="_cpuScheduler", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastoreSystem"), aname="_datastoreSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"memoryManager"), aname="_memoryManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"storageSystem"), aname="_storageSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"networkSystem"), aname="_networkSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vmotionSystem"), aname="_vmotionSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"serviceSystem"), aname="_serviceSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"firewallSystem"), aname="_firewallSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"advancedOption"), aname="_advancedOption", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"diagnosticSystem"), aname="_diagnosticSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"autoStartManager"), aname="_autoStartManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"snmpSystem"), aname="_snmpSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"dateTimeSystem"), aname="_dateTimeSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"patchManager"), aname="_patchManager", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"bootDeviceSystem"), aname="_bootDeviceSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"firmwareSystem"), aname="_firmwareSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"healthStatusSystem"), aname="_healthStatusSystem", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostConfigManager_Def.__bases__:
                bases = list(ns0.HostConfigManager_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostConfigManager_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConnectInfoNetworkInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConnectInfoNetworkInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConnectInfoNetworkInfo_Def.schema
            TClist = [GTD("urn:vim25","NetworkSummary",lazy=True)(pname=(ns,"summary"), aname="_summary", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostConnectInfoNetworkInfo_Def.__bases__:
                bases = list(ns0.HostConnectInfoNetworkInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostConnectInfoNetworkInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostConnectInfoNetworkInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostConnectInfoNetworkInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostConnectInfoNetworkInfo_Def.schema
            TClist = [GTD("urn:vim25","HostConnectInfoNetworkInfo",lazy=True)(pname=(ns,"HostConnectInfoNetworkInfo"), aname="_HostConnectInfoNetworkInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostConnectInfoNetworkInfo = []
                    return
            Holder.__name__ = "ArrayOfHostConnectInfoNetworkInfo_Holder"
            self.pyclass = Holder

    class HostNewNetworkConnectInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNewNetworkConnectInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNewNetworkConnectInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostConnectInfoNetworkInfo_Def not in ns0.HostNewNetworkConnectInfo_Def.__bases__:
                bases = list(ns0.HostNewNetworkConnectInfo_Def.__bases__)
                bases.insert(0, ns0.HostConnectInfoNetworkInfo_Def)
                ns0.HostNewNetworkConnectInfo_Def.__bases__ = tuple(bases)

            ns0.HostConnectInfoNetworkInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDatastoreConnectInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDatastoreConnectInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDatastoreConnectInfo_Def.schema
            TClist = [GTD("urn:vim25","DatastoreSummary",lazy=True)(pname=(ns,"summary"), aname="_summary", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDatastoreConnectInfo_Def.__bases__:
                bases = list(ns0.HostDatastoreConnectInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDatastoreConnectInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDatastoreConnectInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDatastoreConnectInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDatastoreConnectInfo_Def.schema
            TClist = [GTD("urn:vim25","HostDatastoreConnectInfo",lazy=True)(pname=(ns,"HostDatastoreConnectInfo"), aname="_HostDatastoreConnectInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDatastoreConnectInfo = []
                    return
            Holder.__name__ = "ArrayOfHostDatastoreConnectInfo_Holder"
            self.pyclass = Holder

    class HostDatastoreExistsConnectInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDatastoreExistsConnectInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDatastoreExistsConnectInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"newDatastoreName"), aname="_newDatastoreName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDatastoreConnectInfo_Def not in ns0.HostDatastoreExistsConnectInfo_Def.__bases__:
                bases = list(ns0.HostDatastoreExistsConnectInfo_Def.__bases__)
                bases.insert(0, ns0.HostDatastoreConnectInfo_Def)
                ns0.HostDatastoreExistsConnectInfo_Def.__bases__ = tuple(bases)

            ns0.HostDatastoreConnectInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDatastoreNameConflictConnectInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDatastoreNameConflictConnectInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDatastoreNameConflictConnectInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"newDatastoreName"), aname="_newDatastoreName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDatastoreConnectInfo_Def not in ns0.HostDatastoreNameConflictConnectInfo_Def.__bases__:
                bases = list(ns0.HostDatastoreNameConflictConnectInfo_Def.__bases__)
                bases.insert(0, ns0.HostDatastoreConnectInfo_Def)
                ns0.HostDatastoreNameConflictConnectInfo_Def.__bases__ = tuple(bases)

            ns0.HostDatastoreConnectInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConnectInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConnectInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConnectInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"serverIp"), aname="_serverIp", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostListSummary",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineSummary",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vimAccountNameRequired"), aname="_vimAccountNameRequired", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"clusterSupported"), aname="_clusterSupported", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostConnectInfoNetworkInfo",lazy=True)(pname=(ns,"network"), aname="_network", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDatastoreConnectInfo",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostConnectInfo_Def.__bases__:
                bases = list(ns0.HostConnectInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostConnectInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConnectSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConnectSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConnectSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"hostName"), aname="_hostName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sslThumbprint"), aname="_sslThumbprint", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"password"), aname="_password", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vmFolder"), aname="_vmFolder", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vimAccountName"), aname="_vimAccountName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vimAccountPassword"), aname="_vimAccountPassword", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostConnectSpec_Def.__bases__:
                bases = list(ns0.HostConnectSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostConnectSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCpuIdInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCpuIdInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCpuIdInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"level"), aname="_level", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vendor"), aname="_vendor", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"eax"), aname="_eax", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ebx"), aname="_ebx", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ecx"), aname="_ecx", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"edx"), aname="_edx", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostCpuIdInfo_Def.__bases__:
                bases = list(ns0.HostCpuIdInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostCpuIdInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostCpuIdInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostCpuIdInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostCpuIdInfo_Def.schema
            TClist = [GTD("urn:vim25","HostCpuIdInfo",lazy=True)(pname=(ns,"HostCpuIdInfo"), aname="_HostCpuIdInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostCpuIdInfo = []
                    return
            Holder.__name__ = "ArrayOfHostCpuIdInfo_Holder"
            self.pyclass = Holder

    class HostHyperThreadScheduleInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostHyperThreadScheduleInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostHyperThreadScheduleInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"available"), aname="_available", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"active"), aname="_active", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostHyperThreadScheduleInfo_Def.__bases__:
                bases = list(ns0.HostHyperThreadScheduleInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostHyperThreadScheduleInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class EnableHyperThreadingRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "EnableHyperThreadingRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.EnableHyperThreadingRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "EnableHyperThreadingRequestType_Holder"
            self.pyclass = Holder

    class DisableHyperThreadingRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DisableHyperThreadingRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DisableHyperThreadingRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DisableHyperThreadingRequestType_Holder"
            self.pyclass = Holder

    class FileQueryFlags_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileQueryFlags")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileQueryFlags_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"fileType"), aname="_fileType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"fileSize"), aname="_fileSize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"modification"), aname="_modification", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.FileQueryFlags_Def.__bases__:
                bases = list(ns0.FileQueryFlags_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.FileQueryFlags_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"fileSize"), aname="_fileSize", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"modification"), aname="_modification", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.FileInfo_Def.__bases__:
                bases = list(ns0.FileInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.FileInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfFileInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfFileInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfFileInfo_Def.schema
            TClist = [GTD("urn:vim25","FileInfo",lazy=True)(pname=(ns,"FileInfo"), aname="_FileInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._FileInfo = []
                    return
            Holder.__name__ = "ArrayOfFileInfo_Holder"
            self.pyclass = Holder

    class FileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.FileQuery_Def.__bases__:
                bases = list(ns0.FileQuery_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.FileQuery_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfFileQuery_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfFileQuery")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfFileQuery_Def.schema
            TClist = [GTD("urn:vim25","FileQuery",lazy=True)(pname=(ns,"FileQuery"), aname="_FileQuery", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._FileQuery = []
                    return
            Holder.__name__ = "ArrayOfFileQuery_Holder"
            self.pyclass = Holder

    class VmConfigFileQueryFilter_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmConfigFileQueryFilter")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmConfigFileQueryFilter_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"matchConfigVersion"), aname="_matchConfigVersion", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VmConfigFileQueryFilter_Def.__bases__:
                bases = list(ns0.VmConfigFileQueryFilter_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VmConfigFileQueryFilter_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmConfigFileQueryFlags_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmConfigFileQueryFlags")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmConfigFileQueryFlags_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"configVersion"), aname="_configVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VmConfigFileQueryFlags_Def.__bases__:
                bases = list(ns0.VmConfigFileQueryFlags_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VmConfigFileQueryFlags_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmConfigFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmConfigFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmConfigFileQuery_Def.schema
            TClist = [GTD("urn:vim25","VmConfigFileQueryFilter",lazy=True)(pname=(ns,"filter"), aname="_filter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VmConfigFileQueryFlags",lazy=True)(pname=(ns,"details"), aname="_details", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.VmConfigFileQuery_Def.__bases__:
                bases = list(ns0.VmConfigFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.VmConfigFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TemplateConfigFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TemplateConfigFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TemplateConfigFileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFileQuery_Def not in ns0.TemplateConfigFileQuery_Def.__bases__:
                bases = list(ns0.TemplateConfigFileQuery_Def.__bases__)
                bases.insert(0, ns0.VmConfigFileQuery_Def)
                ns0.TemplateConfigFileQuery_Def.__bases__ = tuple(bases)

            ns0.VmConfigFileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDiskFileQueryFilter_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDiskFileQueryFilter")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDiskFileQueryFilter_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskType"), aname="_diskType", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"matchHardwareVersion"), aname="_matchHardwareVersion", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"controllerType"), aname="_controllerType", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VmDiskFileQueryFilter_Def.__bases__:
                bases = list(ns0.VmDiskFileQueryFilter_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VmDiskFileQueryFilter_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDiskFileQueryFlags_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDiskFileQueryFlags")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDiskFileQueryFlags_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"diskType"), aname="_diskType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"capacityKb"), aname="_capacityKb", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"hardwareVersion"), aname="_hardwareVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"controllerType"), aname="_controllerType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"diskExtents"), aname="_diskExtents", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VmDiskFileQueryFlags_Def.__bases__:
                bases = list(ns0.VmDiskFileQueryFlags_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VmDiskFileQueryFlags_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDiskFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDiskFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDiskFileQuery_Def.schema
            TClist = [GTD("urn:vim25","VmDiskFileQueryFilter",lazy=True)(pname=(ns,"filter"), aname="_filter", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VmDiskFileQueryFlags",lazy=True)(pname=(ns,"details"), aname="_details", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.VmDiskFileQuery_Def.__bases__:
                bases = list(ns0.VmDiskFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.VmDiskFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FolderFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FolderFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FolderFileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.FolderFileQuery_Def.__bases__:
                bases = list(ns0.FolderFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.FolderFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmSnapshotFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmSnapshotFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmSnapshotFileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.VmSnapshotFileQuery_Def.__bases__:
                bases = list(ns0.VmSnapshotFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.VmSnapshotFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IsoImageFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IsoImageFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IsoImageFileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.IsoImageFileQuery_Def.__bases__:
                bases = list(ns0.IsoImageFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.IsoImageFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FloppyImageFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FloppyImageFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FloppyImageFileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.FloppyImageFileQuery_Def.__bases__:
                bases = list(ns0.FloppyImageFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.FloppyImageFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmNvramFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmNvramFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmNvramFileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.VmNvramFileQuery_Def.__bases__:
                bases = list(ns0.VmNvramFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.VmNvramFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmLogFileQuery_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmLogFileQuery")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmLogFileQuery_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileQuery_Def not in ns0.VmLogFileQuery_Def.__bases__:
                bases = list(ns0.VmLogFileQuery_Def.__bases__)
                bases.insert(0, ns0.FileQuery_Def)
                ns0.VmLogFileQuery_Def.__bases__ = tuple(bases)

            ns0.FileQuery_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmConfigFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmConfigFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmConfigFileInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"configVersion"), aname="_configVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.VmConfigFileInfo_Def.__bases__:
                bases = list(ns0.VmConfigFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.VmConfigFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class TemplateConfigFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TemplateConfigFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TemplateConfigFileInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmConfigFileInfo_Def not in ns0.TemplateConfigFileInfo_Def.__bases__:
                bases = list(ns0.TemplateConfigFileInfo_Def.__bases__)
                bases.insert(0, ns0.VmConfigFileInfo_Def)
                ns0.TemplateConfigFileInfo_Def.__bases__ = tuple(bases)

            ns0.VmConfigFileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmDiskFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmDiskFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmDiskFileInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskType"), aname="_diskType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"capacityKb"), aname="_capacityKb", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"hardwareVersion"), aname="_hardwareVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"controllerType"), aname="_controllerType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diskExtents"), aname="_diskExtents", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.VmDiskFileInfo_Def.__bases__:
                bases = list(ns0.VmDiskFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.VmDiskFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FolderFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FolderFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FolderFileInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.FolderFileInfo_Def.__bases__:
                bases = list(ns0.FolderFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.FolderFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmSnapshotFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmSnapshotFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmSnapshotFileInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.VmSnapshotFileInfo_Def.__bases__:
                bases = list(ns0.VmSnapshotFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.VmSnapshotFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IsoImageFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IsoImageFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IsoImageFileInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.IsoImageFileInfo_Def.__bases__:
                bases = list(ns0.IsoImageFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.IsoImageFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FloppyImageFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FloppyImageFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FloppyImageFileInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.FloppyImageFileInfo_Def.__bases__:
                bases = list(ns0.FloppyImageFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.FloppyImageFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmNvramFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmNvramFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmNvramFileInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.VmNvramFileInfo_Def.__bases__:
                bases = list(ns0.VmNvramFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.VmNvramFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmLogFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmLogFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmLogFileInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.FileInfo_Def not in ns0.VmLogFileInfo_Def.__bases__:
                bases = list(ns0.VmLogFileInfo_Def.__bases__)
                bases.insert(0, ns0.FileInfo_Def)
                ns0.VmLogFileInfo_Def.__bases__ = tuple(bases)

            ns0.FileInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDatastoreBrowserSearchSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDatastoreBrowserSearchSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDatastoreBrowserSearchSpec_Def.schema
            TClist = [GTD("urn:vim25","FileQuery",lazy=True)(pname=(ns,"query"), aname="_query", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","FileQueryFlags",lazy=True)(pname=(ns,"details"), aname="_details", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"searchCaseInsensitive"), aname="_searchCaseInsensitive", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"matchPattern"), aname="_matchPattern", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sortFoldersFirst"), aname="_sortFoldersFirst", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDatastoreBrowserSearchSpec_Def.__bases__:
                bases = list(ns0.HostDatastoreBrowserSearchSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDatastoreBrowserSearchSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDatastoreBrowserSearchResults_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDatastoreBrowserSearchResults")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDatastoreBrowserSearchResults_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"folderPath"), aname="_folderPath", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","FileInfo",lazy=True)(pname=(ns,"file"), aname="_file", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDatastoreBrowserSearchResults_Def.__bases__:
                bases = list(ns0.HostDatastoreBrowserSearchResults_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDatastoreBrowserSearchResults_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDatastoreBrowserSearchResults_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDatastoreBrowserSearchResults")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDatastoreBrowserSearchResults_Def.schema
            TClist = [GTD("urn:vim25","HostDatastoreBrowserSearchResults",lazy=True)(pname=(ns,"HostDatastoreBrowserSearchResults"), aname="_HostDatastoreBrowserSearchResults", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDatastoreBrowserSearchResults = []
                    return
            Holder.__name__ = "ArrayOfHostDatastoreBrowserSearchResults_Holder"
            self.pyclass = Holder

    class SearchDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SearchDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SearchDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"datastorePath"), aname="_datastorePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDatastoreBrowserSearchSpec",lazy=True)(pname=(ns,"searchSpec"), aname="_searchSpec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastorePath = None
                    self._searchSpec = None
                    return
            Holder.__name__ = "SearchDatastoreRequestType_Holder"
            self.pyclass = Holder

    class SearchDatastoreSubFoldersRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SearchDatastoreSubFoldersRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SearchDatastoreSubFoldersRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"datastorePath"), aname="_datastorePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDatastoreBrowserSearchSpec",lazy=True)(pname=(ns,"searchSpec"), aname="_searchSpec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastorePath = None
                    self._searchSpec = None
                    return
            Holder.__name__ = "SearchDatastoreSubFoldersRequestType_Holder"
            self.pyclass = Holder

    class DeleteFileRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DeleteFileRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DeleteFileRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"datastorePath"), aname="_datastorePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastorePath = None
                    return
            Holder.__name__ = "DeleteFileRequestType_Holder"
            self.pyclass = Holder

    class HostDatastoreSystemCapabilities_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDatastoreSystemCapabilities")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDatastoreSystemCapabilities_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"nfsMountCreationRequired"), aname="_nfsMountCreationRequired", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"nfsMountCreationSupported"), aname="_nfsMountCreationSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"localDatastoreSupported"), aname="_localDatastoreSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDatastoreSystemCapabilities_Def.__bases__:
                bases = list(ns0.HostDatastoreSystemCapabilities_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDatastoreSystemCapabilities_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdateLocalSwapDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateLocalSwapDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateLocalSwapDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastore = None
                    return
            Holder.__name__ = "UpdateLocalSwapDatastoreRequestType_Holder"
            self.pyclass = Holder

    class QueryAvailableDisksForVmfsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryAvailableDisksForVmfsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryAvailableDisksForVmfsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastore = None
                    return
            Holder.__name__ = "QueryAvailableDisksForVmfsRequestType_Holder"
            self.pyclass = Holder

    class QueryVmfsDatastoreCreateOptionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryVmfsDatastoreCreateOptionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryVmfsDatastoreCreateOptionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"devicePath"), aname="_devicePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._devicePath = None
                    return
            Holder.__name__ = "QueryVmfsDatastoreCreateOptionsRequestType_Holder"
            self.pyclass = Holder

    class CreateVmfsDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateVmfsDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateVmfsDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VmfsDatastoreCreateSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateVmfsDatastoreRequestType_Holder"
            self.pyclass = Holder

    class QueryVmfsDatastoreExtendOptionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryVmfsDatastoreExtendOptionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryVmfsDatastoreExtendOptionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"devicePath"), aname="_devicePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastore = None
                    self._devicePath = None
                    return
            Holder.__name__ = "QueryVmfsDatastoreExtendOptionsRequestType_Holder"
            self.pyclass = Holder

    class ExtendVmfsDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ExtendVmfsDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ExtendVmfsDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VmfsDatastoreExtendSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastore = None
                    self._spec = None
                    return
            Holder.__name__ = "ExtendVmfsDatastoreRequestType_Holder"
            self.pyclass = Holder

    class CreateNasDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateNasDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateNasDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNasVolumeSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateNasDatastoreRequestType_Holder"
            self.pyclass = Holder

    class CreateLocalDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateLocalDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateLocalDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._path = None
                    return
            Holder.__name__ = "CreateLocalDatastoreRequestType_Holder"
            self.pyclass = Holder

    class RemoveDatastoreRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveDatastoreRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveDatastoreRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._datastore = None
                    return
            Holder.__name__ = "RemoveDatastoreRequestType_Holder"
            self.pyclass = Holder

    class ConfigureDatastorePrincipalRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ConfigureDatastorePrincipalRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ConfigureDatastorePrincipalRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"password"), aname="_password", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._userName = None
                    self._password = None
                    return
            Holder.__name__ = "ConfigureDatastorePrincipalRequestType_Holder"
            self.pyclass = Holder

    class VmfsDatastoreInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreInfo_Def.schema
            TClist = [GTD("urn:vim25","HostVmfsVolume",lazy=True)(pname=(ns,"vmfs"), aname="_vmfs", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatastoreInfo_Def not in ns0.VmfsDatastoreInfo_Def.__bases__:
                bases = list(ns0.VmfsDatastoreInfo_Def.__bases__)
                bases.insert(0, ns0.DatastoreInfo_Def)
                ns0.VmfsDatastoreInfo_Def.__bases__ = tuple(bases)

            ns0.DatastoreInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class NasDatastoreInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "NasDatastoreInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.NasDatastoreInfo_Def.schema
            TClist = [GTD("urn:vim25","HostNasVolume",lazy=True)(pname=(ns,"nas"), aname="_nas", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatastoreInfo_Def not in ns0.NasDatastoreInfo_Def.__bases__:
                bases = list(ns0.NasDatastoreInfo_Def.__bases__)
                bases.insert(0, ns0.DatastoreInfo_Def)
                ns0.NasDatastoreInfo_Def.__bases__ = tuple(bases)

            ns0.DatastoreInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LocalDatastoreInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LocalDatastoreInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LocalDatastoreInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DatastoreInfo_Def not in ns0.LocalDatastoreInfo_Def.__bases__:
                bases = list(ns0.LocalDatastoreInfo_Def.__bases__)
                bases.insert(0, ns0.DatastoreInfo_Def)
                ns0.LocalDatastoreInfo_Def.__bases__ = tuple(bases)

            ns0.DatastoreInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskUuid"), aname="_diskUuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VmfsDatastoreSpec_Def.__bases__:
                bases = list(ns0.VmfsDatastoreSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VmfsDatastoreSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreCreateSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreCreateSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreCreateSpec_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionSpec",lazy=True)(pname=(ns,"partition"), aname="_partition", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVmfsSpec",lazy=True)(pname=(ns,"vmfs"), aname="_vmfs", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"extent"), aname="_extent", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmfsDatastoreSpec_Def not in ns0.VmfsDatastoreCreateSpec_Def.__bases__:
                bases = list(ns0.VmfsDatastoreCreateSpec_Def.__bases__)
                bases.insert(0, ns0.VmfsDatastoreSpec_Def)
                ns0.VmfsDatastoreCreateSpec_Def.__bases__ = tuple(bases)

            ns0.VmfsDatastoreSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreExtendSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreExtendSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreExtendSpec_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionSpec",lazy=True)(pname=(ns,"partition"), aname="_partition", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"extent"), aname="_extent", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmfsDatastoreSpec_Def not in ns0.VmfsDatastoreExtendSpec_Def.__bases__:
                bases = list(ns0.VmfsDatastoreExtendSpec_Def.__bases__)
                bases.insert(0, ns0.VmfsDatastoreSpec_Def)
                ns0.VmfsDatastoreExtendSpec_Def.__bases__ = tuple(bases)

            ns0.VmfsDatastoreSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreBaseOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreBaseOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreBaseOption_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionLayout",lazy=True)(pname=(ns,"layout"), aname="_layout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VmfsDatastoreBaseOption_Def.__bases__:
                bases = list(ns0.VmfsDatastoreBaseOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VmfsDatastoreBaseOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreSingleExtentOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreSingleExtentOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreSingleExtentOption_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionBlockRange",lazy=True)(pname=(ns,"vmfsExtent"), aname="_vmfsExtent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmfsDatastoreBaseOption_Def not in ns0.VmfsDatastoreSingleExtentOption_Def.__bases__:
                bases = list(ns0.VmfsDatastoreSingleExtentOption_Def.__bases__)
                bases.insert(0, ns0.VmfsDatastoreBaseOption_Def)
                ns0.VmfsDatastoreSingleExtentOption_Def.__bases__ = tuple(bases)

            ns0.VmfsDatastoreBaseOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreAllExtentOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreAllExtentOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreAllExtentOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmfsDatastoreSingleExtentOption_Def not in ns0.VmfsDatastoreAllExtentOption_Def.__bases__:
                bases = list(ns0.VmfsDatastoreAllExtentOption_Def.__bases__)
                bases.insert(0, ns0.VmfsDatastoreSingleExtentOption_Def)
                ns0.VmfsDatastoreAllExtentOption_Def.__bases__ = tuple(bases)

            ns0.VmfsDatastoreSingleExtentOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreMultipleExtentOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreMultipleExtentOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreMultipleExtentOption_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionBlockRange",lazy=True)(pname=(ns,"vmfsExtent"), aname="_vmfsExtent", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VmfsDatastoreBaseOption_Def not in ns0.VmfsDatastoreMultipleExtentOption_Def.__bases__:
                bases = list(ns0.VmfsDatastoreMultipleExtentOption_Def.__bases__)
                bases.insert(0, ns0.VmfsDatastoreBaseOption_Def)
                ns0.VmfsDatastoreMultipleExtentOption_Def.__bases__ = tuple(bases)

            ns0.VmfsDatastoreBaseOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VmfsDatastoreOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VmfsDatastoreOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VmfsDatastoreOption_Def.schema
            TClist = [GTD("urn:vim25","VmfsDatastoreBaseOption",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VmfsDatastoreSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VmfsDatastoreOption_Def.__bases__:
                bases = list(ns0.VmfsDatastoreOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VmfsDatastoreOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVmfsDatastoreOption_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVmfsDatastoreOption")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVmfsDatastoreOption_Def.schema
            TClist = [GTD("urn:vim25","VmfsDatastoreOption",lazy=True)(pname=(ns,"VmfsDatastoreOption"), aname="_VmfsDatastoreOption", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VmfsDatastoreOption = []
                    return
            Holder.__name__ = "ArrayOfVmfsDatastoreOption_Holder"
            self.pyclass = Holder

    class HostDateTimeConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDateTimeConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDateTimeConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"timeZone"), aname="_timeZone", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNtpConfig",lazy=True)(pname=(ns,"ntpConfig"), aname="_ntpConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDateTimeConfig_Def.__bases__:
                bases = list(ns0.HostDateTimeConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDateTimeConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDateTimeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDateTimeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDateTimeInfo_Def.schema
            TClist = [GTD("urn:vim25","HostDateTimeSystemTimeZone",lazy=True)(pname=(ns,"timeZone"), aname="_timeZone", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNtpConfig",lazy=True)(pname=(ns,"ntpConfig"), aname="_ntpConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDateTimeInfo_Def.__bases__:
                bases = list(ns0.HostDateTimeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDateTimeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDateTimeSystemTimeZone_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDateTimeSystemTimeZone")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDateTimeSystemTimeZone_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"gmtOffset"), aname="_gmtOffset", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDateTimeSystemTimeZone_Def.__bases__:
                bases = list(ns0.HostDateTimeSystemTimeZone_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDateTimeSystemTimeZone_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDateTimeSystemTimeZone_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDateTimeSystemTimeZone")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDateTimeSystemTimeZone_Def.schema
            TClist = [GTD("urn:vim25","HostDateTimeSystemTimeZone",lazy=True)(pname=(ns,"HostDateTimeSystemTimeZone"), aname="_HostDateTimeSystemTimeZone", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDateTimeSystemTimeZone = []
                    return
            Holder.__name__ = "ArrayOfHostDateTimeSystemTimeZone_Holder"
            self.pyclass = Holder

    class UpdateDateTimeConfigRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateDateTimeConfigRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateDateTimeConfigRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDateTimeConfig",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._config = None
                    return
            Holder.__name__ = "UpdateDateTimeConfigRequestType_Holder"
            self.pyclass = Holder

    class QueryAvailableTimeZonesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryAvailableTimeZonesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryAvailableTimeZonesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "QueryAvailableTimeZonesRequestType_Holder"
            self.pyclass = Holder

    class QueryDateTimeRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryDateTimeRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryDateTimeRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "QueryDateTimeRequestType_Holder"
            self.pyclass = Holder

    class UpdateDateTimeRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateDateTimeRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateDateTimeRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"dateTime"), aname="_dateTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._dateTime = None
                    return
            Holder.__name__ = "UpdateDateTimeRequestType_Holder"
            self.pyclass = Holder

    class RefreshDateTimeSystemRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshDateTimeSystemRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshDateTimeSystemRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshDateTimeSystemRequestType_Holder"
            self.pyclass = Holder

    class HostDevice_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDevice")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDevice_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"deviceName"), aname="_deviceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"deviceType"), aname="_deviceType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDevice_Def.__bases__:
                bases = list(ns0.HostDevice_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDevice_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDhcpServiceSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDhcpServiceSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDhcpServiceSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"virtualSwitch"), aname="_virtualSwitch", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"defaultLeaseDuration"), aname="_defaultLeaseDuration", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"leaseBeginIp"), aname="_leaseBeginIp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"leaseEndIp"), aname="_leaseEndIp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxLeaseDuration"), aname="_maxLeaseDuration", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"unlimitedLease"), aname="_unlimitedLease", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipSubnetAddr"), aname="_ipSubnetAddr", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipSubnetMask"), aname="_ipSubnetMask", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDhcpServiceSpec_Def.__bases__:
                bases = list(ns0.HostDhcpServiceSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDhcpServiceSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDhcpServiceConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDhcpServiceConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDhcpServiceConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"changeOperation"), aname="_changeOperation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDhcpServiceSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDhcpServiceConfig_Def.__bases__:
                bases = list(ns0.HostDhcpServiceConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDhcpServiceConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDhcpServiceConfig_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDhcpServiceConfig")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDhcpServiceConfig_Def.schema
            TClist = [GTD("urn:vim25","HostDhcpServiceConfig",lazy=True)(pname=(ns,"HostDhcpServiceConfig"), aname="_HostDhcpServiceConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDhcpServiceConfig = []
                    return
            Holder.__name__ = "ArrayOfHostDhcpServiceConfig_Holder"
            self.pyclass = Holder

    class HostDhcpService_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDhcpService")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDhcpService_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDhcpServiceSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDhcpService_Def.__bases__:
                bases = list(ns0.HostDhcpService_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDhcpService_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDhcpService_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDhcpService")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDhcpService_Def.schema
            TClist = [GTD("urn:vim25","HostDhcpService",lazy=True)(pname=(ns,"HostDhcpService"), aname="_HostDhcpService", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDhcpService = []
                    return
            Holder.__name__ = "ArrayOfHostDhcpService_Holder"
            self.pyclass = Holder

    class QueryAvailablePartitionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryAvailablePartitionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryAvailablePartitionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "QueryAvailablePartitionRequestType_Holder"
            self.pyclass = Holder

    class SelectActivePartitionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SelectActivePartitionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SelectActivePartitionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"partition"), aname="_partition", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._partition = None
                    return
            Holder.__name__ = "SelectActivePartitionRequestType_Holder"
            self.pyclass = Holder

    class QueryPartitionCreateOptionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryPartitionCreateOptionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryPartitionCreateOptionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"storageType"), aname="_storageType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diagnosticType"), aname="_diagnosticType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._storageType = None
                    self._diagnosticType = None
                    return
            Holder.__name__ = "QueryPartitionCreateOptionsRequestType_Holder"
            self.pyclass = Holder

    class QueryPartitionCreateDescRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryPartitionCreateDescRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryPartitionCreateDescRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diskUuid"), aname="_diskUuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diagnosticType"), aname="_diagnosticType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._diskUuid = None
                    self._diagnosticType = None
                    return
            Holder.__name__ = "QueryPartitionCreateDescRequestType_Holder"
            self.pyclass = Holder

    class CreateDiagnosticPartitionRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateDiagnosticPartitionRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateDiagnosticPartitionRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiagnosticPartitionCreateSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateDiagnosticPartitionRequestType_Holder"
            self.pyclass = Holder

    class DiagnosticPartitionStorageType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DiagnosticPartitionStorageType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class DiagnosticPartitionType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DiagnosticPartitionType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostDiagnosticPartitionCreateOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiagnosticPartitionCreateOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiagnosticPartitionCreateOption_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"storageType"), aname="_storageType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diagnosticType"), aname="_diagnosticType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDisk",lazy=True)(pname=(ns,"disk"), aname="_disk", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiagnosticPartitionCreateOption_Def.__bases__:
                bases = list(ns0.HostDiagnosticPartitionCreateOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiagnosticPartitionCreateOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDiagnosticPartitionCreateOption_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDiagnosticPartitionCreateOption")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDiagnosticPartitionCreateOption_Def.schema
            TClist = [GTD("urn:vim25","HostDiagnosticPartitionCreateOption",lazy=True)(pname=(ns,"HostDiagnosticPartitionCreateOption"), aname="_HostDiagnosticPartitionCreateOption", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDiagnosticPartitionCreateOption = []
                    return
            Holder.__name__ = "ArrayOfHostDiagnosticPartitionCreateOption_Holder"
            self.pyclass = Holder

    class HostDiagnosticPartitionCreateSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiagnosticPartitionCreateSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiagnosticPartitionCreateSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"storageType"), aname="_storageType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diagnosticType"), aname="_diagnosticType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskPartitionSpec",lazy=True)(pname=(ns,"partition"), aname="_partition", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"active"), aname="_active", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiagnosticPartitionCreateSpec_Def.__bases__:
                bases = list(ns0.HostDiagnosticPartitionCreateSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiagnosticPartitionCreateSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiagnosticPartitionCreateDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiagnosticPartitionCreateDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiagnosticPartitionCreateDescription_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionLayout",lazy=True)(pname=(ns,"layout"), aname="_layout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diskUuid"), aname="_diskUuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiagnosticPartitionCreateSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiagnosticPartitionCreateDescription_Def.__bases__:
                bases = list(ns0.HostDiagnosticPartitionCreateDescription_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiagnosticPartitionCreateDescription_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiagnosticPartition_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiagnosticPartition")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiagnosticPartition_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"storageType"), aname="_storageType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diagnosticType"), aname="_diagnosticType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"slots"), aname="_slots", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiagnosticPartition_Def.__bases__:
                bases = list(ns0.HostDiagnosticPartition_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiagnosticPartition_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDiagnosticPartition_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDiagnosticPartition")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDiagnosticPartition_Def.schema
            TClist = [GTD("urn:vim25","HostDiagnosticPartition",lazy=True)(pname=(ns,"HostDiagnosticPartition"), aname="_HostDiagnosticPartition", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDiagnosticPartition = []
                    return
            Holder.__name__ = "ArrayOfHostDiagnosticPartition_Holder"
            self.pyclass = Holder

    class HostDiskDimensionsChs_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskDimensionsChs")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskDimensionsChs_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"cylinder"), aname="_cylinder", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"head"), aname="_head", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"sector"), aname="_sector", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskDimensionsChs_Def.__bases__:
                bases = list(ns0.HostDiskDimensionsChs_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskDimensionsChs_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiskDimensionsLba_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskDimensionsLba")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskDimensionsLba_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"blockSize"), aname="_blockSize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"block"), aname="_block", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskDimensionsLba_Def.__bases__:
                bases = list(ns0.HostDiskDimensionsLba_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskDimensionsLba_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiskDimensions_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskDimensions")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskDimensions_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskDimensions_Def.__bases__:
                bases = list(ns0.HostDiskDimensions_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskDimensions_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiskPartitionInfoType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostDiskPartitionInfoType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostDiskPartitionAttributes_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskPartitionAttributes")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskPartitionAttributes_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"partition"), aname="_partition", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"startSector"), aname="_startSector", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"endSector"), aname="_endSector", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"logical"), aname="_logical", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"attributes"), aname="_attributes", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskPartitionAttributes_Def.__bases__:
                bases = list(ns0.HostDiskPartitionAttributes_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskPartitionAttributes_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDiskPartitionAttributes_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDiskPartitionAttributes")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDiskPartitionAttributes_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionAttributes",lazy=True)(pname=(ns,"HostDiskPartitionAttributes"), aname="_HostDiskPartitionAttributes", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDiskPartitionAttributes = []
                    return
            Holder.__name__ = "ArrayOfHostDiskPartitionAttributes_Holder"
            self.pyclass = Holder

    class HostDiskPartitionBlockRange_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskPartitionBlockRange")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskPartitionBlockRange_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"partition"), aname="_partition", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskDimensionsLba",lazy=True)(pname=(ns,"start"), aname="_start", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskDimensionsLba",lazy=True)(pname=(ns,"end"), aname="_end", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskPartitionBlockRange_Def.__bases__:
                bases = list(ns0.HostDiskPartitionBlockRange_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskPartitionBlockRange_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDiskPartitionBlockRange_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDiskPartitionBlockRange")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDiskPartitionBlockRange_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionBlockRange",lazy=True)(pname=(ns,"HostDiskPartitionBlockRange"), aname="_HostDiskPartitionBlockRange", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDiskPartitionBlockRange = []
                    return
            Holder.__name__ = "ArrayOfHostDiskPartitionBlockRange_Holder"
            self.pyclass = Holder

    class HostDiskPartitionSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskPartitionSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskPartitionSpec_Def.schema
            TClist = [GTD("urn:vim25","HostDiskDimensionsChs",lazy=True)(pname=(ns,"chs"), aname="_chs", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"totalSectors"), aname="_totalSectors", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskPartitionAttributes",lazy=True)(pname=(ns,"partition"), aname="_partition", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskPartitionSpec_Def.__bases__:
                bases = list(ns0.HostDiskPartitionSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskPartitionSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiskPartitionLayout_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskPartitionLayout")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskPartitionLayout_Def.schema
            TClist = [GTD("urn:vim25","HostDiskDimensionsLba",lazy=True)(pname=(ns,"total"), aname="_total", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskPartitionBlockRange",lazy=True)(pname=(ns,"partition"), aname="_partition", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskPartitionLayout_Def.__bases__:
                bases = list(ns0.HostDiskPartitionLayout_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskPartitionLayout_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiskPartitionInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskPartitionInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskPartitionInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"deviceName"), aname="_deviceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskPartitionSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskPartitionLayout",lazy=True)(pname=(ns,"layout"), aname="_layout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskPartitionInfo_Def.__bases__:
                bases = list(ns0.HostDiskPartitionInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskPartitionInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDiskPartitionInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDiskPartitionInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDiskPartitionInfo_Def.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionInfo",lazy=True)(pname=(ns,"HostDiskPartitionInfo"), aname="_HostDiskPartitionInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDiskPartitionInfo = []
                    return
            Holder.__name__ = "ArrayOfHostDiskPartitionInfo_Holder"
            self.pyclass = Holder

    class HostDnsConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDnsConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDnsConfig_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"dhcp"), aname="_dhcp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"virtualNicDevice"), aname="_virtualNicDevice", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"hostName"), aname="_hostName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"domainName"), aname="_domainName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"address"), aname="_address", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"searchDomain"), aname="_searchDomain", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDnsConfig_Def.__bases__:
                bases = list(ns0.HostDnsConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDnsConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ModeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ModeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ModeInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"browse"), aname="_browse", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"read"), aname="_read", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"modify"), aname="_modify", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"use"), aname="_use", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"admin"), aname="_admin", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"full"), aname="_full", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ModeInfo_Def.__bases__:
                bases = list(ns0.ModeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ModeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostFileAccess_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFileAccess")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFileAccess_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"who"), aname="_who", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"what"), aname="_what", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFileAccess_Def.__bases__:
                bases = list(ns0.HostFileAccess_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFileAccess_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostFileSystemVolumeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFileSystemVolumeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFileSystemVolumeInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"volumeTypeList"), aname="_volumeTypeList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFileSystemMountInfo",lazy=True)(pname=(ns,"mountInfo"), aname="_mountInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFileSystemVolumeInfo_Def.__bases__:
                bases = list(ns0.HostFileSystemVolumeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFileSystemVolumeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostFileSystemMountInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFileSystemMountInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFileSystemMountInfo_Def.schema
            TClist = [GTD("urn:vim25","HostMountInfo",lazy=True)(pname=(ns,"mountInfo"), aname="_mountInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFileSystemVolume",lazy=True)(pname=(ns,"volume"), aname="_volume", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFileSystemMountInfo_Def.__bases__:
                bases = list(ns0.HostFileSystemMountInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFileSystemMountInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostFileSystemMountInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostFileSystemMountInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostFileSystemMountInfo_Def.schema
            TClist = [GTD("urn:vim25","HostFileSystemMountInfo",lazy=True)(pname=(ns,"HostFileSystemMountInfo"), aname="_HostFileSystemMountInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostFileSystemMountInfo = []
                    return
            Holder.__name__ = "ArrayOfHostFileSystemMountInfo_Holder"
            self.pyclass = Holder

    class HostFileSystemVolume_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFileSystemVolume")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFileSystemVolume_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"capacity"), aname="_capacity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFileSystemVolume_Def.__bases__:
                bases = list(ns0.HostFileSystemVolume_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFileSystemVolume_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNasVolumeSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNasVolumeSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNasVolumeSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"remoteHost"), aname="_remoteHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"remotePath"), aname="_remotePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"localPath"), aname="_localPath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"accessMode"), aname="_accessMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"password"), aname="_password", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNasVolumeSpec_Def.__bases__:
                bases = list(ns0.HostNasVolumeSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNasVolumeSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNasVolume_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNasVolume")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNasVolume_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"remoteHost"), aname="_remoteHost", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"remotePath"), aname="_remotePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostFileSystemVolume_Def not in ns0.HostNasVolume_Def.__bases__:
                bases = list(ns0.HostNasVolume_Def.__bases__)
                bases.insert(0, ns0.HostFileSystemVolume_Def)
                ns0.HostNasVolume_Def.__bases__ = tuple(bases)

            ns0.HostFileSystemVolume_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostLocalFileSystemVolumeSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostLocalFileSystemVolumeSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostLocalFileSystemVolumeSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"localPath"), aname="_localPath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostLocalFileSystemVolumeSpec_Def.__bases__:
                bases = list(ns0.HostLocalFileSystemVolumeSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostLocalFileSystemVolumeSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostLocalFileSystemVolume_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostLocalFileSystemVolume")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostLocalFileSystemVolume_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostFileSystemVolume_Def not in ns0.HostLocalFileSystemVolume_Def.__bases__:
                bases = list(ns0.HostLocalFileSystemVolume_Def.__bases__)
                bases.insert(0, ns0.HostFileSystemVolume_Def)
                ns0.HostLocalFileSystemVolume_Def.__bases__ = tuple(bases)

            ns0.HostFileSystemVolume_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostFirewallDefaultPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFirewallDefaultPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFirewallDefaultPolicy_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"incomingBlocked"), aname="_incomingBlocked", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"outgoingBlocked"), aname="_outgoingBlocked", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFirewallDefaultPolicy_Def.__bases__:
                bases = list(ns0.HostFirewallDefaultPolicy_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFirewallDefaultPolicy_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostFirewallInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFirewallInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFirewallInfo_Def.schema
            TClist = [GTD("urn:vim25","HostFirewallDefaultPolicy",lazy=True)(pname=(ns,"defaultPolicy"), aname="_defaultPolicy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFirewallRuleset",lazy=True)(pname=(ns,"ruleset"), aname="_ruleset", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFirewallInfo_Def.__bases__:
                bases = list(ns0.HostFirewallInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFirewallInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdateDefaultPolicyRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateDefaultPolicyRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateDefaultPolicyRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFirewallDefaultPolicy",lazy=True)(pname=(ns,"defaultPolicy"), aname="_defaultPolicy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._defaultPolicy = None
                    return
            Holder.__name__ = "UpdateDefaultPolicyRequestType_Holder"
            self.pyclass = Holder

    class EnableRulesetRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "EnableRulesetRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.EnableRulesetRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._id = None
                    return
            Holder.__name__ = "EnableRulesetRequestType_Holder"
            self.pyclass = Holder

    class DisableRulesetRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DisableRulesetRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DisableRulesetRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._id = None
                    return
            Holder.__name__ = "DisableRulesetRequestType_Holder"
            self.pyclass = Holder

    class RefreshFirewallRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshFirewallRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshFirewallRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshFirewallRequestType_Holder"
            self.pyclass = Holder

    class ResetFirmwareToFactoryDefaultsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetFirmwareToFactoryDefaultsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetFirmwareToFactoryDefaultsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ResetFirmwareToFactoryDefaultsRequestType_Holder"
            self.pyclass = Holder

    class BackupFirmwareConfigurationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "BackupFirmwareConfigurationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.BackupFirmwareConfigurationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "BackupFirmwareConfigurationRequestType_Holder"
            self.pyclass = Holder

    class QueryFirmwareConfigUploadURLRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryFirmwareConfigUploadURLRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryFirmwareConfigUploadURLRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "QueryFirmwareConfigUploadURLRequestType_Holder"
            self.pyclass = Holder

    class RestoreFirmwareConfigurationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RestoreFirmwareConfigurationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RestoreFirmwareConfigurationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._force = None
                    return
            Holder.__name__ = "RestoreFirmwareConfigurationRequestType_Holder"
            self.pyclass = Holder

    class HostFlagInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFlagInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFlagInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"backgroundSnapshotsEnabled"), aname="_backgroundSnapshotsEnabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFlagInfo_Def.__bases__:
                bases = list(ns0.HostFlagInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFlagInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostHardwareInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostHardwareInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostHardwareInfo_Def.schema
            TClist = [GTD("urn:vim25","HostSystemInfo",lazy=True)(pname=(ns,"systemInfo"), aname="_systemInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostCpuInfo",lazy=True)(pname=(ns,"cpuInfo"), aname="_cpuInfo", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostCpuPackage",lazy=True)(pname=(ns,"cpuPkg"), aname="_cpuPkg", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memorySize"), aname="_memorySize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNumaInfo",lazy=True)(pname=(ns,"numaInfo"), aname="_numaInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPciDevice",lazy=True)(pname=(ns,"pciDevice"), aname="_pciDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostCpuIdInfo",lazy=True)(pname=(ns,"cpuFeature"), aname="_cpuFeature", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostBIOSInfo",lazy=True)(pname=(ns,"biosInfo"), aname="_biosInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostHardwareInfo_Def.__bases__:
                bases = list(ns0.HostHardwareInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostHardwareInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostSystemInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostSystemInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostSystemInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"vendor"), aname="_vendor", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"model"), aname="_model", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSystemIdentificationInfo",lazy=True)(pname=(ns,"otherIdentifyingInfo"), aname="_otherIdentifyingInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostSystemInfo_Def.__bases__:
                bases = list(ns0.HostSystemInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostSystemInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCpuInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCpuInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCpuInfo_Def.schema
            TClist = [ZSI.TCnumbers.Ishort(pname=(ns,"numCpuPackages"), aname="_numCpuPackages", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"numCpuCores"), aname="_numCpuCores", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"numCpuThreads"), aname="_numCpuThreads", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"hz"), aname="_hz", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostCpuInfo_Def.__bases__:
                bases = list(ns0.HostCpuInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostCpuInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostCpuPackageVendor_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostCpuPackageVendor")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostCpuPackage_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostCpuPackage")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostCpuPackage_Def.schema
            TClist = [ZSI.TCnumbers.Ishort(pname=(ns,"index"), aname="_index", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vendor"), aname="_vendor", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"hz"), aname="_hz", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"busHz"), aname="_busHz", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"threadId"), aname="_threadId", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostCpuIdInfo",lazy=True)(pname=(ns,"cpuFeature"), aname="_cpuFeature", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostCpuPackage_Def.__bases__:
                bases = list(ns0.HostCpuPackage_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostCpuPackage_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostCpuPackage_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostCpuPackage")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostCpuPackage_Def.schema
            TClist = [GTD("urn:vim25","HostCpuPackage",lazy=True)(pname=(ns,"HostCpuPackage"), aname="_HostCpuPackage", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostCpuPackage = []
                    return
            Holder.__name__ = "ArrayOfHostCpuPackage_Holder"
            self.pyclass = Holder

    class HostNumaInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNumaInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNumaInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numNodes"), aname="_numNodes", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNumaNode",lazy=True)(pname=(ns,"numaNode"), aname="_numaNode", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNumaInfo_Def.__bases__:
                bases = list(ns0.HostNumaInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNumaInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNumaNode_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNumaNode")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNumaNode_Def.schema
            TClist = [ZSI.TCnumbers.Ibyte(pname=(ns,"typeId"), aname="_typeId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"cpuID"), aname="_cpuID", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memoryRangeBegin"), aname="_memoryRangeBegin", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memoryRangeLength"), aname="_memoryRangeLength", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNumaNode_Def.__bases__:
                bases = list(ns0.HostNumaNode_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNumaNode_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostNumaNode_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostNumaNode")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostNumaNode_Def.schema
            TClist = [GTD("urn:vim25","HostNumaNode",lazy=True)(pname=(ns,"HostNumaNode"), aname="_HostNumaNode", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostNumaNode = []
                    return
            Holder.__name__ = "ArrayOfHostNumaNode_Holder"
            self.pyclass = Holder

    class HostBIOSInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostBIOSInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostBIOSInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"biosVersion"), aname="_biosVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"releaseDate"), aname="_releaseDate", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostBIOSInfo_Def.__bases__:
                bases = list(ns0.HostBIOSInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostBIOSInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostHardwareElementStatus_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostHardwareElementStatus")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostHardwareElementInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostHardwareElementInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostHardwareElementInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"status"), aname="_status", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostHardwareElementInfo_Def.__bases__:
                bases = list(ns0.HostHardwareElementInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostHardwareElementInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostHardwareElementInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostHardwareElementInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostHardwareElementInfo_Def.schema
            TClist = [GTD("urn:vim25","HostHardwareElementInfo",lazy=True)(pname=(ns,"HostHardwareElementInfo"), aname="_HostHardwareElementInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostHardwareElementInfo = []
                    return
            Holder.__name__ = "ArrayOfHostHardwareElementInfo_Holder"
            self.pyclass = Holder

    class HostStorageOperationalInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostStorageOperationalInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostStorageOperationalInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"property"), aname="_property", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostStorageOperationalInfo_Def.__bases__:
                bases = list(ns0.HostStorageOperationalInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostStorageOperationalInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostStorageOperationalInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostStorageOperationalInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostStorageOperationalInfo_Def.schema
            TClist = [GTD("urn:vim25","HostStorageOperationalInfo",lazy=True)(pname=(ns,"HostStorageOperationalInfo"), aname="_HostStorageOperationalInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostStorageOperationalInfo = []
                    return
            Holder.__name__ = "ArrayOfHostStorageOperationalInfo_Holder"
            self.pyclass = Holder

    class HostStorageElementInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostStorageElementInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostStorageElementInfo_Def.schema
            TClist = [GTD("urn:vim25","HostStorageOperationalInfo",lazy=True)(pname=(ns,"operationalInfo"), aname="_operationalInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostHardwareElementInfo_Def not in ns0.HostStorageElementInfo_Def.__bases__:
                bases = list(ns0.HostStorageElementInfo_Def.__bases__)
                bases.insert(0, ns0.HostHardwareElementInfo_Def)
                ns0.HostStorageElementInfo_Def.__bases__ = tuple(bases)

            ns0.HostHardwareElementInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostStorageElementInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostStorageElementInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostStorageElementInfo_Def.schema
            TClist = [GTD("urn:vim25","HostStorageElementInfo",lazy=True)(pname=(ns,"HostStorageElementInfo"), aname="_HostStorageElementInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostStorageElementInfo = []
                    return
            Holder.__name__ = "ArrayOfHostStorageElementInfo_Holder"
            self.pyclass = Holder

    class HostHardwareStatusInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostHardwareStatusInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostHardwareStatusInfo_Def.schema
            TClist = [GTD("urn:vim25","HostHardwareElementInfo",lazy=True)(pname=(ns,"memoryStatusInfo"), aname="_memoryStatusInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostHardwareElementInfo",lazy=True)(pname=(ns,"cpuStatusInfo"), aname="_cpuStatusInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostStorageElementInfo",lazy=True)(pname=(ns,"storageStatusInfo"), aname="_storageStatusInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostHardwareStatusInfo_Def.__bases__:
                bases = list(ns0.HostHardwareStatusInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostHardwareStatusInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HealthSystemRuntime_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HealthSystemRuntime")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HealthSystemRuntime_Def.schema
            TClist = [GTD("urn:vim25","HostSystemHealthInfo",lazy=True)(pname=(ns,"systemHealthInfo"), aname="_systemHealthInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostHardwareStatusInfo",lazy=True)(pname=(ns,"hardwareStatusInfo"), aname="_hardwareStatusInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HealthSystemRuntime_Def.__bases__:
                bases = list(ns0.HealthSystemRuntime_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HealthSystemRuntime_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RefreshHealthStatusSystemRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshHealthStatusSystemRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshHealthStatusSystemRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshHealthStatusSystemRequestType_Holder"
            self.pyclass = Holder

    class ResetSystemHealthInfoRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetSystemHealthInfoRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetSystemHealthInfoRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "ResetSystemHealthInfoRequestType_Holder"
            self.pyclass = Holder

    class HostHostBusAdapter_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostHostBusAdapter")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostHostBusAdapter_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"bus"), aname="_bus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"status"), aname="_status", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"model"), aname="_model", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"driver"), aname="_driver", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pci"), aname="_pci", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostHostBusAdapter_Def.__bases__:
                bases = list(ns0.HostHostBusAdapter_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostHostBusAdapter_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostHostBusAdapter_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostHostBusAdapter")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostHostBusAdapter_Def.schema
            TClist = [GTD("urn:vim25","HostHostBusAdapter",lazy=True)(pname=(ns,"HostHostBusAdapter"), aname="_HostHostBusAdapter", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostHostBusAdapter = []
                    return
            Holder.__name__ = "ArrayOfHostHostBusAdapter_Holder"
            self.pyclass = Holder

    class HostParallelScsiHba_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostParallelScsiHba")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostParallelScsiHba_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostHostBusAdapter_Def not in ns0.HostParallelScsiHba_Def.__bases__:
                bases = list(ns0.HostParallelScsiHba_Def.__bases__)
                bases.insert(0, ns0.HostHostBusAdapter_Def)
                ns0.HostParallelScsiHba_Def.__bases__ = tuple(bases)

            ns0.HostHostBusAdapter_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostBlockHba_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostBlockHba")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostBlockHba_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostHostBusAdapter_Def not in ns0.HostBlockHba_Def.__bases__:
                bases = list(ns0.HostBlockHba_Def.__bases__)
                bases.insert(0, ns0.HostHostBusAdapter_Def)
                ns0.HostBlockHba_Def.__bases__ = tuple(bases)

            ns0.HostHostBusAdapter_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FibreChannelPortType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FibreChannelPortType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostFibreChannelHba_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFibreChannelHba")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFibreChannelHba_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"portWorldWideName"), aname="_portWorldWideName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"nodeWorldWideName"), aname="_nodeWorldWideName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","FibreChannelPortType",lazy=True)(pname=(ns,"portType"), aname="_portType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"speed"), aname="_speed", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostHostBusAdapter_Def not in ns0.HostFibreChannelHba_Def.__bases__:
                bases = list(ns0.HostFibreChannelHba_Def.__bases__)
                bases.insert(0, ns0.HostHostBusAdapter_Def)
                ns0.HostFibreChannelHba_Def.__bases__ = tuple(bases)

            ns0.HostHostBusAdapter_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInternetScsiHbaDiscoveryCapabilities_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaDiscoveryCapabilities")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaDiscoveryCapabilities_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"iSnsDiscoverySettable"), aname="_iSnsDiscoverySettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"slpDiscoverySettable"), aname="_slpDiscoverySettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"staticTargetDiscoverySettable"), aname="_staticTargetDiscoverySettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sendTargetsDiscoverySettable"), aname="_sendTargetsDiscoverySettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaDiscoveryCapabilities_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaDiscoveryCapabilities_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaDiscoveryCapabilities_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class InternetScsiSnsDiscoveryMethod_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "InternetScsiSnsDiscoveryMethod")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class SlpDiscoveryMethod_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SlpDiscoveryMethod")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostInternetScsiHbaDiscoveryProperties_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaDiscoveryProperties")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaDiscoveryProperties_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"iSnsDiscoveryEnabled"), aname="_iSnsDiscoveryEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iSnsDiscoveryMethod"), aname="_iSnsDiscoveryMethod", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iSnsHost"), aname="_iSnsHost", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"slpDiscoveryEnabled"), aname="_slpDiscoveryEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"slpDiscoveryMethod"), aname="_slpDiscoveryMethod", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"slpHost"), aname="_slpHost", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"staticTargetDiscoveryEnabled"), aname="_staticTargetDiscoveryEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sendTargetsDiscoveryEnabled"), aname="_sendTargetsDiscoveryEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaDiscoveryProperties_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaDiscoveryProperties_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaDiscoveryProperties_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInternetScsiHbaAuthenticationCapabilities_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaAuthenticationCapabilities")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaAuthenticationCapabilities_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"chapAuthSettable"), aname="_chapAuthSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"krb5AuthSettable"), aname="_krb5AuthSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"srpAuthSettable"), aname="_srpAuthSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"spkmAuthSettable"), aname="_spkmAuthSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaAuthenticationCapabilities_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaAuthenticationCapabilities_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaAuthenticationCapabilities_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInternetScsiHbaAuthenticationProperties_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaAuthenticationProperties")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaAuthenticationProperties_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"chapAuthEnabled"), aname="_chapAuthEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"chapName"), aname="_chapName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"chapSecret"), aname="_chapSecret", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaAuthenticationProperties_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaAuthenticationProperties_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaAuthenticationProperties_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInternetScsiHbaIPCapabilities_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaIPCapabilities")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaIPCapabilities_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"addressSettable"), aname="_addressSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"ipConfigurationMethodSettable"), aname="_ipConfigurationMethodSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"subnetMaskSettable"), aname="_subnetMaskSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"defaultGatewaySettable"), aname="_defaultGatewaySettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"primaryDnsServerAddressSettable"), aname="_primaryDnsServerAddressSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"alternateDnsServerAddressSettable"), aname="_alternateDnsServerAddressSettable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaIPCapabilities_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaIPCapabilities_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaIPCapabilities_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInternetScsiHbaIPProperties_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaIPProperties")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaIPProperties_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"mac"), aname="_mac", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"address"), aname="_address", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"dhcpConfigurationEnabled"), aname="_dhcpConfigurationEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"subnetMask"), aname="_subnetMask", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"defaultGateway"), aname="_defaultGateway", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"primaryDnsServerAddress"), aname="_primaryDnsServerAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"alternateDnsServerAddress"), aname="_alternateDnsServerAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaIPProperties_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaIPProperties_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaIPProperties_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInternetScsiHbaSendTarget_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaSendTarget")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaSendTarget_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"address"), aname="_address", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaSendTarget_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaSendTarget_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaSendTarget_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostInternetScsiHbaSendTarget_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostInternetScsiHbaSendTarget")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostInternetScsiHbaSendTarget_Def.schema
            TClist = [GTD("urn:vim25","HostInternetScsiHbaSendTarget",lazy=True)(pname=(ns,"HostInternetScsiHbaSendTarget"), aname="_HostInternetScsiHbaSendTarget", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostInternetScsiHbaSendTarget = []
                    return
            Holder.__name__ = "ArrayOfHostInternetScsiHbaSendTarget_Holder"
            self.pyclass = Holder

    class HostInternetScsiHbaStaticTarget_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHbaStaticTarget")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHbaStaticTarget_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"address"), aname="_address", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiName"), aname="_iScsiName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostInternetScsiHbaStaticTarget_Def.__bases__:
                bases = list(ns0.HostInternetScsiHbaStaticTarget_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostInternetScsiHbaStaticTarget_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostInternetScsiHbaStaticTarget_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostInternetScsiHbaStaticTarget")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostInternetScsiHbaStaticTarget_Def.schema
            TClist = [GTD("urn:vim25","HostInternetScsiHbaStaticTarget",lazy=True)(pname=(ns,"HostInternetScsiHbaStaticTarget"), aname="_HostInternetScsiHbaStaticTarget", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostInternetScsiHbaStaticTarget = []
                    return
            Holder.__name__ = "ArrayOfHostInternetScsiHbaStaticTarget_Holder"
            self.pyclass = Holder

    class HostInternetScsiHba_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiHba")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiHba_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"isSoftwareBased"), aname="_isSoftwareBased", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaDiscoveryCapabilities",lazy=True)(pname=(ns,"discoveryCapabilities"), aname="_discoveryCapabilities", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaDiscoveryProperties",lazy=True)(pname=(ns,"discoveryProperties"), aname="_discoveryProperties", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaAuthenticationCapabilities",lazy=True)(pname=(ns,"authenticationCapabilities"), aname="_authenticationCapabilities", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaAuthenticationProperties",lazy=True)(pname=(ns,"authenticationProperties"), aname="_authenticationProperties", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaIPCapabilities",lazy=True)(pname=(ns,"ipCapabilities"), aname="_ipCapabilities", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaIPProperties",lazy=True)(pname=(ns,"ipProperties"), aname="_ipProperties", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiName"), aname="_iScsiName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiAlias"), aname="_iScsiAlias", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaSendTarget",lazy=True)(pname=(ns,"configuredSendTarget"), aname="_configuredSendTarget", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaStaticTarget",lazy=True)(pname=(ns,"configuredStaticTarget"), aname="_configuredStaticTarget", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxSpeedMb"), aname="_maxSpeedMb", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"currentSpeedMb"), aname="_currentSpeedMb", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostHostBusAdapter_Def not in ns0.HostInternetScsiHba_Def.__bases__:
                bases = list(ns0.HostInternetScsiHba_Def.__bases__)
                bases.insert(0, ns0.HostHostBusAdapter_Def)
                ns0.HostInternetScsiHba_Def.__bases__ = tuple(bases)

            ns0.HostHostBusAdapter_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostIpConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostIpConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostIpConfig_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"dhcp"), aname="_dhcp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"subnetMask"), aname="_subnetMask", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostIpConfig_Def.__bases__:
                bases = list(ns0.HostIpConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostIpConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostIpRouteConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostIpRouteConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostIpRouteConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"defaultGateway"), aname="_defaultGateway", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"gatewayDevice"), aname="_gatewayDevice", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostIpRouteConfig_Def.__bases__:
                bases = list(ns0.HostIpRouteConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostIpRouteConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostAccountSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostAccountSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostAccountSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"password"), aname="_password", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostAccountSpec_Def.__bases__:
                bases = list(ns0.HostAccountSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostAccountSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostPosixAccountSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPosixAccountSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPosixAccountSpec_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"posixId"), aname="_posixId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"shellAccess"), aname="_shellAccess", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostAccountSpec_Def not in ns0.HostPosixAccountSpec_Def.__bases__:
                bases = list(ns0.HostPosixAccountSpec_Def.__bases__)
                bases.insert(0, ns0.HostAccountSpec_Def)
                ns0.HostPosixAccountSpec_Def.__bases__ = tuple(bases)

            ns0.HostAccountSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CreateUserRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateUserRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateUserRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostAccountSpec",lazy=True)(pname=(ns,"user"), aname="_user", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._user = None
                    return
            Holder.__name__ = "CreateUserRequestType_Holder"
            self.pyclass = Holder

    class UpdateUserRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateUserRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateUserRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostAccountSpec",lazy=True)(pname=(ns,"user"), aname="_user", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._user = None
                    return
            Holder.__name__ = "UpdateUserRequestType_Holder"
            self.pyclass = Holder

    class CreateGroupRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateGroupRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateGroupRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostAccountSpec",lazy=True)(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._group = None
                    return
            Holder.__name__ = "CreateGroupRequestType_Holder"
            self.pyclass = Holder

    class RemoveUserRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveUserRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveUserRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"userName"), aname="_userName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._userName = None
                    return
            Holder.__name__ = "RemoveUserRequestType_Holder"
            self.pyclass = Holder

    class RemoveGroupRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveGroupRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveGroupRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"groupName"), aname="_groupName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._groupName = None
                    return
            Holder.__name__ = "RemoveGroupRequestType_Holder"
            self.pyclass = Holder

    class AssignUserToGroupRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AssignUserToGroupRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AssignUserToGroupRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"user"), aname="_user", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._user = None
                    self._group = None
                    return
            Holder.__name__ = "AssignUserToGroupRequestType_Holder"
            self.pyclass = Holder

    class UnassignUserFromGroupRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UnassignUserFromGroupRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UnassignUserFromGroupRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"user"), aname="_user", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"group"), aname="_group", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._user = None
                    self._group = None
                    return
            Holder.__name__ = "UnassignUserFromGroupRequestType_Holder"
            self.pyclass = Holder

    class ServiceConsoleReservationInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ServiceConsoleReservationInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ServiceConsoleReservationInfo_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"serviceConsoleReservedCfg"), aname="_serviceConsoleReservedCfg", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"serviceConsoleReserved"), aname="_serviceConsoleReserved", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"unreserved"), aname="_unreserved", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ServiceConsoleReservationInfo_Def.__bases__:
                bases = list(ns0.ServiceConsoleReservationInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ServiceConsoleReservationInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineMemoryAllocationPolicy_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineMemoryAllocationPolicy")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineMemoryReservationInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineMemoryReservationInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineMemoryReservationInfo_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"virtualMachineMin"), aname="_virtualMachineMin", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"virtualMachineMax"), aname="_virtualMachineMax", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"virtualMachineReserved"), aname="_virtualMachineReserved", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"allocationPolicy"), aname="_allocationPolicy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineMemoryReservationInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineMemoryReservationInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineMemoryReservationInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineMemoryReservationSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineMemoryReservationSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineMemoryReservationSpec_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"virtualMachineReserved"), aname="_virtualMachineReserved", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"allocationPolicy"), aname="_allocationPolicy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineMemoryReservationSpec_Def.__bases__:
                bases = list(ns0.VirtualMachineMemoryReservationSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineMemoryReservationSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReconfigureServiceConsoleReservationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureServiceConsoleReservationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureServiceConsoleReservationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"cfgBytes"), aname="_cfgBytes", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._cfgBytes = None
                    return
            Holder.__name__ = "ReconfigureServiceConsoleReservationRequestType_Holder"
            self.pyclass = Holder

    class ReconfigureVirtualMachineReservationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureVirtualMachineReservationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureVirtualMachineReservationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineMemoryReservationSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "ReconfigureVirtualMachineReservationRequestType_Holder"
            self.pyclass = Holder

    class HostMountMode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostMountMode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostMountInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostMountInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostMountInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"path"), aname="_path", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"accessMode"), aname="_accessMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"accessible"), aname="_accessible", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostMountInfo_Def.__bases__:
                bases = list(ns0.HostMountInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostMountInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MultipathState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "MultipathState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostMultipathInfoLogicalUnitPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostMultipathInfoLogicalUnitPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostMultipathInfoLogicalUnitPolicy_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"policy"), aname="_policy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostMultipathInfoLogicalUnitPolicy_Def.__bases__:
                bases = list(ns0.HostMultipathInfoLogicalUnitPolicy_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostMultipathInfoLogicalUnitPolicy_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostMultipathInfoFixedLogicalUnitPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostMultipathInfoFixedLogicalUnitPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostMultipathInfoFixedLogicalUnitPolicy_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"prefer"), aname="_prefer", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostMultipathInfoLogicalUnitPolicy_Def not in ns0.HostMultipathInfoFixedLogicalUnitPolicy_Def.__bases__:
                bases = list(ns0.HostMultipathInfoFixedLogicalUnitPolicy_Def.__bases__)
                bases.insert(0, ns0.HostMultipathInfoLogicalUnitPolicy_Def)
                ns0.HostMultipathInfoFixedLogicalUnitPolicy_Def.__bases__ = tuple(bases)

            ns0.HostMultipathInfoLogicalUnitPolicy_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostMultipathInfoLogicalUnit_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostMultipathInfoLogicalUnit")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostMultipathInfoLogicalUnit_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"lun"), aname="_lun", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostMultipathInfoPath",lazy=True)(pname=(ns,"path"), aname="_path", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostMultipathInfoLogicalUnitPolicy",lazy=True)(pname=(ns,"policy"), aname="_policy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostMultipathInfoLogicalUnit_Def.__bases__:
                bases = list(ns0.HostMultipathInfoLogicalUnit_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostMultipathInfoLogicalUnit_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostMultipathInfoLogicalUnit_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostMultipathInfoLogicalUnit")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostMultipathInfoLogicalUnit_Def.schema
            TClist = [GTD("urn:vim25","HostMultipathInfoLogicalUnit",lazy=True)(pname=(ns,"HostMultipathInfoLogicalUnit"), aname="_HostMultipathInfoLogicalUnit", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostMultipathInfoLogicalUnit = []
                    return
            Holder.__name__ = "ArrayOfHostMultipathInfoLogicalUnit_Holder"
            self.pyclass = Holder

    class HostMultipathInfoPath_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostMultipathInfoPath")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostMultipathInfoPath_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pathState"), aname="_pathState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"adapter"), aname="_adapter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"lun"), aname="_lun", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostTargetTransport",lazy=True)(pname=(ns,"transport"), aname="_transport", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostMultipathInfoPath_Def.__bases__:
                bases = list(ns0.HostMultipathInfoPath_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostMultipathInfoPath_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostMultipathInfoPath_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostMultipathInfoPath")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostMultipathInfoPath_Def.schema
            TClist = [GTD("urn:vim25","HostMultipathInfoPath",lazy=True)(pname=(ns,"HostMultipathInfoPath"), aname="_HostMultipathInfoPath", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostMultipathInfoPath = []
                    return
            Holder.__name__ = "ArrayOfHostMultipathInfoPath_Holder"
            self.pyclass = Holder

    class HostMultipathInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostMultipathInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostMultipathInfo_Def.schema
            TClist = [GTD("urn:vim25","HostMultipathInfoLogicalUnit",lazy=True)(pname=(ns,"lun"), aname="_lun", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostMultipathInfo_Def.__bases__:
                bases = list(ns0.HostMultipathInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostMultipathInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNatServicePortForwardSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNatServicePortForwardSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNatServicePortForwardSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"hostPort"), aname="_hostPort", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"guestPort"), aname="_guestPort", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestIpAddress"), aname="_guestIpAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNatServicePortForwardSpec_Def.__bases__:
                bases = list(ns0.HostNatServicePortForwardSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNatServicePortForwardSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostNatServicePortForwardSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostNatServicePortForwardSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostNatServicePortForwardSpec_Def.schema
            TClist = [GTD("urn:vim25","HostNatServicePortForwardSpec",lazy=True)(pname=(ns,"HostNatServicePortForwardSpec"), aname="_HostNatServicePortForwardSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostNatServicePortForwardSpec = []
                    return
            Holder.__name__ = "ArrayOfHostNatServicePortForwardSpec_Holder"
            self.pyclass = Holder

    class HostNatServiceNameServiceSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNatServiceNameServiceSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNatServiceNameServiceSpec_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"dnsAutoDetect"), aname="_dnsAutoDetect", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"dnsPolicy"), aname="_dnsPolicy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"dnsRetries"), aname="_dnsRetries", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"dnsTimeout"), aname="_dnsTimeout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"dnsNameServer"), aname="_dnsNameServer", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"nbdsTimeout"), aname="_nbdsTimeout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"nbnsRetries"), aname="_nbnsRetries", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"nbnsTimeout"), aname="_nbnsTimeout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNatServiceNameServiceSpec_Def.__bases__:
                bases = list(ns0.HostNatServiceNameServiceSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNatServiceNameServiceSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNatServiceSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNatServiceSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNatServiceSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"virtualSwitch"), aname="_virtualSwitch", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"activeFtp"), aname="_activeFtp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"allowAnyOui"), aname="_allowAnyOui", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"configPort"), aname="_configPort", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipGatewayAddress"), aname="_ipGatewayAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"udpTimeout"), aname="_udpTimeout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNatServicePortForwardSpec",lazy=True)(pname=(ns,"portForward"), aname="_portForward", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNatServiceNameServiceSpec",lazy=True)(pname=(ns,"nameService"), aname="_nameService", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNatServiceSpec_Def.__bases__:
                bases = list(ns0.HostNatServiceSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNatServiceSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNatServiceConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNatServiceConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNatServiceConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"changeOperation"), aname="_changeOperation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNatServiceSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNatServiceConfig_Def.__bases__:
                bases = list(ns0.HostNatServiceConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNatServiceConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostNatServiceConfig_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostNatServiceConfig")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostNatServiceConfig_Def.schema
            TClist = [GTD("urn:vim25","HostNatServiceConfig",lazy=True)(pname=(ns,"HostNatServiceConfig"), aname="_HostNatServiceConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostNatServiceConfig = []
                    return
            Holder.__name__ = "ArrayOfHostNatServiceConfig_Holder"
            self.pyclass = Holder

    class HostNatService_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNatService")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNatService_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNatServiceSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNatService_Def.__bases__:
                bases = list(ns0.HostNatService_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNatService_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostNatService_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostNatService")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostNatService_Def.schema
            TClist = [GTD("urn:vim25","HostNatService",lazy=True)(pname=(ns,"HostNatService"), aname="_HostNatService", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostNatService = []
                    return
            Holder.__name__ = "ArrayOfHostNatService_Holder"
            self.pyclass = Holder

    class HostNetCapabilities_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetCapabilities")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetCapabilities_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"canSetPhysicalNicLinkSpeed"), aname="_canSetPhysicalNicLinkSpeed", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"supportsNicTeaming"), aname="_supportsNicTeaming", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"nicTeamingPolicy"), aname="_nicTeamingPolicy", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"supportsVlan"), aname="_supportsVlan", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"usesServiceConsoleNic"), aname="_usesServiceConsoleNic", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"supportsNetworkHints"), aname="_supportsNetworkHints", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxPortGroupsPerVswitch"), aname="_maxPortGroupsPerVswitch", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vswitchConfigSupported"), aname="_vswitchConfigSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vnicConfigSupported"), aname="_vnicConfigSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"ipRouteConfigSupported"), aname="_ipRouteConfigSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"dnsConfigSupported"), aname="_dnsConfigSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"dhcpOnVnicSupported"), aname="_dhcpOnVnicSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetCapabilities_Def.__bases__:
                bases = list(ns0.HostNetCapabilities_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetCapabilities_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNetOffloadCapabilities_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetOffloadCapabilities")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetOffloadCapabilities_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"csumOffload"), aname="_csumOffload", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"tcpSegmentation"), aname="_tcpSegmentation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"zeroCopyXmit"), aname="_zeroCopyXmit", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetOffloadCapabilities_Def.__bases__:
                bases = list(ns0.HostNetOffloadCapabilities_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetOffloadCapabilities_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNetworkConfigResult_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetworkConfigResult")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetworkConfigResult_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"vnicDevice"), aname="_vnicDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"consoleVnicDevice"), aname="_consoleVnicDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetworkConfigResult_Def.__bases__:
                bases = list(ns0.HostNetworkConfigResult_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetworkConfigResult_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNetworkConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetworkConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetworkConfig_Def.schema
            TClist = [GTD("urn:vim25","HostVirtualSwitchConfig",lazy=True)(pname=(ns,"vswitch"), aname="_vswitch", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPortGroupConfig",lazy=True)(pname=(ns,"portgroup"), aname="_portgroup", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicConfig",lazy=True)(pname=(ns,"pnic"), aname="_pnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicConfig",lazy=True)(pname=(ns,"vnic"), aname="_vnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicConfig",lazy=True)(pname=(ns,"consoleVnic"), aname="_consoleVnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDnsConfig",lazy=True)(pname=(ns,"dnsConfig"), aname="_dnsConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpRouteConfig",lazy=True)(pname=(ns,"ipRouteConfig"), aname="_ipRouteConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpRouteConfig",lazy=True)(pname=(ns,"consoleIpRouteConfig"), aname="_consoleIpRouteConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDhcpServiceConfig",lazy=True)(pname=(ns,"dhcp"), aname="_dhcp", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNatServiceConfig",lazy=True)(pname=(ns,"nat"), aname="_nat", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetworkConfig_Def.__bases__:
                bases = list(ns0.HostNetworkConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetworkConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNetworkInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetworkInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetworkInfo_Def.schema
            TClist = [GTD("urn:vim25","HostVirtualSwitch",lazy=True)(pname=(ns,"vswitch"), aname="_vswitch", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPortGroup",lazy=True)(pname=(ns,"portgroup"), aname="_portgroup", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNic",lazy=True)(pname=(ns,"pnic"), aname="_pnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNic",lazy=True)(pname=(ns,"vnic"), aname="_vnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNic",lazy=True)(pname=(ns,"consoleVnic"), aname="_consoleVnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDnsConfig",lazy=True)(pname=(ns,"dnsConfig"), aname="_dnsConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpRouteConfig",lazy=True)(pname=(ns,"ipRouteConfig"), aname="_ipRouteConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpRouteConfig",lazy=True)(pname=(ns,"consoleIpRouteConfig"), aname="_consoleIpRouteConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDhcpService",lazy=True)(pname=(ns,"dhcp"), aname="_dhcp", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNatService",lazy=True)(pname=(ns,"nat"), aname="_nat", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetworkInfo_Def.__bases__:
                bases = list(ns0.HostNetworkInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetworkInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNetworkSecurityPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetworkSecurityPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetworkSecurityPolicy_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"allowPromiscuous"), aname="_allowPromiscuous", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"macChanges"), aname="_macChanges", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"forgedTransmits"), aname="_forgedTransmits", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetworkSecurityPolicy_Def.__bases__:
                bases = list(ns0.HostNetworkSecurityPolicy_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetworkSecurityPolicy_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNetworkTrafficShapingPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetworkTrafficShapingPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetworkTrafficShapingPolicy_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"averageBandwidth"), aname="_averageBandwidth", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"peakBandwidth"), aname="_peakBandwidth", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"burstSize"), aname="_burstSize", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetworkTrafficShapingPolicy_Def.__bases__:
                bases = list(ns0.HostNetworkTrafficShapingPolicy_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetworkTrafficShapingPolicy_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNicFailureCriteria_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNicFailureCriteria")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNicFailureCriteria_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"checkSpeed"), aname="_checkSpeed", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"speed"), aname="_speed", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"checkDuplex"), aname="_checkDuplex", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"fullDuplex"), aname="_fullDuplex", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"checkErrorPercent"), aname="_checkErrorPercent", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"percentage"), aname="_percentage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"checkBeacon"), aname="_checkBeacon", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNicFailureCriteria_Def.__bases__:
                bases = list(ns0.HostNicFailureCriteria_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNicFailureCriteria_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNicOrderPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNicOrderPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNicOrderPolicy_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"activeNic"), aname="_activeNic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"standbyNic"), aname="_standbyNic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNicOrderPolicy_Def.__bases__:
                bases = list(ns0.HostNicOrderPolicy_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNicOrderPolicy_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNicTeamingPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNicTeamingPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNicTeamingPolicy_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"policy"), aname="_policy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"reversePolicy"), aname="_reversePolicy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"notifySwitches"), aname="_notifySwitches", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"rollingOrder"), aname="_rollingOrder", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNicFailureCriteria",lazy=True)(pname=(ns,"failureCriteria"), aname="_failureCriteria", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNicOrderPolicy",lazy=True)(pname=(ns,"nicOrder"), aname="_nicOrder", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNicTeamingPolicy_Def.__bases__:
                bases = list(ns0.HostNicTeamingPolicy_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNicTeamingPolicy_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNetworkPolicy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNetworkPolicy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNetworkPolicy_Def.schema
            TClist = [GTD("urn:vim25","HostNetworkSecurityPolicy",lazy=True)(pname=(ns,"security"), aname="_security", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNicTeamingPolicy",lazy=True)(pname=(ns,"nicTeaming"), aname="_nicTeaming", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetOffloadCapabilities",lazy=True)(pname=(ns,"offloadPolicy"), aname="_offloadPolicy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetworkTrafficShapingPolicy",lazy=True)(pname=(ns,"shapingPolicy"), aname="_shapingPolicy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNetworkPolicy_Def.__bases__:
                bases = list(ns0.HostNetworkPolicy_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNetworkPolicy_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdateNetworkConfigRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateNetworkConfigRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateNetworkConfigRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetworkConfig",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"changeMode"), aname="_changeMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._config = None
                    self._changeMode = None
                    return
            Holder.__name__ = "UpdateNetworkConfigRequestType_Holder"
            self.pyclass = Holder

    class UpdateDnsConfigRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateDnsConfigRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateDnsConfigRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDnsConfig",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._config = None
                    return
            Holder.__name__ = "UpdateDnsConfigRequestType_Holder"
            self.pyclass = Holder

    class UpdateIpRouteConfigRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateIpRouteConfigRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateIpRouteConfigRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpRouteConfig",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._config = None
                    return
            Holder.__name__ = "UpdateIpRouteConfigRequestType_Holder"
            self.pyclass = Holder

    class UpdateConsoleIpRouteConfigRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateConsoleIpRouteConfigRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateConsoleIpRouteConfigRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpRouteConfig",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._config = None
                    return
            Holder.__name__ = "UpdateConsoleIpRouteConfigRequestType_Holder"
            self.pyclass = Holder

    class AddVirtualSwitchRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddVirtualSwitchRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddVirtualSwitchRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vswitchName"), aname="_vswitchName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualSwitchSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vswitchName = None
                    self._spec = None
                    return
            Holder.__name__ = "AddVirtualSwitchRequestType_Holder"
            self.pyclass = Holder

    class RemoveVirtualSwitchRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveVirtualSwitchRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveVirtualSwitchRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vswitchName"), aname="_vswitchName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vswitchName = None
                    return
            Holder.__name__ = "RemoveVirtualSwitchRequestType_Holder"
            self.pyclass = Holder

    class UpdateVirtualSwitchRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateVirtualSwitchRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateVirtualSwitchRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vswitchName"), aname="_vswitchName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualSwitchSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vswitchName = None
                    self._spec = None
                    return
            Holder.__name__ = "UpdateVirtualSwitchRequestType_Holder"
            self.pyclass = Holder

    class AddPortGroupRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddPortGroupRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddPortGroupRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPortGroupSpec",lazy=True)(pname=(ns,"portgrp"), aname="_portgrp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._portgrp = None
                    return
            Holder.__name__ = "AddPortGroupRequestType_Holder"
            self.pyclass = Holder

    class RemovePortGroupRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemovePortGroupRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemovePortGroupRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pgName"), aname="_pgName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._pgName = None
                    return
            Holder.__name__ = "RemovePortGroupRequestType_Holder"
            self.pyclass = Holder

    class UpdatePortGroupRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdatePortGroupRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdatePortGroupRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pgName"), aname="_pgName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPortGroupSpec",lazy=True)(pname=(ns,"portgrp"), aname="_portgrp", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._pgName = None
                    self._portgrp = None
                    return
            Holder.__name__ = "UpdatePortGroupRequestType_Holder"
            self.pyclass = Holder

    class UpdatePhysicalNicLinkSpeedRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdatePhysicalNicLinkSpeedRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdatePhysicalNicLinkSpeedRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicLinkInfo",lazy=True)(pname=(ns,"linkSpeed"), aname="_linkSpeed", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = None
                    self._linkSpeed = None
                    return
            Holder.__name__ = "UpdatePhysicalNicLinkSpeedRequestType_Holder"
            self.pyclass = Holder

    class QueryNetworkHintRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryNetworkHintRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryNetworkHintRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = []
                    return
            Holder.__name__ = "QueryNetworkHintRequestType_Holder"
            self.pyclass = Holder

    class AddVirtualNicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddVirtualNicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddVirtualNicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"portgroup"), aname="_portgroup", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicSpec",lazy=True)(pname=(ns,"nic"), aname="_nic", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._portgroup = None
                    self._nic = None
                    return
            Holder.__name__ = "AddVirtualNicRequestType_Holder"
            self.pyclass = Holder

    class RemoveVirtualNicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveVirtualNicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveVirtualNicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = None
                    return
            Holder.__name__ = "RemoveVirtualNicRequestType_Holder"
            self.pyclass = Holder

    class UpdateVirtualNicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateVirtualNicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateVirtualNicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicSpec",lazy=True)(pname=(ns,"nic"), aname="_nic", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = None
                    self._nic = None
                    return
            Holder.__name__ = "UpdateVirtualNicRequestType_Holder"
            self.pyclass = Holder

    class AddServiceConsoleVirtualNicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddServiceConsoleVirtualNicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddServiceConsoleVirtualNicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"portgroup"), aname="_portgroup", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicSpec",lazy=True)(pname=(ns,"nic"), aname="_nic", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._portgroup = None
                    self._nic = None
                    return
            Holder.__name__ = "AddServiceConsoleVirtualNicRequestType_Holder"
            self.pyclass = Holder

    class RemoveServiceConsoleVirtualNicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveServiceConsoleVirtualNicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveServiceConsoleVirtualNicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = None
                    return
            Holder.__name__ = "RemoveServiceConsoleVirtualNicRequestType_Holder"
            self.pyclass = Holder

    class UpdateServiceConsoleVirtualNicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateServiceConsoleVirtualNicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateServiceConsoleVirtualNicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicSpec",lazy=True)(pname=(ns,"nic"), aname="_nic", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = None
                    self._nic = None
                    return
            Holder.__name__ = "UpdateServiceConsoleVirtualNicRequestType_Holder"
            self.pyclass = Holder

    class RestartServiceConsoleVirtualNicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RestartServiceConsoleVirtualNicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RestartServiceConsoleVirtualNicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = None
                    return
            Holder.__name__ = "RestartServiceConsoleVirtualNicRequestType_Holder"
            self.pyclass = Holder

    class RefreshNetworkSystemRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshNetworkSystemRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshNetworkSystemRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshNetworkSystemRequestType_Holder"
            self.pyclass = Holder

    class HostNtpConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNtpConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNtpConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"server"), aname="_server", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNtpConfig_Def.__bases__:
                bases = list(ns0.HostNtpConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNtpConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostNumericSensorHealthState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostNumericSensorHealthState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostNumericSensorType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostNumericSensorType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostNumericSensorInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostNumericSensorInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostNumericSensorInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"healthState"), aname="_healthState", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"currentReading"), aname="_currentReading", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"unitModifier"), aname="_unitModifier", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"baseUnits"), aname="_baseUnits", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"rateUnits"), aname="_rateUnits", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"sensorType"), aname="_sensorType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostNumericSensorInfo_Def.__bases__:
                bases = list(ns0.HostNumericSensorInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostNumericSensorInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostNumericSensorInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostNumericSensorInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostNumericSensorInfo_Def.schema
            TClist = [GTD("urn:vim25","HostNumericSensorInfo",lazy=True)(pname=(ns,"HostNumericSensorInfo"), aname="_HostNumericSensorInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostNumericSensorInfo = []
                    return
            Holder.__name__ = "ArrayOfHostNumericSensorInfo_Holder"
            self.pyclass = Holder

    class HostPatchManagerReason_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostPatchManagerReason")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostPatchManagerIntegrityStatus_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostPatchManagerIntegrityStatus")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostPatchManagerInstallState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostPatchManagerInstallState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostPatchManagerStatusPrerequisitePatch_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPatchManagerStatusPrerequisitePatch")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPatchManagerStatusPrerequisitePatch_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"installState"), aname="_installState", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPatchManagerStatusPrerequisitePatch_Def.__bases__:
                bases = list(ns0.HostPatchManagerStatusPrerequisitePatch_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPatchManagerStatusPrerequisitePatch_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostPatchManagerStatusPrerequisitePatch_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostPatchManagerStatusPrerequisitePatch")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostPatchManagerStatusPrerequisitePatch_Def.schema
            TClist = [GTD("urn:vim25","HostPatchManagerStatusPrerequisitePatch",lazy=True)(pname=(ns,"HostPatchManagerStatusPrerequisitePatch"), aname="_HostPatchManagerStatusPrerequisitePatch", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostPatchManagerStatusPrerequisitePatch = []
                    return
            Holder.__name__ = "ArrayOfHostPatchManagerStatusPrerequisitePatch_Holder"
            self.pyclass = Holder

    class HostPatchManagerStatus_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPatchManagerStatus")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPatchManagerStatus_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"applicable"), aname="_applicable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"reason"), aname="_reason", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"integrity"), aname="_integrity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"installed"), aname="_installed", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"installState"), aname="_installState", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPatchManagerStatusPrerequisitePatch",lazy=True)(pname=(ns,"prerequisitePatch"), aname="_prerequisitePatch", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"restartRequired"), aname="_restartRequired", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"reconnectRequired"), aname="_reconnectRequired", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmOffRequired"), aname="_vmOffRequired", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"supersededPatchIds"), aname="_supersededPatchIds", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPatchManagerStatus_Def.__bases__:
                bases = list(ns0.HostPatchManagerStatus_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPatchManagerStatus_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostPatchManagerStatus_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostPatchManagerStatus")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostPatchManagerStatus_Def.schema
            TClist = [GTD("urn:vim25","HostPatchManagerStatus",lazy=True)(pname=(ns,"HostPatchManagerStatus"), aname="_HostPatchManagerStatus", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostPatchManagerStatus = []
                    return
            Holder.__name__ = "ArrayOfHostPatchManagerStatus_Holder"
            self.pyclass = Holder

    class HostPatchManagerLocator_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPatchManagerLocator")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPatchManagerLocator_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"url"), aname="_url", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"proxy"), aname="_proxy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPatchManagerLocator_Def.__bases__:
                bases = list(ns0.HostPatchManagerLocator_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPatchManagerLocator_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScanHostPatchRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ScanHostPatchRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ScanHostPatchRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPatchManagerLocator",lazy=True)(pname=(ns,"repository"), aname="_repository", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"updateID"), aname="_updateID", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._repository = None
                    self._updateID = []
                    return
            Holder.__name__ = "ScanHostPatchRequestType_Holder"
            self.pyclass = Holder

    class InstallHostPatchRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "InstallHostPatchRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.InstallHostPatchRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPatchManagerLocator",lazy=True)(pname=(ns,"repository"), aname="_repository", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"updateID"), aname="_updateID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"force"), aname="_force", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._repository = None
                    self._updateID = None
                    self._force = None
                    return
            Holder.__name__ = "InstallHostPatchRequestType_Holder"
            self.pyclass = Holder

    class HostPciDevice_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPciDevice")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPciDevice_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"classId"), aname="_classId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"bus"), aname="_bus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"slot"), aname="_slot", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"function"), aname="_function", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"vendorId"), aname="_vendorId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"subVendorId"), aname="_subVendorId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vendorName"), aname="_vendorName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"deviceId"), aname="_deviceId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"subDeviceId"), aname="_subDeviceId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"deviceName"), aname="_deviceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPciDevice_Def.__bases__:
                bases = list(ns0.HostPciDevice_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPciDevice_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostPciDevice_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostPciDevice")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostPciDevice_Def.schema
            TClist = [GTD("urn:vim25","HostPciDevice",lazy=True)(pname=(ns,"HostPciDevice"), aname="_HostPciDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostPciDevice = []
                    return
            Holder.__name__ = "ArrayOfHostPciDevice_Holder"
            self.pyclass = Holder

    class PhysicalNicSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicSpec_Def.schema
            TClist = [GTD("urn:vim25","HostIpConfig",lazy=True)(pname=(ns,"ip"), aname="_ip", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicLinkInfo",lazy=True)(pname=(ns,"linkSpeed"), aname="_linkSpeed", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNicSpec_Def.__bases__:
                bases = list(ns0.PhysicalNicSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNicSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PhysicalNicConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNicConfig_Def.__bases__:
                bases = list(ns0.PhysicalNicConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNicConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPhysicalNicConfig_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPhysicalNicConfig")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPhysicalNicConfig_Def.schema
            TClist = [GTD("urn:vim25","PhysicalNicConfig",lazy=True)(pname=(ns,"PhysicalNicConfig"), aname="_PhysicalNicConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PhysicalNicConfig = []
                    return
            Holder.__name__ = "ArrayOfPhysicalNicConfig_Holder"
            self.pyclass = Holder

    class PhysicalNicLinkInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicLinkInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicLinkInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"speedMb"), aname="_speedMb", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"duplex"), aname="_duplex", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNicLinkInfo_Def.__bases__:
                bases = list(ns0.PhysicalNicLinkInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNicLinkInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPhysicalNicLinkInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPhysicalNicLinkInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPhysicalNicLinkInfo_Def.schema
            TClist = [GTD("urn:vim25","PhysicalNicLinkInfo",lazy=True)(pname=(ns,"PhysicalNicLinkInfo"), aname="_PhysicalNicLinkInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PhysicalNicLinkInfo = []
                    return
            Holder.__name__ = "ArrayOfPhysicalNicLinkInfo_Holder"
            self.pyclass = Holder

    class PhysicalNicHint_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicHint")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicHint_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"vlanId"), aname="_vlanId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNicHint_Def.__bases__:
                bases = list(ns0.PhysicalNicHint_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNicHint_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PhysicalNicIpHint_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicIpHint")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicIpHint_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ipSubnet"), aname="_ipSubnet", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PhysicalNicHint_Def not in ns0.PhysicalNicIpHint_Def.__bases__:
                bases = list(ns0.PhysicalNicIpHint_Def.__bases__)
                bases.insert(0, ns0.PhysicalNicHint_Def)
                ns0.PhysicalNicIpHint_Def.__bases__ = tuple(bases)

            ns0.PhysicalNicHint_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPhysicalNicIpHint_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPhysicalNicIpHint")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPhysicalNicIpHint_Def.schema
            TClist = [GTD("urn:vim25","PhysicalNicIpHint",lazy=True)(pname=(ns,"PhysicalNicIpHint"), aname="_PhysicalNicIpHint", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PhysicalNicIpHint = []
                    return
            Holder.__name__ = "ArrayOfPhysicalNicIpHint_Holder"
            self.pyclass = Holder

    class PhysicalNicNameHint_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicNameHint")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicNameHint_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"network"), aname="_network", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.PhysicalNicHint_Def not in ns0.PhysicalNicNameHint_Def.__bases__:
                bases = list(ns0.PhysicalNicNameHint_Def.__bases__)
                bases.insert(0, ns0.PhysicalNicHint_Def)
                ns0.PhysicalNicNameHint_Def.__bases__ = tuple(bases)

            ns0.PhysicalNicHint_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPhysicalNicNameHint_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPhysicalNicNameHint")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPhysicalNicNameHint_Def.schema
            TClist = [GTD("urn:vim25","PhysicalNicNameHint",lazy=True)(pname=(ns,"PhysicalNicNameHint"), aname="_PhysicalNicNameHint", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PhysicalNicNameHint = []
                    return
            Holder.__name__ = "ArrayOfPhysicalNicNameHint_Holder"
            self.pyclass = Holder

    class PhysicalNicHintInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicHintInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicHintInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicIpHint",lazy=True)(pname=(ns,"subnet"), aname="_subnet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicNameHint",lazy=True)(pname=(ns,"network"), aname="_network", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicCdpInfo",lazy=True)(pname=(ns,"connectedSwitchPort"), aname="_connectedSwitchPort", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNicHintInfo_Def.__bases__:
                bases = list(ns0.PhysicalNicHintInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNicHintInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPhysicalNicHintInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPhysicalNicHintInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPhysicalNicHintInfo_Def.schema
            TClist = [GTD("urn:vim25","PhysicalNicHintInfo",lazy=True)(pname=(ns,"PhysicalNicHintInfo"), aname="_PhysicalNicHintInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PhysicalNicHintInfo = []
                    return
            Holder.__name__ = "ArrayOfPhysicalNicHintInfo_Holder"
            self.pyclass = Holder

    class PhysicalNicCdpDeviceCapability_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicCdpDeviceCapability")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicCdpDeviceCapability_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"router"), aname="_router", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"transparentBridge"), aname="_transparentBridge", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"sourceRouteBridge"), aname="_sourceRouteBridge", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"networkSwitch"), aname="_networkSwitch", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"host"), aname="_host", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"igmpEnabled"), aname="_igmpEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"repeater"), aname="_repeater", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNicCdpDeviceCapability_Def.__bases__:
                bases = list(ns0.PhysicalNicCdpDeviceCapability_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNicCdpDeviceCapability_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PhysicalNicCdpInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNicCdpInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNicCdpInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"cdpVersion"), aname="_cdpVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"timeout"), aname="_timeout", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"ttl"), aname="_ttl", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"samples"), aname="_samples", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"devId"), aname="_devId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"address"), aname="_address", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"portId"), aname="_portId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicCdpDeviceCapability",lazy=True)(pname=(ns,"deviceCapability"), aname="_deviceCapability", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"softwareVersion"), aname="_softwareVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"hardwarePlatform"), aname="_hardwarePlatform", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipPrefix"), aname="_ipPrefix", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"ipPrefixLen"), aname="_ipPrefixLen", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"vlan"), aname="_vlan", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"fullDuplex"), aname="_fullDuplex", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"mtu"), aname="_mtu", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"systemName"), aname="_systemName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"systemOID"), aname="_systemOID", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mgmtAddr"), aname="_mgmtAddr", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"location"), aname="_location", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNicCdpInfo_Def.__bases__:
                bases = list(ns0.PhysicalNicCdpInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNicCdpInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class PhysicalNic_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "PhysicalNic")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.PhysicalNic_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pci"), aname="_pci", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"driver"), aname="_driver", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicLinkInfo",lazy=True)(pname=(ns,"linkSpeed"), aname="_linkSpeed", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicLinkInfo",lazy=True)(pname=(ns,"validLinkSpecification"), aname="_validLinkSpecification", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","PhysicalNicSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"wakeOnLanSupported"), aname="_wakeOnLanSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mac"), aname="_mac", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.PhysicalNic_Def.__bases__:
                bases = list(ns0.PhysicalNic_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.PhysicalNic_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfPhysicalNic_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfPhysicalNic")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfPhysicalNic_Def.schema
            TClist = [GTD("urn:vim25","PhysicalNic",lazy=True)(pname=(ns,"PhysicalNic"), aname="_PhysicalNic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._PhysicalNic = []
                    return
            Holder.__name__ = "ArrayOfPhysicalNic_Holder"
            self.pyclass = Holder

    class PortGroupConnecteeType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "PortGroupConnecteeType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostPortGroupSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPortGroupSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPortGroupSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"vlanId"), aname="_vlanId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vswitchName"), aname="_vswitchName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetworkPolicy",lazy=True)(pname=(ns,"policy"), aname="_policy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPortGroupSpec_Def.__bases__:
                bases = list(ns0.HostPortGroupSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPortGroupSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostPortGroupConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPortGroupConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPortGroupConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"changeOperation"), aname="_changeOperation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPortGroupSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPortGroupConfig_Def.__bases__:
                bases = list(ns0.HostPortGroupConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPortGroupConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostPortGroupConfig_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostPortGroupConfig")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostPortGroupConfig_Def.schema
            TClist = [GTD("urn:vim25","HostPortGroupConfig",lazy=True)(pname=(ns,"HostPortGroupConfig"), aname="_HostPortGroupConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostPortGroupConfig = []
                    return
            Holder.__name__ = "ArrayOfHostPortGroupConfig_Holder"
            self.pyclass = Holder

    class HostPortGroupPort_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPortGroupPort")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPortGroupPort_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mac"), aname="_mac", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPortGroupPort_Def.__bases__:
                bases = list(ns0.HostPortGroupPort_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPortGroupPort_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostPortGroupPort_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostPortGroupPort")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostPortGroupPort_Def.schema
            TClist = [GTD("urn:vim25","HostPortGroupPort",lazy=True)(pname=(ns,"HostPortGroupPort"), aname="_HostPortGroupPort", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostPortGroupPort = []
                    return
            Holder.__name__ = "ArrayOfHostPortGroupPort_Holder"
            self.pyclass = Holder

    class HostPortGroup_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostPortGroup")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostPortGroup_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPortGroupPort",lazy=True)(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vswitch"), aname="_vswitch", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetworkPolicy",lazy=True)(pname=(ns,"computedPolicy"), aname="_computedPolicy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostPortGroupSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostPortGroup_Def.__bases__:
                bases = list(ns0.HostPortGroup_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostPortGroup_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostPortGroup_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostPortGroup")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostPortGroup_Def.schema
            TClist = [GTD("urn:vim25","HostPortGroup",lazy=True)(pname=(ns,"HostPortGroup"), aname="_HostPortGroup", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostPortGroup = []
                    return
            Holder.__name__ = "ArrayOfHostPortGroup_Holder"
            self.pyclass = Holder

    class HostFirewallRuleDirection_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostFirewallRuleDirection")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostFirewallRuleProtocol_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostFirewallRuleProtocol")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostFirewallRule_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFirewallRule")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFirewallRule_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"endPort"), aname="_endPort", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFirewallRuleDirection",lazy=True)(pname=(ns,"direction"), aname="_direction", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"protocol"), aname="_protocol", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFirewallRule_Def.__bases__:
                bases = list(ns0.HostFirewallRule_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFirewallRule_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostFirewallRule_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostFirewallRule")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostFirewallRule_Def.schema
            TClist = [GTD("urn:vim25","HostFirewallRule",lazy=True)(pname=(ns,"HostFirewallRule"), aname="_HostFirewallRule", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostFirewallRule = []
                    return
            Holder.__name__ = "ArrayOfHostFirewallRule_Holder"
            self.pyclass = Holder

    class HostFirewallRuleset_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFirewallRuleset")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFirewallRuleset_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"label"), aname="_label", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"required"), aname="_required", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostFirewallRule",lazy=True)(pname=(ns,"rule"), aname="_rule", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"service"), aname="_service", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostFirewallRuleset_Def.__bases__:
                bases = list(ns0.HostFirewallRuleset_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostFirewallRuleset_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostFirewallRuleset_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostFirewallRuleset")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostFirewallRuleset_Def.schema
            TClist = [GTD("urn:vim25","HostFirewallRuleset",lazy=True)(pname=(ns,"HostFirewallRuleset"), aname="_HostFirewallRuleset", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostFirewallRuleset = []
                    return
            Holder.__name__ = "ArrayOfHostFirewallRuleset_Holder"
            self.pyclass = Holder

    class HostRuntimeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostRuntimeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostRuntimeInfo_Def.schema
            TClist = [GTD("urn:vim25","HostSystemConnectionState",lazy=True)(pname=(ns,"connectionState"), aname="_connectionState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSystemPowerState",lazy=True)(pname=(ns,"powerState"), aname="_powerState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"inMaintenanceMode"), aname="_inMaintenanceMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"bootTime"), aname="_bootTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HealthSystemRuntime",lazy=True)(pname=(ns,"healthSystemRuntime"), aname="_healthSystemRuntime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostRuntimeInfo_Def.__bases__:
                bases = list(ns0.HostRuntimeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostRuntimeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostScsiDiskPartition_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostScsiDiskPartition")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostScsiDiskPartition_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskName"), aname="_diskName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"partition"), aname="_partition", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostScsiDiskPartition_Def.__bases__:
                bases = list(ns0.HostScsiDiskPartition_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostScsiDiskPartition_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostScsiDiskPartition_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostScsiDiskPartition")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostScsiDiskPartition_Def.schema
            TClist = [GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"HostScsiDiskPartition"), aname="_HostScsiDiskPartition", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostScsiDiskPartition = []
                    return
            Holder.__name__ = "ArrayOfHostScsiDiskPartition_Holder"
            self.pyclass = Holder

    class HostScsiDisk_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostScsiDisk")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostScsiDisk_Def.schema
            TClist = [GTD("urn:vim25","HostDiskDimensionsLba",lazy=True)(pname=(ns,"capacity"), aname="_capacity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"devicePath"), aname="_devicePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScsiLun_Def not in ns0.HostScsiDisk_Def.__bases__:
                bases = list(ns0.HostScsiDisk_Def.__bases__)
                bases.insert(0, ns0.ScsiLun_Def)
                ns0.HostScsiDisk_Def.__bases__ = tuple(bases)

            ns0.ScsiLun_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostScsiDisk_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostScsiDisk")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostScsiDisk_Def.schema
            TClist = [GTD("urn:vim25","HostScsiDisk",lazy=True)(pname=(ns,"HostScsiDisk"), aname="_HostScsiDisk", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostScsiDisk = []
                    return
            Holder.__name__ = "ArrayOfHostScsiDisk_Holder"
            self.pyclass = Holder

    class ScsiLunType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ScsiLunType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ScsiLunDurableName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScsiLunDurableName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScsiLunDurableName_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"namespace"), aname="_namespace", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"namespaceId"), aname="_namespaceId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"data"), aname="_data", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ScsiLunDurableName_Def.__bases__:
                bases = list(ns0.ScsiLunDurableName_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ScsiLunDurableName_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfScsiLunDurableName_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfScsiLunDurableName")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfScsiLunDurableName_Def.schema
            TClist = [GTD("urn:vim25","ScsiLunDurableName",lazy=True)(pname=(ns,"ScsiLunDurableName"), aname="_ScsiLunDurableName", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ScsiLunDurableName = []
                    return
            Holder.__name__ = "ArrayOfScsiLunDurableName_Holder"
            self.pyclass = Holder

    class ScsiLunState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ScsiLunState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ScsiLun_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScsiLun")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScsiLun_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"canonicalName"), aname="_canonicalName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"lunType"), aname="_lunType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vendor"), aname="_vendor", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"model"), aname="_model", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"revision"), aname="_revision", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"scsiLevel"), aname="_scsiLevel", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"serialNumber"), aname="_serialNumber", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ScsiLunDurableName",lazy=True)(pname=(ns,"durableName"), aname="_durableName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ScsiLunDurableName",lazy=True)(pname=(ns,"alternateName"), aname="_alternateName", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"standardInquiry"), aname="_standardInquiry", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"queueDepth"), aname="_queueDepth", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"operationalState"), aname="_operationalState", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostDevice_Def not in ns0.ScsiLun_Def.__bases__:
                bases = list(ns0.ScsiLun_Def.__bases__)
                bases.insert(0, ns0.HostDevice_Def)
                ns0.ScsiLun_Def.__bases__ = tuple(bases)

            ns0.HostDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfScsiLun_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfScsiLun")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfScsiLun_Def.schema
            TClist = [GTD("urn:vim25","ScsiLun",lazy=True)(pname=(ns,"ScsiLun"), aname="_ScsiLun", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ScsiLun = []
                    return
            Holder.__name__ = "ArrayOfScsiLun_Holder"
            self.pyclass = Holder

    class HostScsiTopologyInterface_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostScsiTopologyInterface")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostScsiTopologyInterface_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"adapter"), aname="_adapter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiTopologyTarget",lazy=True)(pname=(ns,"target"), aname="_target", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostScsiTopologyInterface_Def.__bases__:
                bases = list(ns0.HostScsiTopologyInterface_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostScsiTopologyInterface_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostScsiTopologyInterface_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostScsiTopologyInterface")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostScsiTopologyInterface_Def.schema
            TClist = [GTD("urn:vim25","HostScsiTopologyInterface",lazy=True)(pname=(ns,"HostScsiTopologyInterface"), aname="_HostScsiTopologyInterface", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostScsiTopologyInterface = []
                    return
            Holder.__name__ = "ArrayOfHostScsiTopologyInterface_Holder"
            self.pyclass = Holder

    class HostScsiTopologyTarget_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostScsiTopologyTarget")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostScsiTopologyTarget_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"target"), aname="_target", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiTopologyLun",lazy=True)(pname=(ns,"lun"), aname="_lun", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostTargetTransport",lazy=True)(pname=(ns,"transport"), aname="_transport", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostScsiTopologyTarget_Def.__bases__:
                bases = list(ns0.HostScsiTopologyTarget_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostScsiTopologyTarget_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostScsiTopologyTarget_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostScsiTopologyTarget")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostScsiTopologyTarget_Def.schema
            TClist = [GTD("urn:vim25","HostScsiTopologyTarget",lazy=True)(pname=(ns,"HostScsiTopologyTarget"), aname="_HostScsiTopologyTarget", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostScsiTopologyTarget = []
                    return
            Holder.__name__ = "ArrayOfHostScsiTopologyTarget_Holder"
            self.pyclass = Holder

    class HostScsiTopologyLun_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostScsiTopologyLun")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostScsiTopologyLun_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"lun"), aname="_lun", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"scsiLun"), aname="_scsiLun", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostScsiTopologyLun_Def.__bases__:
                bases = list(ns0.HostScsiTopologyLun_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostScsiTopologyLun_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostScsiTopologyLun_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostScsiTopologyLun")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostScsiTopologyLun_Def.schema
            TClist = [GTD("urn:vim25","HostScsiTopologyLun",lazy=True)(pname=(ns,"HostScsiTopologyLun"), aname="_HostScsiTopologyLun", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostScsiTopologyLun = []
                    return
            Holder.__name__ = "ArrayOfHostScsiTopologyLun_Holder"
            self.pyclass = Holder

    class HostScsiTopology_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostScsiTopology")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostScsiTopology_Def.schema
            TClist = [GTD("urn:vim25","HostScsiTopologyInterface",lazy=True)(pname=(ns,"adapter"), aname="_adapter", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostScsiTopology_Def.__bases__:
                bases = list(ns0.HostScsiTopology_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostScsiTopology_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostServicePolicy_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostServicePolicy")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostService_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostService")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostService_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"label"), aname="_label", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"required"), aname="_required", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"uninstallable"), aname="_uninstallable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"running"), aname="_running", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ruleset"), aname="_ruleset", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"policy"), aname="_policy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostService_Def.__bases__:
                bases = list(ns0.HostService_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostService_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostService_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostService")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostService_Def.schema
            TClist = [GTD("urn:vim25","HostService",lazy=True)(pname=(ns,"HostService"), aname="_HostService", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostService = []
                    return
            Holder.__name__ = "ArrayOfHostService_Holder"
            self.pyclass = Holder

    class HostServiceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostServiceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostServiceInfo_Def.schema
            TClist = [GTD("urn:vim25","HostService",lazy=True)(pname=(ns,"service"), aname="_service", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostServiceInfo_Def.__bases__:
                bases = list(ns0.HostServiceInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostServiceInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdateServicePolicyRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateServicePolicyRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateServicePolicyRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"policy"), aname="_policy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._id = None
                    self._policy = None
                    return
            Holder.__name__ = "UpdateServicePolicyRequestType_Holder"
            self.pyclass = Holder

    class StartServiceRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "StartServiceRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.StartServiceRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._id = None
                    return
            Holder.__name__ = "StartServiceRequestType_Holder"
            self.pyclass = Holder

    class StopServiceRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "StopServiceRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.StopServiceRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._id = None
                    return
            Holder.__name__ = "StopServiceRequestType_Holder"
            self.pyclass = Holder

    class RestartServiceRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RestartServiceRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RestartServiceRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._id = None
                    return
            Holder.__name__ = "RestartServiceRequestType_Holder"
            self.pyclass = Holder

    class UninstallServiceRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UninstallServiceRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UninstallServiceRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._id = None
                    return
            Holder.__name__ = "UninstallServiceRequestType_Holder"
            self.pyclass = Holder

    class RefreshServicesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshServicesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshServicesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshServicesRequestType_Holder"
            self.pyclass = Holder

    class HostSnmpDestination_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostSnmpDestination")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostSnmpDestination_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"hostName"), aname="_hostName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"community"), aname="_community", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostSnmpDestination_Def.__bases__:
                bases = list(ns0.HostSnmpDestination_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostSnmpDestination_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostSnmpDestination_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostSnmpDestination")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostSnmpDestination_Def.schema
            TClist = [GTD("urn:vim25","HostSnmpDestination",lazy=True)(pname=(ns,"HostSnmpDestination"), aname="_HostSnmpDestination", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostSnmpDestination = []
                    return
            Holder.__name__ = "ArrayOfHostSnmpDestination_Holder"
            self.pyclass = Holder

    class HostSnmpConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostSnmpConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostSnmpConfigSpec_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"readOnlyCommunities"), aname="_readOnlyCommunities", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSnmpDestination",lazy=True)(pname=(ns,"trapTargets"), aname="_trapTargets", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostSnmpConfigSpec_Def.__bases__:
                bases = list(ns0.HostSnmpConfigSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostSnmpConfigSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostSnmpSystemAgentLimits_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostSnmpSystemAgentLimits")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostSnmpSystemAgentLimits_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"maxReadOnlyCommunities"), aname="_maxReadOnlyCommunities", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxTrapDestinations"), aname="_maxTrapDestinations", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxCommunityLength"), aname="_maxCommunityLength", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxBufferSize"), aname="_maxBufferSize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostSnmpSystemAgentLimits_Def.__bases__:
                bases = list(ns0.HostSnmpSystemAgentLimits_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostSnmpSystemAgentLimits_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ReconfigureSnmpAgentRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureSnmpAgentRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureSnmpAgentRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSnmpConfigSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "ReconfigureSnmpAgentRequestType_Holder"
            self.pyclass = Holder

    class SendTestNotificationRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SendTestNotificationRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SendTestNotificationRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "SendTestNotificationRequestType_Holder"
            self.pyclass = Holder

    class HostStorageDeviceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostStorageDeviceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostStorageDeviceInfo_Def.schema
            TClist = [GTD("urn:vim25","HostHostBusAdapter",lazy=True)(pname=(ns,"hostBusAdapter"), aname="_hostBusAdapter", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ScsiLun",lazy=True)(pname=(ns,"scsiLun"), aname="_scsiLun", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiTopology",lazy=True)(pname=(ns,"scsiTopology"), aname="_scsiTopology", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostMultipathInfo",lazy=True)(pname=(ns,"multipathInfo"), aname="_multipathInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"softwareInternetScsiEnabled"), aname="_softwareInternetScsiEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostStorageDeviceInfo_Def.__bases__:
                bases = list(ns0.HostStorageDeviceInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostStorageDeviceInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RetrieveDiskPartitionInfoRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveDiskPartitionInfoRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveDiskPartitionInfoRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"devicePath"), aname="_devicePath", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._devicePath = []
                    return
            Holder.__name__ = "RetrieveDiskPartitionInfoRequestType_Holder"
            self.pyclass = Holder

    class ComputeDiskPartitionInfoRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ComputeDiskPartitionInfoRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ComputeDiskPartitionInfoRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"devicePath"), aname="_devicePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskPartitionLayout",lazy=True)(pname=(ns,"layout"), aname="_layout", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._devicePath = None
                    self._layout = None
                    return
            Holder.__name__ = "ComputeDiskPartitionInfoRequestType_Holder"
            self.pyclass = Holder

    class UpdateDiskPartitionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateDiskPartitionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateDiskPartitionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"devicePath"), aname="_devicePath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostDiskPartitionSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._devicePath = None
                    self._spec = None
                    return
            Holder.__name__ = "UpdateDiskPartitionsRequestType_Holder"
            self.pyclass = Holder

    class FormatVmfsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "FormatVmfsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.FormatVmfsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVmfsSpec",lazy=True)(pname=(ns,"createSpec"), aname="_createSpec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._createSpec = None
                    return
            Holder.__name__ = "FormatVmfsRequestType_Holder"
            self.pyclass = Holder

    class RescanVmfsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RescanVmfsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RescanVmfsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RescanVmfsRequestType_Holder"
            self.pyclass = Holder

    class AttachVmfsExtentRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AttachVmfsExtentRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AttachVmfsExtentRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vmfsPath"), aname="_vmfsPath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"extent"), aname="_extent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vmfsPath = None
                    self._extent = None
                    return
            Holder.__name__ = "AttachVmfsExtentRequestType_Holder"
            self.pyclass = Holder

    class UpgradeVmfsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpgradeVmfsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpgradeVmfsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vmfsPath"), aname="_vmfsPath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._vmfsPath = None
                    return
            Holder.__name__ = "UpgradeVmfsRequestType_Holder"
            self.pyclass = Holder

    class UpgradeVmLayoutRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpgradeVmLayoutRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpgradeVmLayoutRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "UpgradeVmLayoutRequestType_Holder"
            self.pyclass = Holder

    class RescanHbaRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RescanHbaRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RescanHbaRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"hbaDevice"), aname="_hbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._hbaDevice = None
                    return
            Holder.__name__ = "RescanHbaRequestType_Holder"
            self.pyclass = Holder

    class RescanAllHbaRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RescanAllHbaRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RescanAllHbaRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RescanAllHbaRequestType_Holder"
            self.pyclass = Holder

    class UpdateSoftwareInternetScsiEnabledRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateSoftwareInternetScsiEnabledRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateSoftwareInternetScsiEnabledRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._enabled = None
                    return
            Holder.__name__ = "UpdateSoftwareInternetScsiEnabledRequestType_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiDiscoveryPropertiesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateInternetScsiDiscoveryPropertiesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateInternetScsiDiscoveryPropertiesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaDiscoveryProperties",lazy=True)(pname=(ns,"discoveryProperties"), aname="_discoveryProperties", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._discoveryProperties = None
                    return
            Holder.__name__ = "UpdateInternetScsiDiscoveryPropertiesRequestType_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiAuthenticationPropertiesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateInternetScsiAuthenticationPropertiesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateInternetScsiAuthenticationPropertiesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaAuthenticationProperties",lazy=True)(pname=(ns,"authenticationProperties"), aname="_authenticationProperties", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._authenticationProperties = None
                    return
            Holder.__name__ = "UpdateInternetScsiAuthenticationPropertiesRequestType_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiIPPropertiesRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateInternetScsiIPPropertiesRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateInternetScsiIPPropertiesRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaIPProperties",lazy=True)(pname=(ns,"ipProperties"), aname="_ipProperties", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._ipProperties = None
                    return
            Holder.__name__ = "UpdateInternetScsiIPPropertiesRequestType_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiNameRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateInternetScsiNameRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateInternetScsiNameRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiName"), aname="_iScsiName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._iScsiName = None
                    return
            Holder.__name__ = "UpdateInternetScsiNameRequestType_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiAliasRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateInternetScsiAliasRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateInternetScsiAliasRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiAlias"), aname="_iScsiAlias", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._iScsiAlias = None
                    return
            Holder.__name__ = "UpdateInternetScsiAliasRequestType_Holder"
            self.pyclass = Holder

    class AddInternetScsiSendTargetsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddInternetScsiSendTargetsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddInternetScsiSendTargetsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaSendTarget",lazy=True)(pname=(ns,"targets"), aname="_targets", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._targets = []
                    return
            Holder.__name__ = "AddInternetScsiSendTargetsRequestType_Holder"
            self.pyclass = Holder

    class RemoveInternetScsiSendTargetsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveInternetScsiSendTargetsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveInternetScsiSendTargetsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaSendTarget",lazy=True)(pname=(ns,"targets"), aname="_targets", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._targets = []
                    return
            Holder.__name__ = "RemoveInternetScsiSendTargetsRequestType_Holder"
            self.pyclass = Holder

    class AddInternetScsiStaticTargetsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "AddInternetScsiStaticTargetsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.AddInternetScsiStaticTargetsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaStaticTarget",lazy=True)(pname=(ns,"targets"), aname="_targets", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._targets = []
                    return
            Holder.__name__ = "AddInternetScsiStaticTargetsRequestType_Holder"
            self.pyclass = Holder

    class RemoveInternetScsiStaticTargetsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveInternetScsiStaticTargetsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveInternetScsiStaticTargetsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiHbaDevice"), aname="_iScsiHbaDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostInternetScsiHbaStaticTarget",lazy=True)(pname=(ns,"targets"), aname="_targets", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._iScsiHbaDevice = None
                    self._targets = []
                    return
            Holder.__name__ = "RemoveInternetScsiStaticTargetsRequestType_Holder"
            self.pyclass = Holder

    class EnableMultipathPathRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "EnableMultipathPathRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.EnableMultipathPathRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pathName"), aname="_pathName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._pathName = None
                    return
            Holder.__name__ = "EnableMultipathPathRequestType_Holder"
            self.pyclass = Holder

    class DisableMultipathPathRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DisableMultipathPathRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DisableMultipathPathRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pathName"), aname="_pathName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._pathName = None
                    return
            Holder.__name__ = "DisableMultipathPathRequestType_Holder"
            self.pyclass = Holder

    class SetMultipathLunPolicyRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SetMultipathLunPolicyRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SetMultipathLunPolicyRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"lunId"), aname="_lunId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostMultipathInfoLogicalUnitPolicy",lazy=True)(pname=(ns,"policy"), aname="_policy", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._lunId = None
                    self._policy = None
                    return
            Holder.__name__ = "SetMultipathLunPolicyRequestType_Holder"
            self.pyclass = Holder

    class RefreshStorageSystemRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RefreshStorageSystemRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RefreshStorageSystemRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RefreshStorageSystemRequestType_Holder"
            self.pyclass = Holder

    class HostHardwareSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostHardwareSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostHardwareSummary_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"vendor"), aname="_vendor", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"model"), aname="_model", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSystemIdentificationInfo",lazy=True)(pname=(ns,"otherIdentifyingInfo"), aname="_otherIdentifyingInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memorySize"), aname="_memorySize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"cpuModel"), aname="_cpuModel", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"cpuMhz"), aname="_cpuMhz", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"numCpuPkgs"), aname="_numCpuPkgs", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"numCpuCores"), aname="_numCpuCores", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ishort(pname=(ns,"numCpuThreads"), aname="_numCpuThreads", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numNics"), aname="_numNics", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numHBAs"), aname="_numHBAs", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostHardwareSummary_Def.__bases__:
                bases = list(ns0.HostHardwareSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostHardwareSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostListSummaryQuickStats_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostListSummaryQuickStats")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostListSummaryQuickStats_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"overallCpuUsage"), aname="_overallCpuUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"overallMemoryUsage"), aname="_overallMemoryUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"distributedCpuFairness"), aname="_distributedCpuFairness", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"distributedMemoryFairness"), aname="_distributedMemoryFairness", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostListSummaryQuickStats_Def.__bases__:
                bases = list(ns0.HostListSummaryQuickStats_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostListSummaryQuickStats_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostConfigSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostConfigSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostConfigSummary_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"port"), aname="_port", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","AboutInfo",lazy=True)(pname=(ns,"product"), aname="_product", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmotionEnabled"), aname="_vmotionEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostConfigSummary_Def.__bases__:
                bases = list(ns0.HostConfigSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostConfigSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostListSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostListSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostListSummary_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostHardwareSummary",lazy=True)(pname=(ns,"hardware"), aname="_hardware", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostRuntimeInfo",lazy=True)(pname=(ns,"runtime"), aname="_runtime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostConfigSummary",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostListSummaryQuickStats",lazy=True)(pname=(ns,"quickStats"), aname="_quickStats", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityStatus",lazy=True)(pname=(ns,"overallStatus"), aname="_overallStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"rebootRequired"), aname="_rebootRequired", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomFieldValue",lazy=True)(pname=(ns,"customValue"), aname="_customValue", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"managementServerIp"), aname="_managementServerIp", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostListSummary_Def.__bases__:
                bases = list(ns0.HostListSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostListSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostSystemHealthInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostSystemHealthInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostSystemHealthInfo_Def.schema
            TClist = [GTD("urn:vim25","HostNumericSensorInfo",lazy=True)(pname=(ns,"numericSensorInfo"), aname="_numericSensorInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostSystemHealthInfo_Def.__bases__:
                bases = list(ns0.HostSystemHealthInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostSystemHealthInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostSystemIdentificationInfoIdentifier_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "HostSystemIdentificationInfoIdentifier")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class HostSystemIdentificationInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostSystemIdentificationInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostSystemIdentificationInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"identifierValue"), aname="_identifierValue", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"identifierType"), aname="_identifierType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostSystemIdentificationInfo_Def.__bases__:
                bases = list(ns0.HostSystemIdentificationInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostSystemIdentificationInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostSystemIdentificationInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostSystemIdentificationInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostSystemIdentificationInfo_Def.schema
            TClist = [GTD("urn:vim25","HostSystemIdentificationInfo",lazy=True)(pname=(ns,"HostSystemIdentificationInfo"), aname="_HostSystemIdentificationInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostSystemIdentificationInfo = []
                    return
            Holder.__name__ = "ArrayOfHostSystemIdentificationInfo_Holder"
            self.pyclass = Holder

    class HostSystemResourceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostSystemResourceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostSystemResourceInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceConfigSpec",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostSystemResourceInfo",lazy=True)(pname=(ns,"child"), aname="_child", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostSystemResourceInfo_Def.__bases__:
                bases = list(ns0.HostSystemResourceInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostSystemResourceInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostSystemResourceInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostSystemResourceInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostSystemResourceInfo_Def.schema
            TClist = [GTD("urn:vim25","HostSystemResourceInfo",lazy=True)(pname=(ns,"HostSystemResourceInfo"), aname="_HostSystemResourceInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostSystemResourceInfo = []
                    return
            Holder.__name__ = "ArrayOfHostSystemResourceInfo_Holder"
            self.pyclass = Holder

    class HostTargetTransport_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostTargetTransport")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostTargetTransport_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostTargetTransport_Def.__bases__:
                bases = list(ns0.HostTargetTransport_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostTargetTransport_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostParallelScsiTargetTransport_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostParallelScsiTargetTransport")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostParallelScsiTargetTransport_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostTargetTransport_Def not in ns0.HostParallelScsiTargetTransport_Def.__bases__:
                bases = list(ns0.HostParallelScsiTargetTransport_Def.__bases__)
                bases.insert(0, ns0.HostTargetTransport_Def)
                ns0.HostParallelScsiTargetTransport_Def.__bases__ = tuple(bases)

            ns0.HostTargetTransport_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostBlockAdapterTargetTransport_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostBlockAdapterTargetTransport")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostBlockAdapterTargetTransport_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostTargetTransport_Def not in ns0.HostBlockAdapterTargetTransport_Def.__bases__:
                bases = list(ns0.HostBlockAdapterTargetTransport_Def.__bases__)
                bases.insert(0, ns0.HostTargetTransport_Def)
                ns0.HostBlockAdapterTargetTransport_Def.__bases__ = tuple(bases)

            ns0.HostTargetTransport_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostFibreChannelTargetTransport_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostFibreChannelTargetTransport")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostFibreChannelTargetTransport_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"portWorldWideName"), aname="_portWorldWideName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"nodeWorldWideName"), aname="_nodeWorldWideName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostTargetTransport_Def not in ns0.HostFibreChannelTargetTransport_Def.__bases__:
                bases = list(ns0.HostFibreChannelTargetTransport_Def.__bases__)
                bases.insert(0, ns0.HostTargetTransport_Def)
                ns0.HostFibreChannelTargetTransport_Def.__bases__ = tuple(bases)

            ns0.HostTargetTransport_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostInternetScsiTargetTransport_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostInternetScsiTargetTransport")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostInternetScsiTargetTransport_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"iScsiName"), aname="_iScsiName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"iScsiAlias"), aname="_iScsiAlias", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"address"), aname="_address", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostTargetTransport_Def not in ns0.HostInternetScsiTargetTransport_Def.__bases__:
                bases = list(ns0.HostInternetScsiTargetTransport_Def.__bases__)
                bases.insert(0, ns0.HostTargetTransport_Def)
                ns0.HostInternetScsiTargetTransport_Def.__bases__ = tuple(bases)

            ns0.HostTargetTransport_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVMotionConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVMotionConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVMotionConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"vmotionNicKey"), aname="_vmotionNicKey", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVMotionConfig_Def.__bases__:
                bases = list(ns0.HostVMotionConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVMotionConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVMotionInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVMotionInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVMotionInfo_Def.schema
            TClist = [GTD("urn:vim25","HostVMotionNetConfig",lazy=True)(pname=(ns,"netConfig"), aname="_netConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpConfig",lazy=True)(pname=(ns,"ipConfig"), aname="_ipConfig", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVMotionInfo_Def.__bases__:
                bases = list(ns0.HostVMotionInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVMotionInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVMotionNetConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVMotionNetConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVMotionNetConfig_Def.schema
            TClist = [GTD("urn:vim25","HostVirtualNic",lazy=True)(pname=(ns,"candidateVnic"), aname="_candidateVnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"selectedVnic"), aname="_selectedVnic", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVMotionNetConfig_Def.__bases__:
                bases = list(ns0.HostVMotionNetConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVMotionNetConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpdateIpConfigRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateIpConfigRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateIpConfigRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostIpConfig",lazy=True)(pname=(ns,"ipConfig"), aname="_ipConfig", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._ipConfig = None
                    return
            Holder.__name__ = "UpdateIpConfigRequestType_Holder"
            self.pyclass = Holder

    class SelectVnicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "SelectVnicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.SelectVnicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._device = None
                    return
            Holder.__name__ = "SelectVnicRequestType_Holder"
            self.pyclass = Holder

    class DeselectVnicRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DeselectVnicRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DeselectVnicRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DeselectVnicRequestType_Holder"
            self.pyclass = Holder

    class HostVirtualNicSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualNicSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualNicSpec_Def.schema
            TClist = [GTD("urn:vim25","HostIpConfig",lazy=True)(pname=(ns,"ip"), aname="_ip", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mac"), aname="_mac", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualNicSpec_Def.__bases__:
                bases = list(ns0.HostVirtualNicSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualNicSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVirtualNicConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualNicConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualNicConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"changeOperation"), aname="_changeOperation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"portgroup"), aname="_portgroup", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualNicConfig_Def.__bases__:
                bases = list(ns0.HostVirtualNicConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualNicConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostVirtualNicConfig_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostVirtualNicConfig")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostVirtualNicConfig_Def.schema
            TClist = [GTD("urn:vim25","HostVirtualNicConfig",lazy=True)(pname=(ns,"HostVirtualNicConfig"), aname="_HostVirtualNicConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostVirtualNicConfig = []
                    return
            Holder.__name__ = "ArrayOfHostVirtualNicConfig_Holder"
            self.pyclass = Holder

    class HostVirtualNic_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualNic")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualNic_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"portgroup"), aname="_portgroup", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualNicSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"port"), aname="_port", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualNic_Def.__bases__:
                bases = list(ns0.HostVirtualNic_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualNic_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostVirtualNic_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostVirtualNic")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostVirtualNic_Def.schema
            TClist = [GTD("urn:vim25","HostVirtualNic",lazy=True)(pname=(ns,"HostVirtualNic"), aname="_HostVirtualNic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostVirtualNic = []
                    return
            Holder.__name__ = "ArrayOfHostVirtualNic_Holder"
            self.pyclass = Holder

    class HostVirtualSwitchBridge_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitchBridge")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitchBridge_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualSwitchBridge_Def.__bases__:
                bases = list(ns0.HostVirtualSwitchBridge_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualSwitchBridge_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVirtualSwitchAutoBridge_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitchAutoBridge")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitchAutoBridge_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"excludedNicDevice"), aname="_excludedNicDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostVirtualSwitchBridge_Def not in ns0.HostVirtualSwitchAutoBridge_Def.__bases__:
                bases = list(ns0.HostVirtualSwitchAutoBridge_Def.__bases__)
                bases.insert(0, ns0.HostVirtualSwitchBridge_Def)
                ns0.HostVirtualSwitchAutoBridge_Def.__bases__ = tuple(bases)

            ns0.HostVirtualSwitchBridge_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVirtualSwitchSimpleBridge_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitchSimpleBridge")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitchSimpleBridge_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"nicDevice"), aname="_nicDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostVirtualSwitchBridge_Def not in ns0.HostVirtualSwitchSimpleBridge_Def.__bases__:
                bases = list(ns0.HostVirtualSwitchSimpleBridge_Def.__bases__)
                bases.insert(0, ns0.HostVirtualSwitchBridge_Def)
                ns0.HostVirtualSwitchSimpleBridge_Def.__bases__ = tuple(bases)

            ns0.HostVirtualSwitchBridge_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVirtualSwitchBondBridge_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitchBondBridge")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitchBondBridge_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"nicDevice"), aname="_nicDevice", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualSwitchBeaconConfig",lazy=True)(pname=(ns,"beacon"), aname="_beacon", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostVirtualSwitchBridge_Def not in ns0.HostVirtualSwitchBondBridge_Def.__bases__:
                bases = list(ns0.HostVirtualSwitchBondBridge_Def.__bases__)
                bases.insert(0, ns0.HostVirtualSwitchBridge_Def)
                ns0.HostVirtualSwitchBondBridge_Def.__bases__ = tuple(bases)

            ns0.HostVirtualSwitchBridge_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVirtualSwitchBeaconConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitchBeaconConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitchBeaconConfig_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"interval"), aname="_interval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualSwitchBeaconConfig_Def.__bases__:
                bases = list(ns0.HostVirtualSwitchBeaconConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualSwitchBeaconConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVirtualSwitchSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitchSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitchSpec_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"numPorts"), aname="_numPorts", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualSwitchBridge",lazy=True)(pname=(ns,"bridge"), aname="_bridge", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostNetworkPolicy",lazy=True)(pname=(ns,"policy"), aname="_policy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"mtu"), aname="_mtu", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualSwitchSpec_Def.__bases__:
                bases = list(ns0.HostVirtualSwitchSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualSwitchSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVirtualSwitchConfig_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitchConfig")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitchConfig_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"changeOperation"), aname="_changeOperation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualSwitchSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualSwitchConfig_Def.__bases__:
                bases = list(ns0.HostVirtualSwitchConfig_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualSwitchConfig_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostVirtualSwitchConfig_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostVirtualSwitchConfig")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostVirtualSwitchConfig_Def.schema
            TClist = [GTD("urn:vim25","HostVirtualSwitchConfig",lazy=True)(pname=(ns,"HostVirtualSwitchConfig"), aname="_HostVirtualSwitchConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostVirtualSwitchConfig = []
                    return
            Holder.__name__ = "ArrayOfHostVirtualSwitchConfig_Holder"
            self.pyclass = Holder

    class HostVirtualSwitch_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVirtualSwitch")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVirtualSwitch_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numPorts"), aname="_numPorts", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numPortsAvailable"), aname="_numPortsAvailable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"mtu"), aname="_mtu", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"portgroup"), aname="_portgroup", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pnic"), aname="_pnic", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostVirtualSwitchSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVirtualSwitch_Def.__bases__:
                bases = list(ns0.HostVirtualSwitch_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVirtualSwitch_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostVirtualSwitch_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostVirtualSwitch")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostVirtualSwitch_Def.schema
            TClist = [GTD("urn:vim25","HostVirtualSwitch",lazy=True)(pname=(ns,"HostVirtualSwitch"), aname="_HostVirtualSwitch", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostVirtualSwitch = []
                    return
            Holder.__name__ = "ArrayOfHostVirtualSwitch_Holder"
            self.pyclass = Holder

    class HostVmfsSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVmfsSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVmfsSpec_Def.schema
            TClist = [GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"extent"), aname="_extent", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"blockSizeMb"), aname="_blockSizeMb", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"majorVersion"), aname="_majorVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"volumeName"), aname="_volumeName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostVmfsSpec_Def.__bases__:
                bases = list(ns0.HostVmfsSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostVmfsSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostVmfsVolume_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostVmfsVolume")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostVmfsVolume_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"blockSizeMb"), aname="_blockSizeMb", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxBlocks"), aname="_maxBlocks", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"majorVersion"), aname="_majorVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostScsiDiskPartition",lazy=True)(pname=(ns,"extent"), aname="_extent", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmfsUpgradable"), aname="_vmfsUpgradable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HostFileSystemVolume_Def not in ns0.HostVmfsVolume_Def.__bases__:
                bases = list(ns0.HostVmfsVolume_Def.__bases__)
                bases.insert(0, ns0.HostFileSystemVolume_Def)
                ns0.HostVmfsVolume_Def.__bases__ = tuple(bases)

            ns0.HostFileSystemVolume_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayUpdateOperation_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayUpdateOperation")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ArrayUpdateSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ArrayUpdateSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ArrayUpdateSpec_Def.schema
            TClist = [GTD("urn:vim25","ArrayUpdateOperation",lazy=True)(pname=(ns,"operation"), aname="_operation", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"removeKey"), aname="_removeKey", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ArrayUpdateSpec_Def.__bases__:
                bases = list(ns0.ArrayUpdateSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ArrayUpdateSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class BoolOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "BoolOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.BoolOption_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"supported"), aname="_supported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"defaultValue"), aname="_defaultValue", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.OptionType_Def not in ns0.BoolOption_Def.__bases__:
                bases = list(ns0.BoolOption_Def.__bases__)
                bases.insert(0, ns0.OptionType_Def)
                ns0.BoolOption_Def.__bases__ = tuple(bases)

            ns0.OptionType_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ChoiceOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ChoiceOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ChoiceOption_Def.schema
            TClist = [GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"choiceInfo"), aname="_choiceInfo", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"defaultIndex"), aname="_defaultIndex", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.OptionType_Def not in ns0.ChoiceOption_Def.__bases__:
                bases = list(ns0.ChoiceOption_Def.__bases__)
                bases.insert(0, ns0.OptionType_Def)
                ns0.ChoiceOption_Def.__bases__ = tuple(bases)

            ns0.OptionType_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class FloatOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "FloatOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.FloatOption_Def.schema
            TClist = [ZSI.TCnumbers.FPfloat(pname=(ns,"min"), aname="_min", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.FPfloat(pname=(ns,"max"), aname="_max", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.FPfloat(pname=(ns,"defaultValue"), aname="_defaultValue", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.OptionType_Def not in ns0.FloatOption_Def.__bases__:
                bases = list(ns0.FloatOption_Def.__bases__)
                bases.insert(0, ns0.OptionType_Def)
                ns0.FloatOption_Def.__bases__ = tuple(bases)

            ns0.OptionType_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class IntOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "IntOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.IntOption_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"min"), aname="_min", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"max"), aname="_max", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"defaultValue"), aname="_defaultValue", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.OptionType_Def not in ns0.IntOption_Def.__bases__:
                bases = list(ns0.IntOption_Def.__bases__)
                bases.insert(0, ns0.OptionType_Def)
                ns0.IntOption_Def.__bases__ = tuple(bases)

            ns0.OptionType_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class LongOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "LongOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.LongOption_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"min"), aname="_min", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"max"), aname="_max", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"defaultValue"), aname="_defaultValue", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.OptionType_Def not in ns0.LongOption_Def.__bases__:
                bases = list(ns0.LongOption_Def.__bases__)
                bases.insert(0, ns0.OptionType_Def)
                ns0.LongOption_Def.__bases__ = tuple(bases)

            ns0.OptionType_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class OptionDef_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "OptionDef")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.OptionDef_Def.schema
            TClist = [GTD("urn:vim25","OptionType",lazy=True)(pname=(ns,"optionType"), aname="_optionType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ElementDescription_Def not in ns0.OptionDef_Def.__bases__:
                bases = list(ns0.OptionDef_Def.__bases__)
                bases.insert(0, ns0.ElementDescription_Def)
                ns0.OptionDef_Def.__bases__ = tuple(bases)

            ns0.ElementDescription_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfOptionDef_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfOptionDef")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfOptionDef_Def.schema
            TClist = [GTD("urn:vim25","OptionDef",lazy=True)(pname=(ns,"OptionDef"), aname="_OptionDef", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._OptionDef = []
                    return
            Holder.__name__ = "ArrayOfOptionDef_Holder"
            self.pyclass = Holder

    class QueryOptionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "QueryOptionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.QueryOptionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    return
            Holder.__name__ = "QueryOptionsRequestType_Holder"
            self.pyclass = Holder

    class UpdateOptionsRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpdateOptionsRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.UpdateOptionsRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"changedValue"), aname="_changedValue", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._changedValue = []
                    return
            Holder.__name__ = "UpdateOptionsRequestType_Holder"
            self.pyclass = Holder

    class OptionType_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "OptionType")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.OptionType_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"valueIsReadonly"), aname="_valueIsReadonly", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.OptionType_Def.__bases__:
                bases = list(ns0.OptionType_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.OptionType_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class OptionValue_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "OptionValue")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.OptionValue_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"value"), aname="_value", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.OptionValue_Def.__bases__:
                bases = list(ns0.OptionValue_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.OptionValue_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfOptionValue_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfOptionValue")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfOptionValue_Def.schema
            TClist = [GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"OptionValue"), aname="_OptionValue", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._OptionValue = []
                    return
            Holder.__name__ = "ArrayOfOptionValue_Holder"
            self.pyclass = Holder

    class StringOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "StringOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.StringOption_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"defaultValue"), aname="_defaultValue", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"validCharacters"), aname="_validCharacters", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.OptionType_Def not in ns0.StringOption_Def.__bases__:
                bases = list(ns0.StringOption_Def.__bases__)
                bases.insert(0, ns0.OptionType_Def)
                ns0.StringOption_Def.__bases__ = tuple(bases)

            ns0.OptionType_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RemoveScheduledTaskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveScheduledTaskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveScheduledTaskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RemoveScheduledTaskRequestType_Holder"
            self.pyclass = Holder

    class ReconfigureScheduledTaskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ReconfigureScheduledTaskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ReconfigureScheduledTaskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ScheduledTaskSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._spec = None
                    return
            Holder.__name__ = "ReconfigureScheduledTaskRequestType_Holder"
            self.pyclass = Holder

    class RunScheduledTaskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RunScheduledTaskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RunScheduledTaskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "RunScheduledTaskRequestType_Holder"
            self.pyclass = Holder

    class ScheduledTaskDetail_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskDetail")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskDetail_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"frequency"), aname="_frequency", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TypeDescription_Def not in ns0.ScheduledTaskDetail_Def.__bases__:
                bases = list(ns0.ScheduledTaskDetail_Def.__bases__)
                bases.insert(0, ns0.TypeDescription_Def)
                ns0.ScheduledTaskDetail_Def.__bases__ = tuple(bases)

            ns0.TypeDescription_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfScheduledTaskDetail_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfScheduledTaskDetail")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfScheduledTaskDetail_Def.schema
            TClist = [GTD("urn:vim25","ScheduledTaskDetail",lazy=True)(pname=(ns,"ScheduledTaskDetail"), aname="_ScheduledTaskDetail", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ScheduledTaskDetail = []
                    return
            Holder.__name__ = "ArrayOfScheduledTaskDetail_Holder"
            self.pyclass = Holder

    class ScheduledTaskDescription_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskDescription")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskDescription_Def.schema
            TClist = [GTD("urn:vim25","TypeDescription",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ScheduledTaskDetail",lazy=True)(pname=(ns,"schedulerInfo"), aname="_schedulerInfo", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"dayOfWeek"), aname="_dayOfWeek", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ElementDescription",lazy=True)(pname=(ns,"weekOfMonth"), aname="_weekOfMonth", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ScheduledTaskDescription_Def.__bases__:
                bases = list(ns0.ScheduledTaskDescription_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ScheduledTaskDescription_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"scheduledTask"), aname="_scheduledTask", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"lastModifiedTime"), aname="_lastModifiedTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"lastModifiedUser"), aname="_lastModifiedUser", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"nextRunTime"), aname="_nextRunTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"prevRunTime"), aname="_prevRunTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskInfoState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LocalizedMethodFault",lazy=True)(pname=(ns,"error"), aname="_error", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"result"), aname="_result", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"progress"), aname="_progress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"activeTask"), aname="_activeTask", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ScheduledTaskSpec_Def not in ns0.ScheduledTaskInfo_Def.__bases__:
                bases = list(ns0.ScheduledTaskInfo_Def.__bases__)
                bases.insert(0, ns0.ScheduledTaskSpec_Def)
                ns0.ScheduledTaskInfo_Def.__bases__ = tuple(bases)

            ns0.ScheduledTaskSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CreateScheduledTaskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateScheduledTaskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateScheduledTaskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ScheduledTaskSpec",lazy=True)(pname=(ns,"spec"), aname="_spec", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    self._spec = None
                    return
            Holder.__name__ = "CreateScheduledTaskRequestType_Holder"
            self.pyclass = Holder

    class RetrieveEntityScheduledTaskRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RetrieveEntityScheduledTaskRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RetrieveEntityScheduledTaskRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = None
                    return
            Holder.__name__ = "RetrieveEntityScheduledTaskRequestType_Holder"
            self.pyclass = Holder

    class TaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "TaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.TaskScheduler_Def.schema
            TClist = [ZSI.TCtimes.gDateTime(pname=(ns,"activeTime"), aname="_activeTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"expireTime"), aname="_expireTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.TaskScheduler_Def.__bases__:
                bases = list(ns0.TaskScheduler_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.TaskScheduler_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class AfterStartupTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "AfterStartupTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.AfterStartupTaskScheduler_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"minute"), aname="_minute", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskScheduler_Def not in ns0.AfterStartupTaskScheduler_Def.__bases__:
                bases = list(ns0.AfterStartupTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.TaskScheduler_Def)
                ns0.AfterStartupTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.TaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class OnceTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "OnceTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.OnceTaskScheduler_Def.schema
            TClist = [ZSI.TCtimes.gDateTime(pname=(ns,"runAt"), aname="_runAt", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskScheduler_Def not in ns0.OnceTaskScheduler_Def.__bases__:
                bases = list(ns0.OnceTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.TaskScheduler_Def)
                ns0.OnceTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.TaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class RecurrentTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "RecurrentTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.RecurrentTaskScheduler_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"interval"), aname="_interval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.TaskScheduler_Def not in ns0.RecurrentTaskScheduler_Def.__bases__:
                bases = list(ns0.RecurrentTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.TaskScheduler_Def)
                ns0.RecurrentTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.TaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HourlyTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HourlyTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HourlyTaskScheduler_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"minute"), aname="_minute", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.RecurrentTaskScheduler_Def not in ns0.HourlyTaskScheduler_Def.__bases__:
                bases = list(ns0.HourlyTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.RecurrentTaskScheduler_Def)
                ns0.HourlyTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.RecurrentTaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DailyTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DailyTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DailyTaskScheduler_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"hour"), aname="_hour", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.HourlyTaskScheduler_Def not in ns0.DailyTaskScheduler_Def.__bases__:
                bases = list(ns0.DailyTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.HourlyTaskScheduler_Def)
                ns0.DailyTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.HourlyTaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class WeeklyTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "WeeklyTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.WeeklyTaskScheduler_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"sunday"), aname="_sunday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"monday"), aname="_monday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"tuesday"), aname="_tuesday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"wednesday"), aname="_wednesday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"thursday"), aname="_thursday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"friday"), aname="_friday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"saturday"), aname="_saturday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DailyTaskScheduler_Def not in ns0.WeeklyTaskScheduler_Def.__bases__:
                bases = list(ns0.WeeklyTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.DailyTaskScheduler_Def)
                ns0.WeeklyTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.DailyTaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MonthlyTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MonthlyTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MonthlyTaskScheduler_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DailyTaskScheduler_Def not in ns0.MonthlyTaskScheduler_Def.__bases__:
                bases = list(ns0.MonthlyTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.DailyTaskScheduler_Def)
                ns0.MonthlyTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.DailyTaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class MonthlyByDayTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MonthlyByDayTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MonthlyByDayTaskScheduler_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"day"), aname="_day", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MonthlyTaskScheduler_Def not in ns0.MonthlyByDayTaskScheduler_Def.__bases__:
                bases = list(ns0.MonthlyByDayTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.MonthlyTaskScheduler_Def)
                ns0.MonthlyByDayTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.MonthlyTaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class DayOfWeek_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DayOfWeek")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class WeekOfMonth_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "WeekOfMonth")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class MonthlyByWeekdayTaskScheduler_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "MonthlyByWeekdayTaskScheduler")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.MonthlyByWeekdayTaskScheduler_Def.schema
            TClist = [GTD("urn:vim25","WeekOfMonth",lazy=True)(pname=(ns,"offset"), aname="_offset", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DayOfWeek",lazy=True)(pname=(ns,"weekday"), aname="_weekday", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.MonthlyTaskScheduler_Def not in ns0.MonthlyByWeekdayTaskScheduler_Def.__bases__:
                bases = list(ns0.MonthlyByWeekdayTaskScheduler_Def.__bases__)
                bases.insert(0, ns0.MonthlyTaskScheduler_Def)
                ns0.MonthlyByWeekdayTaskScheduler_Def.__bases__ = tuple(bases)

            ns0.MonthlyTaskScheduler_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ScheduledTaskSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ScheduledTaskSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ScheduledTaskSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","TaskScheduler",lazy=True)(pname=(ns,"scheduler"), aname="_scheduler", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Action",lazy=True)(pname=(ns,"action"), aname="_action", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"notification"), aname="_notification", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ScheduledTaskSpec_Def.__bases__:
                bases = list(ns0.ScheduledTaskSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ScheduledTaskSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class OpenInventoryViewFolderRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "OpenInventoryViewFolderRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.OpenInventoryViewFolderRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = []
                    return
            Holder.__name__ = "OpenInventoryViewFolderRequestType_Holder"
            self.pyclass = Holder

    class CloseInventoryViewFolderRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CloseInventoryViewFolderRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CloseInventoryViewFolderRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"entity"), aname="_entity", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._entity = []
                    return
            Holder.__name__ = "CloseInventoryViewFolderRequestType_Holder"
            self.pyclass = Holder

    class ModifyListViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ModifyListViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ModifyListViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"add"), aname="_add", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"remove"), aname="_remove", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._add = []
                    self._remove = []
                    return
            Holder.__name__ = "ModifyListViewRequestType_Holder"
            self.pyclass = Holder

    class ResetListViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetListViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetListViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._obj = []
                    return
            Holder.__name__ = "ResetListViewRequestType_Holder"
            self.pyclass = Holder

    class ResetListViewFromViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ResetListViewFromViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ResetListViewFromViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"view"), aname="_view", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._view = None
                    return
            Holder.__name__ = "ResetListViewFromViewRequestType_Holder"
            self.pyclass = Holder

    class DestroyViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "DestroyViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.DestroyViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "DestroyViewRequestType_Holder"
            self.pyclass = Holder

    class CreateInventoryViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateInventoryViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateInventoryViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    return
            Holder.__name__ = "CreateInventoryViewRequestType_Holder"
            self.pyclass = Holder

    class CreateContainerViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateContainerViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateContainerViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"container"), aname="_container", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"recursive"), aname="_recursive", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._container = None
                    self._type = []
                    self._recursive = None
                    return
            Holder.__name__ = "CreateContainerViewRequestType_Holder"
            self.pyclass = Holder

    class CreateListViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateListViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateListViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"obj"), aname="_obj", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._obj = []
                    return
            Holder.__name__ = "CreateListViewRequestType_Holder"
            self.pyclass = Holder

    class CreateListViewFromViewRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CreateListViewFromViewRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.CreateListViewFromViewRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"view"), aname="_view", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._view = None
                    return
            Holder.__name__ = "CreateListViewFromViewRequestType_Holder"
            self.pyclass = Holder

    class VirtualMachineAffinityInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineAffinityInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineAffinityInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"affinitySet"), aname="_affinitySet", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineAffinityInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineAffinityInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineAffinityInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineBootOptions_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineBootOptions")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineBootOptions_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"bootDelay"), aname="_bootDelay", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enterBIOSSetup"), aname="_enterBIOSSetup", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineBootOptions_Def.__bases__:
                bases = list(ns0.VirtualMachineBootOptions_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineBootOptions_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineCapability_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineCapability")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineCapability_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"snapshotOperationsSupported"), aname="_snapshotOperationsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"multipleSnapshotsSupported"), aname="_multipleSnapshotsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"snapshotConfigSupported"), aname="_snapshotConfigSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"poweredOffSnapshotsSupported"), aname="_poweredOffSnapshotsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"memorySnapshotsSupported"), aname="_memorySnapshotsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"revertToSnapshotSupported"), aname="_revertToSnapshotSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"quiescedSnapshotsSupported"), aname="_quiescedSnapshotsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"disableSnapshotsSupported"), aname="_disableSnapshotsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"lockSnapshotsSupported"), aname="_lockSnapshotsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"consolePreferencesSupported"), aname="_consolePreferencesSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"cpuFeatureMaskSupported"), aname="_cpuFeatureMaskSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"s1AcpiManagementSupported"), aname="_s1AcpiManagementSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"settingScreenResolutionSupported"), aname="_settingScreenResolutionSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"toolsAutoUpdateSupported"), aname="_toolsAutoUpdateSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"vmNpivWwnSupported"), aname="_vmNpivWwnSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"npivWwnOnNonRdmVmSupported"), aname="_npivWwnOnNonRdmVmSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"swapPlacementSupported"), aname="_swapPlacementSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"toolsSyncTimeSupported"), aname="_toolsSyncTimeSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"virtualMmuUsageSupported"), aname="_virtualMmuUsageSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"diskSharesSupported"), aname="_diskSharesSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"bootOptionsSupported"), aname="_bootOptionsSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"settingVideoRamSizeSupported"), aname="_settingVideoRamSizeSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineCapability_Def.__bases__:
                bases = list(ns0.VirtualMachineCapability_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineCapability_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineCdromInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineCdromInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineCdromInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineCdromInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineCdromInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineCdromInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineCdromInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineCdromInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineCdromInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineCdromInfo",lazy=True)(pname=(ns,"VirtualMachineCdromInfo"), aname="_VirtualMachineCdromInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineCdromInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineCdromInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineCloneSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineCloneSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineCloneSpec_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineRelocateSpec",lazy=True)(pname=(ns,"location"), aname="_location", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"template"), aname="_template", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConfigSpec",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSpec",lazy=True)(pname=(ns,"customization"), aname="_customization", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"powerOn"), aname="_powerOn", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineCloneSpec_Def.__bases__:
                bases = list(ns0.VirtualMachineCloneSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineCloneSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineConfigInfoNpivWwnType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigInfoNpivWwnType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineConfigInfoSwapPlacementType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigInfoSwapPlacementType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineConfigInfoDatastoreUrlPair_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigInfoDatastoreUrlPair")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineConfigInfoDatastoreUrlPair_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"url"), aname="_url", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineConfigInfoDatastoreUrlPair_Def.__bases__:
                bases = list(ns0.VirtualMachineConfigInfoDatastoreUrlPair_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineConfigInfoDatastoreUrlPair_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineConfigInfoDatastoreUrlPair_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineConfigInfoDatastoreUrlPair")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineConfigInfoDatastoreUrlPair_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineConfigInfoDatastoreUrlPair",lazy=True)(pname=(ns,"VirtualMachineConfigInfoDatastoreUrlPair"), aname="_VirtualMachineConfigInfoDatastoreUrlPair", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineConfigInfoDatastoreUrlPair = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineConfigInfoDatastoreUrlPair_Holder"
            self.pyclass = Holder

    class VirtualMachineConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineConfigInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"changeVersion"), aname="_changeVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"modified"), aname="_modified", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestFullName"), aname="_guestFullName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"npivNodeWorldWideName"), aname="_npivNodeWorldWideName", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"npivPortWorldWideName"), aname="_npivPortWorldWideName", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"npivWorldWideNameType"), aname="_npivWorldWideNameType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locationId"), aname="_locationId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"template"), aname="_template", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestId"), aname="_guestId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"alternateGuestName"), aname="_alternateGuestName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"annotation"), aname="_annotation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineFileInfo",lazy=True)(pname=(ns,"files"), aname="_files", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ToolsConfigInfo",lazy=True)(pname=(ns,"tools"), aname="_tools", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineFlagInfo",lazy=True)(pname=(ns,"flags"), aname="_flags", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConsolePreferences",lazy=True)(pname=(ns,"consolePreferences"), aname="_consolePreferences", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineDefaultPowerOpInfo",lazy=True)(pname=(ns,"defaultPowerOps"), aname="_defaultPowerOps", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualHardware",lazy=True)(pname=(ns,"hardware"), aname="_hardware", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceAllocationInfo",lazy=True)(pname=(ns,"cpuAllocation"), aname="_cpuAllocation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceAllocationInfo",lazy=True)(pname=(ns,"memoryAllocation"), aname="_memoryAllocation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineAffinityInfo",lazy=True)(pname=(ns,"cpuAffinity"), aname="_cpuAffinity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineAffinityInfo",lazy=True)(pname=(ns,"memoryAffinity"), aname="_memoryAffinity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineNetworkShaperInfo",lazy=True)(pname=(ns,"networkShaper"), aname="_networkShaper", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"extraConfig"), aname="_extraConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostCpuIdInfo",lazy=True)(pname=(ns,"cpuFeatureMask"), aname="_cpuFeatureMask", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConfigInfoDatastoreUrlPair",lazy=True)(pname=(ns,"datastoreUrl"), aname="_datastoreUrl", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"swapPlacement"), aname="_swapPlacement", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineBootOptions",lazy=True)(pname=(ns,"bootOptions"), aname="_bootOptions", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineConfigInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineConfigOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineConfigOption_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","GuestOsDescriptor",lazy=True)(pname=(ns,"guestOSDescriptor"), aname="_guestOSDescriptor", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"guestOSDefaultIndex"), aname="_guestOSDefaultIndex", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualHardwareOption",lazy=True)(pname=(ns,"hardwareOptions"), aname="_hardwareOptions", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineCapability",lazy=True)(pname=(ns,"capabilities"), aname="_capabilities", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DatastoreOption",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDevice",lazy=True)(pname=(ns,"defaultDevice"), aname="_defaultDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"supportedMonitorType"), aname="_supportedMonitorType", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineConfigOption_Def.__bases__:
                bases = list(ns0.VirtualMachineConfigOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineConfigOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineConfigOptionDescriptor_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigOptionDescriptor")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineConfigOptionDescriptor_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineConfigOptionDescriptor_Def.__bases__:
                bases = list(ns0.VirtualMachineConfigOptionDescriptor_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineConfigOptionDescriptor_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineConfigOptionDescriptor_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineConfigOptionDescriptor")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineConfigOptionDescriptor_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineConfigOptionDescriptor",lazy=True)(pname=(ns,"VirtualMachineConfigOptionDescriptor"), aname="_VirtualMachineConfigOptionDescriptor", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineConfigOptionDescriptor = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineConfigOptionDescriptor_Holder"
            self.pyclass = Holder

    class VirtualMachineConfigSpecNpivWwnOp_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigSpecNpivWwnOp")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineCpuIdInfoSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineCpuIdInfoSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineCpuIdInfoSpec_Def.schema
            TClist = [GTD("urn:vim25","HostCpuIdInfo",lazy=True)(pname=(ns,"info"), aname="_info", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.ArrayUpdateSpec_Def not in ns0.VirtualMachineCpuIdInfoSpec_Def.__bases__:
                bases = list(ns0.VirtualMachineCpuIdInfoSpec_Def.__bases__)
                bases.insert(0, ns0.ArrayUpdateSpec_Def)
                ns0.VirtualMachineCpuIdInfoSpec_Def.__bases__ = tuple(bases)

            ns0.ArrayUpdateSpec_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineCpuIdInfoSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineCpuIdInfoSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineCpuIdInfoSpec_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineCpuIdInfoSpec",lazy=True)(pname=(ns,"VirtualMachineCpuIdInfoSpec"), aname="_VirtualMachineCpuIdInfoSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineCpuIdInfoSpec = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineCpuIdInfoSpec_Holder"
            self.pyclass = Holder

    class VirtualMachineConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineConfigSpec_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"changeVersion"), aname="_changeVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"version"), aname="_version", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"npivNodeWorldWideName"), aname="_npivNodeWorldWideName", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"npivPortWorldWideName"), aname="_npivPortWorldWideName", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"npivWorldWideNameType"), aname="_npivWorldWideNameType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"npivWorldWideNameOp"), aname="_npivWorldWideNameOp", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"locationId"), aname="_locationId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestId"), aname="_guestId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"alternateGuestName"), aname="_alternateGuestName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"annotation"), aname="_annotation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineFileInfo",lazy=True)(pname=(ns,"files"), aname="_files", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ToolsConfigInfo",lazy=True)(pname=(ns,"tools"), aname="_tools", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineFlagInfo",lazy=True)(pname=(ns,"flags"), aname="_flags", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConsolePreferences",lazy=True)(pname=(ns,"consolePreferences"), aname="_consolePreferences", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineDefaultPowerOpInfo",lazy=True)(pname=(ns,"powerOpInfo"), aname="_powerOpInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numCPUs"), aname="_numCPUs", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memoryMB"), aname="_memoryMB", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceConfigSpec",lazy=True)(pname=(ns,"deviceChange"), aname="_deviceChange", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceAllocationInfo",lazy=True)(pname=(ns,"cpuAllocation"), aname="_cpuAllocation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourceAllocationInfo",lazy=True)(pname=(ns,"memoryAllocation"), aname="_memoryAllocation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineAffinityInfo",lazy=True)(pname=(ns,"cpuAffinity"), aname="_cpuAffinity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineAffinityInfo",lazy=True)(pname=(ns,"memoryAffinity"), aname="_memoryAffinity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineNetworkShaperInfo",lazy=True)(pname=(ns,"networkShaper"), aname="_networkShaper", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineCpuIdInfoSpec",lazy=True)(pname=(ns,"cpuFeatureMask"), aname="_cpuFeatureMask", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"extraConfig"), aname="_extraConfig", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"swapPlacement"), aname="_swapPlacement", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineBootOptions",lazy=True)(pname=(ns,"bootOptions"), aname="_bootOptions", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineConfigSpec_Def.__bases__:
                bases = list(ns0.VirtualMachineConfigSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineConfigSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ConfigTarget_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ConfigTarget")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ConfigTarget_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"numCpus"), aname="_numCpus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numCpuCores"), aname="_numCpuCores", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numNumaNodes"), aname="_numNumaNodes", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineDatastoreInfo",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineNetworkInfo",lazy=True)(pname=(ns,"network"), aname="_network", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineCdromInfo",lazy=True)(pname=(ns,"cdRom"), aname="_cdRom", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineSerialInfo",lazy=True)(pname=(ns,"serial"), aname="_serial", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineParallelInfo",lazy=True)(pname=(ns,"parallel"), aname="_parallel", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineSoundInfo",lazy=True)(pname=(ns,"sound"), aname="_sound", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineUsbInfo",lazy=True)(pname=(ns,"usb"), aname="_usb", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineFloppyInfo",lazy=True)(pname=(ns,"floppy"), aname="_floppy", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineLegacyNetworkSwitchInfo",lazy=True)(pname=(ns,"legacyNetworkInfo"), aname="_legacyNetworkInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineScsiPassthroughInfo",lazy=True)(pname=(ns,"scsiPassthrough"), aname="_scsiPassthrough", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineScsiDiskDeviceInfo",lazy=True)(pname=(ns,"scsiDisk"), aname="_scsiDisk", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineIdeDiskDeviceInfo",lazy=True)(pname=(ns,"ideDisk"), aname="_ideDisk", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxMemMBOptimalPerf"), aname="_maxMemMBOptimalPerf", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ResourcePoolRuntimeInfo",lazy=True)(pname=(ns,"resourcePool"), aname="_resourcePool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"autoVmotion"), aname="_autoVmotion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ConfigTarget_Def.__bases__:
                bases = list(ns0.ConfigTarget_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ConfigTarget_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineConsolePreferences_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConsolePreferences")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineConsolePreferences_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"powerOnWhenOpened"), aname="_powerOnWhenOpened", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enterFullScreenOnPowerOn"), aname="_enterFullScreenOnPowerOn", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"closeOnPowerOffOrSuspend"), aname="_closeOnPowerOffOrSuspend", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineConsolePreferences_Def.__bases__:
                bases = list(ns0.VirtualMachineConsolePreferences_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineConsolePreferences_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineDatastoreInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineDatastoreInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineDatastoreInfo_Def.schema
            TClist = [GTD("urn:vim25","DatastoreSummary",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","DatastoreCapability",lazy=True)(pname=(ns,"capability"), aname="_capability", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"maxFileSize"), aname="_maxFileSize", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"mode"), aname="_mode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineDatastoreInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineDatastoreInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineDatastoreInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineDatastoreInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineDatastoreInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineDatastoreInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineDatastoreInfo",lazy=True)(pname=(ns,"VirtualMachineDatastoreInfo"), aname="_VirtualMachineDatastoreInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineDatastoreInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineDatastoreInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineDatastoreVolumeOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineDatastoreVolumeOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineDatastoreVolumeOption_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"fileSystemType"), aname="_fileSystemType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"majorVersion"), aname="_majorVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineDatastoreVolumeOption_Def.__bases__:
                bases = list(ns0.VirtualMachineDatastoreVolumeOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineDatastoreVolumeOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineDatastoreVolumeOption_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineDatastoreVolumeOption")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineDatastoreVolumeOption_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineDatastoreVolumeOption",lazy=True)(pname=(ns,"VirtualMachineDatastoreVolumeOption"), aname="_VirtualMachineDatastoreVolumeOption", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineDatastoreVolumeOption = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineDatastoreVolumeOption_Holder"
            self.pyclass = Holder

    class DatastoreOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "DatastoreOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.DatastoreOption_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineDatastoreVolumeOption",lazy=True)(pname=(ns,"unsupportedVolumes"), aname="_unsupportedVolumes", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.DatastoreOption_Def.__bases__:
                bases = list(ns0.DatastoreOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.DatastoreOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachinePowerOpType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachinePowerOpType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineStandbyActionType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineStandbyActionType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineDefaultPowerOpInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineDefaultPowerOpInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineDefaultPowerOpInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"powerOffType"), aname="_powerOffType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"suspendType"), aname="_suspendType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"resetType"), aname="_resetType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"defaultPowerOffType"), aname="_defaultPowerOffType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"defaultSuspendType"), aname="_defaultSuspendType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"defaultResetType"), aname="_defaultResetType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"standbyAction"), aname="_standbyAction", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineDefaultPowerOpInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineDefaultPowerOpInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineDefaultPowerOpInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineDiskDeviceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineDiskDeviceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineDiskDeviceInfo_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"capacity"), aname="_capacity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineDiskDeviceInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineDiskDeviceInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineDiskDeviceInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineFileInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFileInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineFileInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"vmPathName"), aname="_vmPathName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"snapshotDirectory"), aname="_snapshotDirectory", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"suspendDirectory"), aname="_suspendDirectory", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"logDirectory"), aname="_logDirectory", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineFileInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineFileInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineFileInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineFileLayoutDiskLayout_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFileLayoutDiskLayout")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineFileLayoutDiskLayout_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diskFile"), aname="_diskFile", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineFileLayoutDiskLayout_Def.__bases__:
                bases = list(ns0.VirtualMachineFileLayoutDiskLayout_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineFileLayoutDiskLayout_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineFileLayoutDiskLayout_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineFileLayoutDiskLayout")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineFileLayoutDiskLayout_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineFileLayoutDiskLayout",lazy=True)(pname=(ns,"VirtualMachineFileLayoutDiskLayout"), aname="_VirtualMachineFileLayoutDiskLayout", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineFileLayoutDiskLayout = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineFileLayoutDiskLayout_Holder"
            self.pyclass = Holder

    class VirtualMachineFileLayoutSnapshotLayout_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFileLayoutSnapshotLayout")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineFileLayoutSnapshotLayout_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"snapshotFile"), aname="_snapshotFile", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineFileLayoutSnapshotLayout_Def.__bases__:
                bases = list(ns0.VirtualMachineFileLayoutSnapshotLayout_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineFileLayoutSnapshotLayout_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineFileLayoutSnapshotLayout_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineFileLayoutSnapshotLayout")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineFileLayoutSnapshotLayout_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineFileLayoutSnapshotLayout",lazy=True)(pname=(ns,"VirtualMachineFileLayoutSnapshotLayout"), aname="_VirtualMachineFileLayoutSnapshotLayout", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineFileLayoutSnapshotLayout = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineFileLayoutSnapshotLayout_Holder"
            self.pyclass = Holder

    class VirtualMachineFileLayout_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFileLayout")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineFileLayout_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"configFile"), aname="_configFile", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"logFile"), aname="_logFile", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineFileLayoutDiskLayout",lazy=True)(pname=(ns,"disk"), aname="_disk", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineFileLayoutSnapshotLayout",lazy=True)(pname=(ns,"snapshot"), aname="_snapshot", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"swapFile"), aname="_swapFile", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineFileLayout_Def.__bases__:
                bases = list(ns0.VirtualMachineFileLayout_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineFileLayout_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineHtSharing_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineHtSharing")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachinePowerOffBehavior_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachinePowerOffBehavior")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineFlagInfoMonitorType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFlagInfoMonitorType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineFlagInfoVirtualMmuUsage_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFlagInfoVirtualMmuUsage")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineFlagInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFlagInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineFlagInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"disableAcceleration"), aname="_disableAcceleration", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"enableLogging"), aname="_enableLogging", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"useToe"), aname="_useToe", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"runWithDebugInfo"), aname="_runWithDebugInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"monitorType"), aname="_monitorType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"htSharing"), aname="_htSharing", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"snapshotDisabled"), aname="_snapshotDisabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"snapshotLocked"), aname="_snapshotLocked", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"diskUuidEnabled"), aname="_diskUuidEnabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"virtualMmuUsage"), aname="_virtualMmuUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"snapshotPowerOffBehavior"), aname="_snapshotPowerOffBehavior", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineFlagInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineFlagInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineFlagInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineFloppyInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineFloppyInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineFloppyInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineFloppyInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineFloppyInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineFloppyInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineFloppyInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineFloppyInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineFloppyInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineFloppyInfo",lazy=True)(pname=(ns,"VirtualMachineFloppyInfo"), aname="_VirtualMachineFloppyInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineFloppyInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineFloppyInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineToolsStatus_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineToolsStatus")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class GuestDiskInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GuestDiskInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GuestDiskInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskPath"), aname="_diskPath", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"capacity"), aname="_capacity", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"freeSpace"), aname="_freeSpace", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.GuestDiskInfo_Def.__bases__:
                bases = list(ns0.GuestDiskInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.GuestDiskInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfGuestDiskInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfGuestDiskInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfGuestDiskInfo_Def.schema
            TClist = [GTD("urn:vim25","GuestDiskInfo",lazy=True)(pname=(ns,"GuestDiskInfo"), aname="_GuestDiskInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._GuestDiskInfo = []
                    return
            Holder.__name__ = "ArrayOfGuestDiskInfo_Holder"
            self.pyclass = Holder

    class GuestNicInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GuestNicInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GuestNicInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"network"), aname="_network", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"macAddress"), aname="_macAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"connected"), aname="_connected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"deviceConfigId"), aname="_deviceConfigId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.GuestNicInfo_Def.__bases__:
                bases = list(ns0.GuestNicInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.GuestNicInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfGuestNicInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfGuestNicInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfGuestNicInfo_Def.schema
            TClist = [GTD("urn:vim25","GuestNicInfo",lazy=True)(pname=(ns,"GuestNicInfo"), aname="_GuestNicInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._GuestNicInfo = []
                    return
            Holder.__name__ = "ArrayOfGuestNicInfo_Holder"
            self.pyclass = Holder

    class GuestScreenInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GuestScreenInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GuestScreenInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"width"), aname="_width", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"height"), aname="_height", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.GuestScreenInfo_Def.__bases__:
                bases = list(ns0.GuestScreenInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.GuestScreenInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineGuestState_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineGuestState")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class GuestInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GuestInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GuestInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineToolsStatus",lazy=True)(pname=(ns,"toolsStatus"), aname="_toolsStatus", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"toolsVersion"), aname="_toolsVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestId"), aname="_guestId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestFamily"), aname="_guestFamily", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestFullName"), aname="_guestFullName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"hostName"), aname="_hostName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","GuestNicInfo",lazy=True)(pname=(ns,"net"), aname="_net", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","GuestDiskInfo",lazy=True)(pname=(ns,"disk"), aname="_disk", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","GuestScreenInfo",lazy=True)(pname=(ns,"screen"), aname="_screen", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestState"), aname="_guestState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.GuestInfo_Def.__bases__:
                bases = list(ns0.GuestInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.GuestInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineGuestOsFamily_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineGuestOsFamily")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineGuestOsIdentifier_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineGuestOsIdentifier")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class GuestOsDescriptor_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "GuestOsDescriptor")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.GuestOsDescriptor_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"family"), aname="_family", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fullName"), aname="_fullName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"supportedMaxCPUs"), aname="_supportedMaxCPUs", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"supportedMinMemMB"), aname="_supportedMinMemMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"supportedMaxMemMB"), aname="_supportedMaxMemMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"recommendedMemMB"), aname="_recommendedMemMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"recommendedColorDepth"), aname="_recommendedColorDepth", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"supportedDiskControllerList"), aname="_supportedDiskControllerList", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"recommendedSCSIController"), aname="_recommendedSCSIController", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"recommendedDiskController"), aname="_recommendedDiskController", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"supportedNumDisks"), aname="_supportedNumDisks", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"recommendedDiskSizeMB"), aname="_recommendedDiskSizeMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"supportedEthernetCard"), aname="_supportedEthernetCard", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"recommendedEthernetCard"), aname="_recommendedEthernetCard", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"supportsSlaveDisk"), aname="_supportsSlaveDisk", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","HostCpuIdInfo",lazy=True)(pname=(ns,"cpuFeatureMask"), aname="_cpuFeatureMask", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"supportsWakeOnLan"), aname="_supportsWakeOnLan", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.GuestOsDescriptor_Def.__bases__:
                bases = list(ns0.GuestOsDescriptor_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.GuestOsDescriptor_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfGuestOsDescriptor_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfGuestOsDescriptor")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfGuestOsDescriptor_Def.schema
            TClist = [GTD("urn:vim25","GuestOsDescriptor",lazy=True)(pname=(ns,"GuestOsDescriptor"), aname="_GuestOsDescriptor", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._GuestOsDescriptor = []
                    return
            Holder.__name__ = "ArrayOfGuestOsDescriptor_Holder"
            self.pyclass = Holder

    class VirtualMachineIdeDiskDevicePartitionInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineIdeDiskDevicePartitionInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineIdeDiskDevicePartitionInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"capacity"), aname="_capacity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineIdeDiskDevicePartitionInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineIdeDiskDevicePartitionInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineIdeDiskDevicePartitionInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineIdeDiskDevicePartitionInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineIdeDiskDevicePartitionInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineIdeDiskDevicePartitionInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineIdeDiskDevicePartitionInfo",lazy=True)(pname=(ns,"VirtualMachineIdeDiskDevicePartitionInfo"), aname="_VirtualMachineIdeDiskDevicePartitionInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineIdeDiskDevicePartitionInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineIdeDiskDevicePartitionInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineIdeDiskDeviceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineIdeDiskDeviceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineIdeDiskDeviceInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineIdeDiskDevicePartitionInfo",lazy=True)(pname=(ns,"partitionTable"), aname="_partitionTable", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineDiskDeviceInfo_Def not in ns0.VirtualMachineIdeDiskDeviceInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineIdeDiskDeviceInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineDiskDeviceInfo_Def)
                ns0.VirtualMachineIdeDiskDeviceInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineDiskDeviceInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineIdeDiskDeviceInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineIdeDiskDeviceInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineIdeDiskDeviceInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineIdeDiskDeviceInfo",lazy=True)(pname=(ns,"VirtualMachineIdeDiskDeviceInfo"), aname="_VirtualMachineIdeDiskDeviceInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineIdeDiskDeviceInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineIdeDiskDeviceInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineLegacyNetworkSwitchInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineLegacyNetworkSwitchInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineLegacyNetworkSwitchInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineLegacyNetworkSwitchInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineLegacyNetworkSwitchInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineLegacyNetworkSwitchInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineLegacyNetworkSwitchInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineLegacyNetworkSwitchInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineLegacyNetworkSwitchInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineLegacyNetworkSwitchInfo",lazy=True)(pname=(ns,"VirtualMachineLegacyNetworkSwitchInfo"), aname="_VirtualMachineLegacyNetworkSwitchInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineLegacyNetworkSwitchInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineLegacyNetworkSwitchInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineMessage_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineMessage")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineMessage_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.AnyType(pname=(ns,"argument"), aname="_argument", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineMessage_Def.__bases__:
                bases = list(ns0.VirtualMachineMessage_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineMessage_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineMessage_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineMessage")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineMessage_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineMessage",lazy=True)(pname=(ns,"VirtualMachineMessage"), aname="_VirtualMachineMessage", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineMessage = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineMessage_Holder"
            self.pyclass = Holder

    class VirtualMachineNetworkInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineNetworkInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineNetworkInfo_Def.schema
            TClist = [GTD("urn:vim25","NetworkSummary",lazy=True)(pname=(ns,"network"), aname="_network", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineNetworkInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineNetworkInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineNetworkInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineNetworkInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineNetworkInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineNetworkInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineNetworkInfo",lazy=True)(pname=(ns,"VirtualMachineNetworkInfo"), aname="_VirtualMachineNetworkInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineNetworkInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineNetworkInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineNetworkShaperInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineNetworkShaperInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineNetworkShaperInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"enabled"), aname="_enabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"peakBps"), aname="_peakBps", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"averageBps"), aname="_averageBps", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"burstSize"), aname="_burstSize", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineNetworkShaperInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineNetworkShaperInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineNetworkShaperInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineParallelInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineParallelInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineParallelInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineParallelInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineParallelInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineParallelInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineParallelInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineParallelInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineParallelInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineParallelInfo",lazy=True)(pname=(ns,"VirtualMachineParallelInfo"), aname="_VirtualMachineParallelInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineParallelInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineParallelInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineQuestionInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineQuestionInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineQuestionInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"id"), aname="_id", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"text"), aname="_text", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"choice"), aname="_choice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineMessage",lazy=True)(pname=(ns,"message"), aname="_message", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineQuestionInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineQuestionInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineQuestionInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineRelocateTransformation_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineRelocateTransformation")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineRelocateSpecDiskLocator_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineRelocateSpecDiskLocator")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineRelocateSpecDiskLocator_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"diskId"), aname="_diskId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineRelocateSpecDiskLocator_Def.__bases__:
                bases = list(ns0.VirtualMachineRelocateSpecDiskLocator_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineRelocateSpecDiskLocator_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineRelocateSpecDiskLocator_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineRelocateSpecDiskLocator")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineRelocateSpecDiskLocator_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineRelocateSpecDiskLocator",lazy=True)(pname=(ns,"VirtualMachineRelocateSpecDiskLocator"), aname="_VirtualMachineRelocateSpecDiskLocator", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineRelocateSpecDiskLocator = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineRelocateSpecDiskLocator_Holder"
            self.pyclass = Holder

    class VirtualMachineRelocateSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineRelocateSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineRelocateSpec_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"pool"), aname="_pool", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineRelocateSpecDiskLocator",lazy=True)(pname=(ns,"disk"), aname="_disk", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineRelocateTransformation",lazy=True)(pname=(ns,"transform"), aname="_transform", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineRelocateSpec_Def.__bases__:
                bases = list(ns0.VirtualMachineRelocateSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineRelocateSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineRuntimeInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineRuntimeInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineRuntimeInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConnectionState",lazy=True)(pname=(ns,"connectionState"), aname="_connectionState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachinePowerState",lazy=True)(pname=(ns,"powerState"), aname="_powerState", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"toolsInstallerMounted"), aname="_toolsInstallerMounted", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"suspendTime"), aname="_suspendTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"bootTime"), aname="_bootTime", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"suspendInterval"), aname="_suspendInterval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineQuestionInfo",lazy=True)(pname=(ns,"question"), aname="_question", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"memoryOverhead"), aname="_memoryOverhead", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxCpuUsage"), aname="_maxCpuUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"maxMemoryUsage"), aname="_maxMemoryUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numMksConnections"), aname="_numMksConnections", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineRuntimeInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineRuntimeInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineRuntimeInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineScsiDiskDeviceInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineScsiDiskDeviceInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineScsiDiskDeviceInfo_Def.schema
            TClist = [GTD("urn:vim25","HostScsiDisk",lazy=True)(pname=(ns,"disk"), aname="_disk", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineDiskDeviceInfo_Def not in ns0.VirtualMachineScsiDiskDeviceInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineScsiDiskDeviceInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineDiskDeviceInfo_Def)
                ns0.VirtualMachineScsiDiskDeviceInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineDiskDeviceInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineScsiDiskDeviceInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineScsiDiskDeviceInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineScsiDiskDeviceInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineScsiDiskDeviceInfo",lazy=True)(pname=(ns,"VirtualMachineScsiDiskDeviceInfo"), aname="_VirtualMachineScsiDiskDeviceInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineScsiDiskDeviceInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineScsiDiskDeviceInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineScsiPassthroughType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineScsiPassthroughType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineScsiPassthroughInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineScsiPassthroughInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineScsiPassthroughInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"scsiClass"), aname="_scsiClass", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vendor"), aname="_vendor", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"physicalUnitNumber"), aname="_physicalUnitNumber", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineScsiPassthroughInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineScsiPassthroughInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineScsiPassthroughInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineScsiPassthroughInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineScsiPassthroughInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineScsiPassthroughInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineScsiPassthroughInfo",lazy=True)(pname=(ns,"VirtualMachineScsiPassthroughInfo"), aname="_VirtualMachineScsiPassthroughInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineScsiPassthroughInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineScsiPassthroughInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineSerialInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineSerialInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineSerialInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineSerialInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineSerialInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineSerialInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineSerialInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineSerialInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineSerialInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineSerialInfo",lazy=True)(pname=(ns,"VirtualMachineSerialInfo"), aname="_VirtualMachineSerialInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineSerialInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineSerialInfo_Holder"
            self.pyclass = Holder

    class RevertToSnapshotRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RevertToSnapshotRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RevertToSnapshotRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"host"), aname="_host", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._host = None
                    return
            Holder.__name__ = "RevertToSnapshotRequestType_Holder"
            self.pyclass = Holder

    class RemoveSnapshotRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RemoveSnapshotRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RemoveSnapshotRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"removeChildren"), aname="_removeChildren", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._removeChildren = None
                    return
            Holder.__name__ = "RemoveSnapshotRequestType_Holder"
            self.pyclass = Holder

    class RenameSnapshotRequestType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "RenameSnapshotRequestType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.RenameSnapshotRequestType_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"_this"), aname="__this", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self.__this = None
                    self._name = None
                    self._description = None
                    return
            Holder.__name__ = "RenameSnapshotRequestType_Holder"
            self.pyclass = Holder

    class VirtualMachineSnapshotInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineSnapshotInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineSnapshotInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"currentSnapshot"), aname="_currentSnapshot", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineSnapshotTree",lazy=True)(pname=(ns,"rootSnapshotList"), aname="_rootSnapshotList", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineSnapshotInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineSnapshotInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineSnapshotInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineSnapshotTree_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineSnapshotTree")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineSnapshotTree_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"snapshot"), aname="_snapshot", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCtimes.gDateTime(pname=(ns,"createTime"), aname="_createTime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachinePowerState",lazy=True)(pname=(ns,"state"), aname="_state", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"quiesced"), aname="_quiesced", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineSnapshotTree",lazy=True)(pname=(ns,"childSnapshotList"), aname="_childSnapshotList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineSnapshotTree_Def.__bases__:
                bases = list(ns0.VirtualMachineSnapshotTree_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineSnapshotTree_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineSnapshotTree_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineSnapshotTree")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineSnapshotTree_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineSnapshotTree",lazy=True)(pname=(ns,"VirtualMachineSnapshotTree"), aname="_VirtualMachineSnapshotTree", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineSnapshotTree = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineSnapshotTree_Holder"
            self.pyclass = Holder

    class VirtualMachineSoundInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineSoundInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineSoundInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineSoundInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineSoundInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineSoundInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineSoundInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineSoundInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineSoundInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineSoundInfo",lazy=True)(pname=(ns,"VirtualMachineSoundInfo"), aname="_VirtualMachineSoundInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineSoundInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineSoundInfo_Holder"
            self.pyclass = Holder

    class VirtualMachineConfigSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineConfigSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineConfigSummary_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"template"), aname="_template", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"vmPathName"), aname="_vmPathName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"memorySizeMB"), aname="_memorySizeMB", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"cpuReservation"), aname="_cpuReservation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"memoryReservation"), aname="_memoryReservation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numCpu"), aname="_numCpu", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numEthernetCards"), aname="_numEthernetCards", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numVirtualDisks"), aname="_numVirtualDisks", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestId"), aname="_guestId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestFullName"), aname="_guestFullName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"annotation"), aname="_annotation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineConfigSummary_Def.__bases__:
                bases = list(ns0.VirtualMachineConfigSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineConfigSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineQuickStats_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineQuickStats")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineQuickStats_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"overallCpuUsage"), aname="_overallCpuUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"guestMemoryUsage"), aname="_guestMemoryUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"hostMemoryUsage"), aname="_hostMemoryUsage", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityStatus",lazy=True)(pname=(ns,"guestHeartbeatStatus"), aname="_guestHeartbeatStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"distributedCpuEntitlement"), aname="_distributedCpuEntitlement", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"distributedMemoryEntitlement"), aname="_distributedMemoryEntitlement", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineQuickStats_Def.__bases__:
                bases = list(ns0.VirtualMachineQuickStats_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineQuickStats_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineGuestSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineGuestSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineGuestSummary_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"guestId"), aname="_guestId", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"guestFullName"), aname="_guestFullName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineToolsStatus",lazy=True)(pname=(ns,"toolsStatus"), aname="_toolsStatus", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"hostName"), aname="_hostName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineGuestSummary_Def.__bases__:
                bases = list(ns0.VirtualMachineGuestSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineGuestSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineSummary_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineSummary")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineSummary_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"vm"), aname="_vm", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineRuntimeInfo",lazy=True)(pname=(ns,"runtime"), aname="_runtime", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineGuestSummary",lazy=True)(pname=(ns,"guest"), aname="_guest", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineConfigSummary",lazy=True)(pname=(ns,"config"), aname="_config", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineQuickStats",lazy=True)(pname=(ns,"quickStats"), aname="_quickStats", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedEntityStatus",lazy=True)(pname=(ns,"overallStatus"), aname="_overallStatus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomFieldValue",lazy=True)(pname=(ns,"customValue"), aname="_customValue", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineSummary_Def.__bases__:
                bases = list(ns0.VirtualMachineSummary_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineSummary_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineSummary_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineSummary")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineSummary_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineSummary",lazy=True)(pname=(ns,"VirtualMachineSummary"), aname="_VirtualMachineSummary", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineSummary = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineSummary_Holder"
            self.pyclass = Holder

    class VirtualMachineTargetInfoConfigurationTag_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineTargetInfoConfigurationTag")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineTargetInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineTargetInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineTargetInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"configurationTag"), aname="_configurationTag", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualMachineTargetInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineTargetInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualMachineTargetInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class UpgradePolicy_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "UpgradePolicy")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ToolsConfigInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "ToolsConfigInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.ToolsConfigInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"toolsVersion"), aname="_toolsVersion", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"afterPowerOn"), aname="_afterPowerOn", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"afterResume"), aname="_afterResume", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"beforeGuestStandby"), aname="_beforeGuestStandby", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"beforeGuestShutdown"), aname="_beforeGuestShutdown", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"beforeGuestReboot"), aname="_beforeGuestReboot", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"toolsUpgradePolicy"), aname="_toolsUpgradePolicy", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"pendingCustomization"), aname="_pendingCustomization", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"syncTimeWithHost"), aname="_syncTimeWithHost", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.ToolsConfigInfo_Def.__bases__:
                bases = list(ns0.ToolsConfigInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.ToolsConfigInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineUsbInfoSpeed_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineUsbInfoSpeed")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineUsbInfoFamily_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualMachineUsbInfoFamily")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualMachineUsbInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineUsbInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineUsbInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"description"), aname="_description", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"vendor"), aname="_vendor", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"product"), aname="_product", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"physicalPath"), aname="_physicalPath", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"family"), aname="_family", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"speed"), aname="_speed", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualMachineSummary",lazy=True)(pname=(ns,"summary"), aname="_summary", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualMachineTargetInfo_Def not in ns0.VirtualMachineUsbInfo_Def.__bases__:
                bases = list(ns0.VirtualMachineUsbInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualMachineTargetInfo_Def)
                ns0.VirtualMachineUsbInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualMachineTargetInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualMachineUsbInfo_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualMachineUsbInfo")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualMachineUsbInfo_Def.schema
            TClist = [GTD("urn:vim25","VirtualMachineUsbInfo",lazy=True)(pname=(ns,"VirtualMachineUsbInfo"), aname="_VirtualMachineUsbInfo", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualMachineUsbInfo = []
                    return
            Holder.__name__ = "ArrayOfVirtualMachineUsbInfo_Holder"
            self.pyclass = Holder

    class VirtualHardware_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualHardware")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualHardware_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"numCPU"), aname="_numCPU", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"memoryMB"), aname="_memoryMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDevice",lazy=True)(pname=(ns,"device"), aname="_device", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualHardware_Def.__bases__:
                bases = list(ns0.VirtualHardware_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualHardware_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualHardwareOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualHardwareOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualHardwareOption_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"hwVersion"), aname="_hwVersion", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceOption",lazy=True)(pname=(ns,"virtualDeviceOption"), aname="_virtualDeviceOption", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"deviceListReadonly"), aname="_deviceListReadonly", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"numCPU"), aname="_numCPU", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"numCpuReadonly"), aname="_numCpuReadonly", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","LongOption",lazy=True)(pname=(ns,"memoryMB"), aname="_memoryMB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numPCIControllers"), aname="_numPCIControllers", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numIDEControllers"), aname="_numIDEControllers", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numUSBControllers"), aname="_numUSBControllers", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numSIOControllers"), aname="_numSIOControllers", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numPS2Controllers"), aname="_numPS2Controllers", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"licensingLimit"), aname="_licensingLimit", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualHardwareOption_Def.__bases__:
                bases = list(ns0.VirtualHardwareOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualHardwareOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationSpec_Def.schema
            TClist = [GTD("urn:vim25","CustomizationOptions",lazy=True)(pname=(ns,"options"), aname="_options", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationIdentitySettings",lazy=True)(pname=(ns,"identity"), aname="_identity", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationGlobalIPSettings",lazy=True)(pname=(ns,"globalIPSettings"), aname="_globalIPSettings", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationAdapterMapping",lazy=True)(pname=(ns,"nicSettingMap"), aname="_nicSettingMap", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ibyte(pname=(ns,"encryptionKey"), aname="_encryptionKey", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationSpec_Def.__bases__:
                bases = list(ns0.CustomizationSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationName_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationName_Def.__bases__:
                bases = list(ns0.CustomizationName_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationName_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationFixedName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationFixedName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationFixedName_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationName_Def not in ns0.CustomizationFixedName_Def.__bases__:
                bases = list(ns0.CustomizationFixedName_Def.__bases__)
                bases.insert(0, ns0.CustomizationName_Def)
                ns0.CustomizationFixedName_Def.__bases__ = tuple(bases)

            ns0.CustomizationName_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationPrefixName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationPrefixName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationPrefixName_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"base"), aname="_base", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationName_Def not in ns0.CustomizationPrefixName_Def.__bases__:
                bases = list(ns0.CustomizationPrefixName_Def.__bases__)
                bases.insert(0, ns0.CustomizationName_Def)
                ns0.CustomizationPrefixName_Def.__bases__ = tuple(bases)

            ns0.CustomizationName_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationVirtualMachineName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationVirtualMachineName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationVirtualMachineName_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationName_Def not in ns0.CustomizationVirtualMachineName_Def.__bases__:
                bases = list(ns0.CustomizationVirtualMachineName_Def.__bases__)
                bases.insert(0, ns0.CustomizationName_Def)
                ns0.CustomizationVirtualMachineName_Def.__bases__ = tuple(bases)

            ns0.CustomizationName_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationUnknownName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationUnknownName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationUnknownName_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationName_Def not in ns0.CustomizationUnknownName_Def.__bases__:
                bases = list(ns0.CustomizationUnknownName_Def.__bases__)
                bases.insert(0, ns0.CustomizationName_Def)
                ns0.CustomizationUnknownName_Def.__bases__ = tuple(bases)

            ns0.CustomizationName_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationCustomName_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationCustomName")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationCustomName_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"argument"), aname="_argument", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationName_Def not in ns0.CustomizationCustomName_Def.__bases__:
                bases = list(ns0.CustomizationCustomName_Def.__bases__)
                bases.insert(0, ns0.CustomizationName_Def)
                ns0.CustomizationCustomName_Def.__bases__ = tuple(bases)

            ns0.CustomizationName_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationPassword_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationPassword")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationPassword_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"plainText"), aname="_plainText", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationPassword_Def.__bases__:
                bases = list(ns0.CustomizationPassword_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationPassword_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationOptions_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationOptions")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationOptions_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationOptions_Def.__bases__:
                bases = list(ns0.CustomizationOptions_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationOptions_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationSysprepRebootOption_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CustomizationSysprepRebootOption")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class CustomizationWinOptions_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationWinOptions")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationWinOptions_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"changeSID"), aname="_changeSID", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"deleteAccounts"), aname="_deleteAccounts", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationSysprepRebootOption",lazy=True)(pname=(ns,"reboot"), aname="_reboot", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationOptions_Def not in ns0.CustomizationWinOptions_Def.__bases__:
                bases = list(ns0.CustomizationWinOptions_Def.__bases__)
                bases.insert(0, ns0.CustomizationOptions_Def)
                ns0.CustomizationWinOptions_Def.__bases__ = tuple(bases)

            ns0.CustomizationOptions_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationLinuxOptions_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationLinuxOptions")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationLinuxOptions_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationOptions_Def not in ns0.CustomizationLinuxOptions_Def.__bases__:
                bases = list(ns0.CustomizationLinuxOptions_Def.__bases__)
                bases.insert(0, ns0.CustomizationOptions_Def)
                ns0.CustomizationLinuxOptions_Def.__bases__ = tuple(bases)

            ns0.CustomizationOptions_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationGuiUnattended_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationGuiUnattended")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationGuiUnattended_Def.schema
            TClist = [GTD("urn:vim25","CustomizationPassword",lazy=True)(pname=(ns,"password"), aname="_password", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"timeZone"), aname="_timeZone", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"autoLogon"), aname="_autoLogon", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"autoLogonCount"), aname="_autoLogonCount", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationGuiUnattended_Def.__bases__:
                bases = list(ns0.CustomizationGuiUnattended_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationGuiUnattended_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationUserData_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationUserData")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationUserData_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"fullName"), aname="_fullName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"orgName"), aname="_orgName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationName",lazy=True)(pname=(ns,"computerName"), aname="_computerName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"productId"), aname="_productId", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationUserData_Def.__bases__:
                bases = list(ns0.CustomizationUserData_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationUserData_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationGuiRunOnce_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationGuiRunOnce")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationGuiRunOnce_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"commandList"), aname="_commandList", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationGuiRunOnce_Def.__bases__:
                bases = list(ns0.CustomizationGuiRunOnce_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationGuiRunOnce_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationIdentification_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationIdentification")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationIdentification_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"joinWorkgroup"), aname="_joinWorkgroup", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"joinDomain"), aname="_joinDomain", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"domainAdmin"), aname="_domainAdmin", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationPassword",lazy=True)(pname=(ns,"domainAdminPassword"), aname="_domainAdminPassword", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationIdentification_Def.__bases__:
                bases = list(ns0.CustomizationIdentification_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationIdentification_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationLicenseDataMode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CustomizationLicenseDataMode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class CustomizationLicenseFilePrintData_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationLicenseFilePrintData")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationLicenseFilePrintData_Def.schema
            TClist = [GTD("urn:vim25","CustomizationLicenseDataMode",lazy=True)(pname=(ns,"autoMode"), aname="_autoMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"autoUsers"), aname="_autoUsers", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationLicenseFilePrintData_Def.__bases__:
                bases = list(ns0.CustomizationLicenseFilePrintData_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationLicenseFilePrintData_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationIdentitySettings_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationIdentitySettings")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationIdentitySettings_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationIdentitySettings_Def.__bases__:
                bases = list(ns0.CustomizationIdentitySettings_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationIdentitySettings_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationSysprepText_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationSysprepText")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationSysprepText_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"value"), aname="_value", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationIdentitySettings_Def not in ns0.CustomizationSysprepText_Def.__bases__:
                bases = list(ns0.CustomizationSysprepText_Def.__bases__)
                bases.insert(0, ns0.CustomizationIdentitySettings_Def)
                ns0.CustomizationSysprepText_Def.__bases__ = tuple(bases)

            ns0.CustomizationIdentitySettings_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationSysprep_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationSysprep")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationSysprep_Def.schema
            TClist = [GTD("urn:vim25","CustomizationGuiUnattended",lazy=True)(pname=(ns,"guiUnattended"), aname="_guiUnattended", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationUserData",lazy=True)(pname=(ns,"userData"), aname="_userData", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationGuiRunOnce",lazy=True)(pname=(ns,"guiRunOnce"), aname="_guiRunOnce", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationIdentification",lazy=True)(pname=(ns,"identification"), aname="_identification", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationLicenseFilePrintData",lazy=True)(pname=(ns,"licenseFilePrintData"), aname="_licenseFilePrintData", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationIdentitySettings_Def not in ns0.CustomizationSysprep_Def.__bases__:
                bases = list(ns0.CustomizationSysprep_Def.__bases__)
                bases.insert(0, ns0.CustomizationIdentitySettings_Def)
                ns0.CustomizationSysprep_Def.__bases__ = tuple(bases)

            ns0.CustomizationIdentitySettings_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationLinuxPrep_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationLinuxPrep")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationLinuxPrep_Def.schema
            TClist = [GTD("urn:vim25","CustomizationName",lazy=True)(pname=(ns,"hostName"), aname="_hostName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"domain"), aname="_domain", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationIdentitySettings_Def not in ns0.CustomizationLinuxPrep_Def.__bases__:
                bases = list(ns0.CustomizationLinuxPrep_Def.__bases__)
                bases.insert(0, ns0.CustomizationIdentitySettings_Def)
                ns0.CustomizationLinuxPrep_Def.__bases__ = tuple(bases)

            ns0.CustomizationIdentitySettings_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationGlobalIPSettings_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationGlobalIPSettings")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationGlobalIPSettings_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"dnsSuffixList"), aname="_dnsSuffixList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"dnsServerList"), aname="_dnsServerList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationGlobalIPSettings_Def.__bases__:
                bases = list(ns0.CustomizationGlobalIPSettings_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationGlobalIPSettings_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationNetBIOSMode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "CustomizationNetBIOSMode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class CustomizationIPSettings_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationIPSettings")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationIPSettings_Def.schema
            TClist = [GTD("urn:vim25","CustomizationIpGenerator",lazy=True)(pname=(ns,"ip"), aname="_ip", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"subnetMask"), aname="_subnetMask", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"gateway"), aname="_gateway", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"dnsServerList"), aname="_dnsServerList", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"dnsDomain"), aname="_dnsDomain", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"primaryWINS"), aname="_primaryWINS", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"secondaryWINS"), aname="_secondaryWINS", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationNetBIOSMode",lazy=True)(pname=(ns,"netBIOS"), aname="_netBIOS", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationIPSettings_Def.__bases__:
                bases = list(ns0.CustomizationIPSettings_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationIPSettings_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationIpGenerator_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationIpGenerator")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationIpGenerator_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationIpGenerator_Def.__bases__:
                bases = list(ns0.CustomizationIpGenerator_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationIpGenerator_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationDhcpIpGenerator_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationDhcpIpGenerator")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationDhcpIpGenerator_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationIpGenerator_Def not in ns0.CustomizationDhcpIpGenerator_Def.__bases__:
                bases = list(ns0.CustomizationDhcpIpGenerator_Def.__bases__)
                bases.insert(0, ns0.CustomizationIpGenerator_Def)
                ns0.CustomizationDhcpIpGenerator_Def.__bases__ = tuple(bases)

            ns0.CustomizationIpGenerator_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationFixedIp_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationFixedIp")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationFixedIp_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"ipAddress"), aname="_ipAddress", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationIpGenerator_Def not in ns0.CustomizationFixedIp_Def.__bases__:
                bases = list(ns0.CustomizationFixedIp_Def.__bases__)
                bases.insert(0, ns0.CustomizationIpGenerator_Def)
                ns0.CustomizationFixedIp_Def.__bases__ = tuple(bases)

            ns0.CustomizationIpGenerator_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationUnknownIpGenerator_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationUnknownIpGenerator")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationUnknownIpGenerator_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationIpGenerator_Def not in ns0.CustomizationUnknownIpGenerator_Def.__bases__:
                bases = list(ns0.CustomizationUnknownIpGenerator_Def.__bases__)
                bases.insert(0, ns0.CustomizationIpGenerator_Def)
                ns0.CustomizationUnknownIpGenerator_Def.__bases__ = tuple(bases)

            ns0.CustomizationIpGenerator_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationCustomIpGenerator_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationCustomIpGenerator")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationCustomIpGenerator_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"argument"), aname="_argument", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.CustomizationIpGenerator_Def not in ns0.CustomizationCustomIpGenerator_Def.__bases__:
                bases = list(ns0.CustomizationCustomIpGenerator_Def.__bases__)
                bases.insert(0, ns0.CustomizationIpGenerator_Def)
                ns0.CustomizationCustomIpGenerator_Def.__bases__ = tuple(bases)

            ns0.CustomizationIpGenerator_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class CustomizationAdapterMapping_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "CustomizationAdapterMapping")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.CustomizationAdapterMapping_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"macAddress"), aname="_macAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","CustomizationIPSettings",lazy=True)(pname=(ns,"adapter"), aname="_adapter", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.CustomizationAdapterMapping_Def.__bases__:
                bases = list(ns0.CustomizationAdapterMapping_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.CustomizationAdapterMapping_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfCustomizationAdapterMapping_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfCustomizationAdapterMapping")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfCustomizationAdapterMapping_Def.schema
            TClist = [GTD("urn:vim25","CustomizationAdapterMapping",lazy=True)(pname=(ns,"CustomizationAdapterMapping"), aname="_CustomizationAdapterMapping", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._CustomizationAdapterMapping = []
                    return
            Holder.__name__ = "ArrayOfCustomizationAdapterMapping_Holder"
            self.pyclass = Holder

    class HostDiskMappingPartitionInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskMappingPartitionInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskMappingPartitionInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fileSystem"), aname="_fileSystem", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"capacityInKb"), aname="_capacityInKb", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskMappingPartitionInfo_Def.__bases__:
                bases = list(ns0.HostDiskMappingPartitionInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskMappingPartitionInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiskMappingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskMappingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskMappingInfo_Def.schema
            TClist = [GTD("urn:vim25","HostDiskMappingPartitionInfo",lazy=True)(pname=(ns,"physicalPartition"), aname="_physicalPartition", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"exclusive"), aname="_exclusive", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskMappingInfo_Def.__bases__:
                bases = list(ns0.HostDiskMappingInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskMappingInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class HostDiskMappingPartitionOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskMappingPartitionOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskMappingPartitionOption_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"fileSystem"), aname="_fileSystem", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"capacityInKb"), aname="_capacityInKb", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskMappingPartitionOption_Def.__bases__:
                bases = list(ns0.HostDiskMappingPartitionOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskMappingPartitionOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfHostDiskMappingPartitionOption_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfHostDiskMappingPartitionOption")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfHostDiskMappingPartitionOption_Def.schema
            TClist = [GTD("urn:vim25","HostDiskMappingPartitionOption",lazy=True)(pname=(ns,"HostDiskMappingPartitionOption"), aname="_HostDiskMappingPartitionOption", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._HostDiskMappingPartitionOption = []
                    return
            Holder.__name__ = "ArrayOfHostDiskMappingPartitionOption_Holder"
            self.pyclass = Holder

    class HostDiskMappingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "HostDiskMappingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.HostDiskMappingOption_Def.schema
            TClist = [GTD("urn:vim25","HostDiskMappingPartitionOption",lazy=True)(pname=(ns,"physicalPartition"), aname="_physicalPartition", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"name"), aname="_name", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.HostDiskMappingOption_Def.__bases__:
                bases = list(ns0.HostDiskMappingOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.HostDiskMappingOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualBusLogicController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualBusLogicController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualBusLogicController_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSCSIController_Def not in ns0.VirtualBusLogicController_Def.__bases__:
                bases = list(ns0.VirtualBusLogicController_Def.__bases__)
                bases.insert(0, ns0.VirtualSCSIController_Def)
                ns0.VirtualBusLogicController_Def.__bases__ = tuple(bases)

            ns0.VirtualSCSIController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualBusLogicControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualBusLogicControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualBusLogicControllerOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSCSIControllerOption_Def not in ns0.VirtualBusLogicControllerOption_Def.__bases__:
                bases = list(ns0.VirtualBusLogicControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualSCSIControllerOption_Def)
                ns0.VirtualBusLogicControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualSCSIControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromIsoBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromIsoBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromIsoBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualCdromIsoBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualCdromIsoBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualCdromIsoBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromPassthroughBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromPassthroughBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromPassthroughBackingInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"exclusive"), aname="_exclusive", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualCdromPassthroughBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualCdromPassthroughBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualCdromPassthroughBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromRemotePassthroughBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromRemotePassthroughBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromRemotePassthroughBackingInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"exclusive"), aname="_exclusive", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceRemoteDeviceBackingInfo_Def not in ns0.VirtualCdromRemotePassthroughBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualCdromRemotePassthroughBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceRemoteDeviceBackingInfo_Def)
                ns0.VirtualCdromRemotePassthroughBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceRemoteDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromAtapiBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromAtapiBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromAtapiBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualCdromAtapiBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualCdromAtapiBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualCdromAtapiBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromRemoteAtapiBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromRemoteAtapiBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromRemoteAtapiBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceRemoteDeviceBackingInfo_Def not in ns0.VirtualCdromRemoteAtapiBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualCdromRemoteAtapiBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceRemoteDeviceBackingInfo_Def)
                ns0.VirtualCdromRemoteAtapiBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceRemoteDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdrom_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdrom")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdrom_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualCdrom_Def.__bases__:
                bases = list(ns0.VirtualCdrom_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualCdrom_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromIsoBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromIsoBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromIsoBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualCdromIsoBackingOption_Def.__bases__:
                bases = list(ns0.VirtualCdromIsoBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualCdromIsoBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromPassthroughBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromPassthroughBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromPassthroughBackingOption_Def.schema
            TClist = [GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"exclusive"), aname="_exclusive", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualCdromPassthroughBackingOption_Def.__bases__:
                bases = list(ns0.VirtualCdromPassthroughBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualCdromPassthroughBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromRemotePassthroughBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromRemotePassthroughBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromRemotePassthroughBackingOption_Def.schema
            TClist = [GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"exclusive"), aname="_exclusive", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceRemoteDeviceBackingOption_Def not in ns0.VirtualCdromRemotePassthroughBackingOption_Def.__bases__:
                bases = list(ns0.VirtualCdromRemotePassthroughBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceRemoteDeviceBackingOption_Def)
                ns0.VirtualCdromRemotePassthroughBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceRemoteDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromAtapiBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromAtapiBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromAtapiBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualCdromAtapiBackingOption_Def.__bases__:
                bases = list(ns0.VirtualCdromAtapiBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualCdromAtapiBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromRemoteAtapiBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromRemoteAtapiBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromRemoteAtapiBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualCdromRemoteAtapiBackingOption_Def.__bases__:
                bases = list(ns0.VirtualCdromRemoteAtapiBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualCdromRemoteAtapiBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualCdromOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualCdromOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualCdromOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualCdromOption_Def.__bases__:
                bases = list(ns0.VirtualCdromOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualCdromOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualController_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"busNumber"), aname="_busNumber", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"device"), aname="_device", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualController_Def.__bases__:
                bases = list(ns0.VirtualController_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualController_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualControllerOption_Def.schema
            TClist = [GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"devices"), aname="_devices", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"supportedDevice"), aname="_supportedDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualControllerOption_Def.__bases__:
                bases = list(ns0.VirtualControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceFileBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceFileBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceFileBackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"fileName"), aname="_fileName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"datastore"), aname="_datastore", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingInfo_Def not in ns0.VirtualDeviceFileBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDeviceFileBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingInfo_Def)
                ns0.VirtualDeviceFileBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceDeviceBackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"deviceName"), aname="_deviceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"useAutoDetect"), aname="_useAutoDetect", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingInfo_Def not in ns0.VirtualDeviceDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDeviceDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingInfo_Def)
                ns0.VirtualDeviceDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceRemoteDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceRemoteDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceRemoteDeviceBackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"deviceName"), aname="_deviceName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"useAutoDetect"), aname="_useAutoDetect", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingInfo_Def not in ns0.VirtualDeviceRemoteDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDeviceRemoteDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingInfo_Def)
                ns0.VirtualDeviceRemoteDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDevicePipeBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDevicePipeBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDevicePipeBackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"pipeName"), aname="_pipeName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingInfo_Def not in ns0.VirtualDevicePipeBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDevicePipeBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingInfo_Def)
                ns0.VirtualDevicePipeBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceConnectInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceConnectInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceConnectInfo_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"startConnected"), aname="_startConnected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"allowGuestControl"), aname="_allowGuestControl", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"connected"), aname="_connected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDeviceConnectInfo_Def.__bases__:
                bases = list(ns0.VirtualDeviceConnectInfo_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDeviceConnectInfo_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDevice_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDevice")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDevice_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"key"), aname="_key", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","Description",lazy=True)(pname=(ns,"deviceInfo"), aname="_deviceInfo", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceBackingInfo",lazy=True)(pname=(ns,"backing"), aname="_backing", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceConnectInfo",lazy=True)(pname=(ns,"connectable"), aname="_connectable", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"controllerKey"), aname="_controllerKey", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"unitNumber"), aname="_unitNumber", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDevice_Def.__bases__:
                bases = list(ns0.VirtualDevice_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDevice_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualDevice_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualDevice")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualDevice_Def.schema
            TClist = [GTD("urn:vim25","VirtualDevice",lazy=True)(pname=(ns,"VirtualDevice"), aname="_VirtualDevice", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualDevice = []
                    return
            Holder.__name__ = "ArrayOfVirtualDevice_Holder"
            self.pyclass = Holder

    class VirtualDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceBackingOption_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualDeviceBackingOption_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualDeviceBackingOption_Def.schema
            TClist = [GTD("urn:vim25","VirtualDeviceBackingOption",lazy=True)(pname=(ns,"VirtualDeviceBackingOption"), aname="_VirtualDeviceBackingOption", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualDeviceBackingOption = []
                    return
            Holder.__name__ = "ArrayOfVirtualDeviceBackingOption_Holder"
            self.pyclass = Holder

    class VirtualDeviceFileExtension_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceFileExtension")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualDeviceFileBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceFileBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceFileBackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"fileNameExtensions"), aname="_fileNameExtensions", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingOption_Def not in ns0.VirtualDeviceFileBackingOption_Def.__bases__:
                bases = list(ns0.VirtualDeviceFileBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingOption_Def)
                ns0.VirtualDeviceFileBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceDeviceBackingOption_Def.schema
            TClist = [GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"autoDetectAvailable"), aname="_autoDetectAvailable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingOption_Def not in ns0.VirtualDeviceDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualDeviceDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingOption_Def)
                ns0.VirtualDeviceDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceRemoteDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceRemoteDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceRemoteDeviceBackingOption_Def.schema
            TClist = [GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"autoDetectAvailable"), aname="_autoDetectAvailable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingOption_Def not in ns0.VirtualDeviceRemoteDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualDeviceRemoteDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingOption_Def)
                ns0.VirtualDeviceRemoteDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDevicePipeBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDevicePipeBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDevicePipeBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceBackingOption_Def not in ns0.VirtualDevicePipeBackingOption_Def.__bases__:
                bases = list(ns0.VirtualDevicePipeBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceBackingOption_Def)
                ns0.VirtualDevicePipeBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceConnectOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceConnectOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceConnectOption_Def.schema
            TClist = [GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"startConnected"), aname="_startConnected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"allowGuestControl"), aname="_allowGuestControl", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDeviceConnectOption_Def.__bases__:
                bases = list(ns0.VirtualDeviceConnectOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDeviceConnectOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDeviceOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceOption_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"type"), aname="_type", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceConnectOption",lazy=True)(pname=(ns,"connectOption"), aname="_connectOption", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"controllerType"), aname="_controllerType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"autoAssignController"), aname="_autoAssignController", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceBackingOption",lazy=True)(pname=(ns,"backingOption"), aname="_backingOption", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"defaultBackingOptionIndex"), aname="_defaultBackingOptionIndex", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"licensingLimit"), aname="_licensingLimit", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"deprecated"), aname="_deprecated", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"plugAndPlay"), aname="_plugAndPlay", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDeviceOption_Def.__bases__:
                bases = list(ns0.VirtualDeviceOption_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDeviceOption_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualDeviceOption_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualDeviceOption")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualDeviceOption_Def.schema
            TClist = [GTD("urn:vim25","VirtualDeviceOption",lazy=True)(pname=(ns,"VirtualDeviceOption"), aname="_VirtualDeviceOption", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualDeviceOption = []
                    return
            Holder.__name__ = "ArrayOfVirtualDeviceOption_Holder"
            self.pyclass = Holder

    class VirtualDeviceConfigSpecOperation_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceConfigSpecOperation")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualDeviceConfigSpecFileOperation_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceConfigSpecFileOperation")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualDeviceConfigSpec_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDeviceConfigSpec")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDeviceConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","VirtualDeviceConfigSpecOperation",lazy=True)(pname=(ns,"operation"), aname="_operation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDeviceConfigSpecFileOperation",lazy=True)(pname=(ns,"fileOperation"), aname="_fileOperation", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualDevice",lazy=True)(pname=(ns,"device"), aname="_device", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.DynamicData_Def not in ns0.VirtualDeviceConfigSpec_Def.__bases__:
                bases = list(ns0.VirtualDeviceConfigSpec_Def.__bases__)
                bases.insert(0, ns0.DynamicData_Def)
                ns0.VirtualDeviceConfigSpec_Def.__bases__ = tuple(bases)

            ns0.DynamicData_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ArrayOfVirtualDeviceConfigSpec_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualDeviceConfigSpec")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualDeviceConfigSpec_Def.schema
            TClist = [GTD("urn:vim25","VirtualDeviceConfigSpec",lazy=True)(pname=(ns,"VirtualDeviceConfigSpec"), aname="_VirtualDeviceConfigSpec", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualDeviceConfigSpec = []
                    return
            Holder.__name__ = "ArrayOfVirtualDeviceConfigSpec_Holder"
            self.pyclass = Holder

    class VirtualDiskSparseVer1BackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskSparseVer1BackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskSparseVer1BackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"split"), aname="_split", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"spaceUsedInKB"), aname="_spaceUsedInKB", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualDiskSparseVer1BackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDiskSparseVer1BackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualDiskSparseVer1BackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskSparseVer2BackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskSparseVer2BackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskSparseVer2BackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"split"), aname="_split", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Ilong(pname=(ns,"spaceUsedInKB"), aname="_spaceUsedInKB", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualDiskSparseVer2BackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDiskSparseVer2BackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualDiskSparseVer2BackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskFlatVer1BackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskFlatVer1BackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskFlatVer1BackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"split"), aname="_split", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualDiskFlatVer1BackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDiskFlatVer1BackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualDiskFlatVer1BackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskFlatVer2BackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskFlatVer2BackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskFlatVer2BackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"split"), aname="_split", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"thinProvisioned"), aname="_thinProvisioned", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualDiskFlatVer2BackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDiskFlatVer2BackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualDiskFlatVer2BackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskRawDiskVer2BackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskRawDiskVer2BackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskRawDiskVer2BackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"descriptorFileName"), aname="_descriptorFileName", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualDiskRawDiskVer2BackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDiskRawDiskVer2BackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualDiskRawDiskVer2BackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskPartitionedRawDiskVer2BackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskPartitionedRawDiskVer2BackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskPartitionedRawDiskVer2BackingInfo_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"partition"), aname="_partition", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDiskRawDiskVer2BackingInfo_Def not in ns0.VirtualDiskPartitionedRawDiskVer2BackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDiskPartitionedRawDiskVer2BackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDiskRawDiskVer2BackingInfo_Def)
                ns0.VirtualDiskPartitionedRawDiskVer2BackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDiskRawDiskVer2BackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskRawDiskMappingVer1BackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskRawDiskMappingVer1BackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskRawDiskMappingVer1BackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"lunUuid"), aname="_lunUuid", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"deviceName"), aname="_deviceName", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"compatibilityMode"), aname="_compatibilityMode", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"uuid"), aname="_uuid", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualDiskRawDiskMappingVer1BackingInfo_Def.__bases__:
                bases = list(ns0.VirtualDiskRawDiskMappingVer1BackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualDiskRawDiskMappingVer1BackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDisk_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDisk")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDisk_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"capacityInKB"), aname="_capacityInKB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","SharesInfo",lazy=True)(pname=(ns,"shares"), aname="_shares", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualDisk_Def.__bases__:
                bases = list(ns0.VirtualDisk_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualDisk_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskMode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualDiskMode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualDiskCompatibilityMode_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualDiskCompatibilityMode")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualDiskSparseVer1BackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskSparseVer1BackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskSparseVer1BackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"diskModes"), aname="_diskModes", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"split"), aname="_split", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"growable"), aname="_growable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualDiskSparseVer1BackingOption_Def.__bases__:
                bases = list(ns0.VirtualDiskSparseVer1BackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualDiskSparseVer1BackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskSparseVer2BackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskSparseVer2BackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskSparseVer2BackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"split"), aname="_split", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"growable"), aname="_growable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"hotGrowable"), aname="_hotGrowable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualDiskSparseVer2BackingOption_Def.__bases__:
                bases = list(ns0.VirtualDiskSparseVer2BackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualDiskSparseVer2BackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskFlatVer1BackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskFlatVer1BackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskFlatVer1BackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"split"), aname="_split", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"growable"), aname="_growable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualDiskFlatVer1BackingOption_Def.__bases__:
                bases = list(ns0.VirtualDiskFlatVer1BackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualDiskFlatVer1BackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskFlatVer2BackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskFlatVer2BackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskFlatVer2BackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"split"), aname="_split", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"writeThrough"), aname="_writeThrough", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"growable"), aname="_growable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"hotGrowable"), aname="_hotGrowable", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualDiskFlatVer2BackingOption_Def.__bases__:
                bases = list(ns0.VirtualDiskFlatVer2BackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualDiskFlatVer2BackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskRawDiskVer2BackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskRawDiskVer2BackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskRawDiskVer2BackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"descriptorFileNameExtensions"), aname="_descriptorFileNameExtensions", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualDiskRawDiskVer2BackingOption_Def.__bases__:
                bases = list(ns0.VirtualDiskRawDiskVer2BackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualDiskRawDiskVer2BackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskPartitionedRawDiskVer2BackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskPartitionedRawDiskVer2BackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskPartitionedRawDiskVer2BackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDiskRawDiskVer2BackingOption_Def not in ns0.VirtualDiskPartitionedRawDiskVer2BackingOption_Def.__bases__:
                bases = list(ns0.VirtualDiskPartitionedRawDiskVer2BackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDiskRawDiskVer2BackingOption_Def)
                ns0.VirtualDiskPartitionedRawDiskVer2BackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDiskRawDiskVer2BackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskRawDiskMappingVer1BackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskRawDiskMappingVer1BackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskRawDiskMappingVer1BackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"descriptorFileNameExtensions"), aname="_descriptorFileNameExtensions", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"compatibilityMode"), aname="_compatibilityMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"diskMode"), aname="_diskMode", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"uuid"), aname="_uuid", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualDiskRawDiskMappingVer1BackingOption_Def.__bases__:
                bases = list(ns0.VirtualDiskRawDiskMappingVer1BackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualDiskRawDiskMappingVer1BackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualDiskOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualDiskOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualDiskOption_Def.schema
            TClist = [GTD("urn:vim25","LongOption",lazy=True)(pname=(ns,"capacityInKB"), aname="_capacityInKB", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualDiskOption_Def.__bases__:
                bases = list(ns0.VirtualDiskOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualDiskOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualE1000_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualE1000")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualE1000_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualEthernetCard_Def not in ns0.VirtualE1000_Def.__bases__:
                bases = list(ns0.VirtualE1000_Def.__bases__)
                bases.insert(0, ns0.VirtualEthernetCard_Def)
                ns0.VirtualE1000_Def.__bases__ = tuple(bases)

            ns0.VirtualEthernetCard_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualE1000Option_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualE1000Option")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualE1000Option_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualEthernetCardOption_Def not in ns0.VirtualE1000Option_Def.__bases__:
                bases = list(ns0.VirtualE1000Option_Def.__bases__)
                bases.insert(0, ns0.VirtualEthernetCardOption_Def)
                ns0.VirtualE1000Option_Def.__bases__ = tuple(bases)

            ns0.VirtualEthernetCardOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEnsoniq1371_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEnsoniq1371")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEnsoniq1371_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSoundCard_Def not in ns0.VirtualEnsoniq1371_Def.__bases__:
                bases = list(ns0.VirtualEnsoniq1371_Def.__bases__)
                bases.insert(0, ns0.VirtualSoundCard_Def)
                ns0.VirtualEnsoniq1371_Def.__bases__ = tuple(bases)

            ns0.VirtualSoundCard_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEnsoniq1371Option_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEnsoniq1371Option")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEnsoniq1371Option_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSoundCardOption_Def not in ns0.VirtualEnsoniq1371Option_Def.__bases__:
                bases = list(ns0.VirtualEnsoniq1371Option_Def.__bases__)
                bases.insert(0, ns0.VirtualSoundCardOption_Def)
                ns0.VirtualEnsoniq1371Option_Def.__bases__ = tuple(bases)

            ns0.VirtualSoundCardOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEthernetCardNetworkBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardNetworkBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEthernetCardNetworkBackingInfo_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"network"), aname="_network", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualEthernetCardNetworkBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualEthernetCardNetworkBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualEthernetCardNetworkBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEthernetCardLegacyNetworkBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardLegacyNetworkBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEthernetCardLegacyNetworkBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualEthernetCardLegacyNetworkBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualEthernetCardLegacyNetworkBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualEthernetCardLegacyNetworkBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEthernetCard_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCard")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEthernetCard_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"addressType"), aname="_addressType", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.String(pname=(ns,"macAddress"), aname="_macAddress", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"wakeOnLanEnabled"), aname="_wakeOnLanEnabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualEthernetCard_Def.__bases__:
                bases = list(ns0.VirtualEthernetCard_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualEthernetCard_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEthernetCardNetworkBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardNetworkBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEthernetCardNetworkBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualEthernetCardNetworkBackingOption_Def.__bases__:
                bases = list(ns0.VirtualEthernetCardNetworkBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualEthernetCardNetworkBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEthernetCardLegacyNetworkDeviceName_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardLegacyNetworkDeviceName")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualEthernetCardLegacyNetworkBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardLegacyNetworkBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEthernetCardLegacyNetworkBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualEthernetCardLegacyNetworkBackingOption_Def.__bases__:
                bases = list(ns0.VirtualEthernetCardLegacyNetworkBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualEthernetCardLegacyNetworkBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualEthernetCardMacType_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardMacType")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualEthernetCardOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualEthernetCardOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualEthernetCardOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"supportedOUI"), aname="_supportedOUI", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"macType"), aname="_macType", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"wakeOnLanEnabled"), aname="_wakeOnLanEnabled", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualEthernetCardOption_Def.__bases__:
                bases = list(ns0.VirtualEthernetCardOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualEthernetCardOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppyImageBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppyImageBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppyImageBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualFloppyImageBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualFloppyImageBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualFloppyImageBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppyDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppyDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppyDeviceBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualFloppyDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualFloppyDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualFloppyDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppyRemoteDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppyRemoteDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppyRemoteDeviceBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceRemoteDeviceBackingInfo_Def not in ns0.VirtualFloppyRemoteDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualFloppyRemoteDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceRemoteDeviceBackingInfo_Def)
                ns0.VirtualFloppyRemoteDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceRemoteDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppy_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppy")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppy_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualFloppy_Def.__bases__:
                bases = list(ns0.VirtualFloppy_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualFloppy_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppyImageBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppyImageBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppyImageBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualFloppyImageBackingOption_Def.__bases__:
                bases = list(ns0.VirtualFloppyImageBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualFloppyImageBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppyDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppyDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppyDeviceBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualFloppyDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualFloppyDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualFloppyDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppyRemoteDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppyRemoteDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppyRemoteDeviceBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceRemoteDeviceBackingOption_Def not in ns0.VirtualFloppyRemoteDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualFloppyRemoteDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceRemoteDeviceBackingOption_Def)
                ns0.VirtualFloppyRemoteDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceRemoteDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualFloppyOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualFloppyOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualFloppyOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualFloppyOption_Def.__bases__:
                bases = list(ns0.VirtualFloppyOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualFloppyOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualIDEController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualIDEController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualIDEController_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualController_Def not in ns0.VirtualIDEController_Def.__bases__:
                bases = list(ns0.VirtualIDEController_Def.__bases__)
                bases.insert(0, ns0.VirtualController_Def)
                ns0.VirtualIDEController_Def.__bases__ = tuple(bases)

            ns0.VirtualController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualIDEControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualIDEControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualIDEControllerOption_Def.schema
            TClist = [GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numIDEDisks"), aname="_numIDEDisks", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numIDECdroms"), aname="_numIDECdroms", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualControllerOption_Def not in ns0.VirtualIDEControllerOption_Def.__bases__:
                bases = list(ns0.VirtualIDEControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualControllerOption_Def)
                ns0.VirtualIDEControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualKeyboard_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualKeyboard")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualKeyboard_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualKeyboard_Def.__bases__:
                bases = list(ns0.VirtualKeyboard_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualKeyboard_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualKeyboardOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualKeyboardOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualKeyboardOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualKeyboardOption_Def.__bases__:
                bases = list(ns0.VirtualKeyboardOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualKeyboardOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualLsiLogicController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualLsiLogicController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualLsiLogicController_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSCSIController_Def not in ns0.VirtualLsiLogicController_Def.__bases__:
                bases = list(ns0.VirtualLsiLogicController_Def.__bases__)
                bases.insert(0, ns0.VirtualSCSIController_Def)
                ns0.VirtualLsiLogicController_Def.__bases__ = tuple(bases)

            ns0.VirtualSCSIController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualLsiLogicControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualLsiLogicControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualLsiLogicControllerOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSCSIControllerOption_Def not in ns0.VirtualLsiLogicControllerOption_Def.__bases__:
                bases = list(ns0.VirtualLsiLogicControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualSCSIControllerOption_Def)
                ns0.VirtualLsiLogicControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualSCSIControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPCIController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPCIController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPCIController_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualController_Def not in ns0.VirtualPCIController_Def.__bases__:
                bases = list(ns0.VirtualPCIController_Def.__bases__)
                bases.insert(0, ns0.VirtualController_Def)
                ns0.VirtualPCIController_Def.__bases__ = tuple(bases)

            ns0.VirtualController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPCIControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPCIControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPCIControllerOption_Def.schema
            TClist = [GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numSCSIControllers"), aname="_numSCSIControllers", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numEthernetCards"), aname="_numEthernetCards", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numVideoCards"), aname="_numVideoCards", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numSoundCards"), aname="_numSoundCards", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numVmiRoms"), aname="_numVmiRoms", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualControllerOption_Def not in ns0.VirtualPCIControllerOption_Def.__bases__:
                bases = list(ns0.VirtualPCIControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualControllerOption_Def)
                ns0.VirtualPCIControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPCNet32_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPCNet32")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPCNet32_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualEthernetCard_Def not in ns0.VirtualPCNet32_Def.__bases__:
                bases = list(ns0.VirtualPCNet32_Def.__bases__)
                bases.insert(0, ns0.VirtualEthernetCard_Def)
                ns0.VirtualPCNet32_Def.__bases__ = tuple(bases)

            ns0.VirtualEthernetCard_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPCNet32Option_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPCNet32Option")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPCNet32Option_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"supportsMorphing"), aname="_supportsMorphing", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualEthernetCardOption_Def not in ns0.VirtualPCNet32Option_Def.__bases__:
                bases = list(ns0.VirtualPCNet32Option_Def.__bases__)
                bases.insert(0, ns0.VirtualEthernetCardOption_Def)
                ns0.VirtualPCNet32Option_Def.__bases__ = tuple(bases)

            ns0.VirtualEthernetCardOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPS2Controller_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPS2Controller")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPS2Controller_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualController_Def not in ns0.VirtualPS2Controller_Def.__bases__:
                bases = list(ns0.VirtualPS2Controller_Def.__bases__)
                bases.insert(0, ns0.VirtualController_Def)
                ns0.VirtualPS2Controller_Def.__bases__ = tuple(bases)

            ns0.VirtualController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPS2ControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPS2ControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPS2ControllerOption_Def.schema
            TClist = [GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numKeyboards"), aname="_numKeyboards", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numPointingDevices"), aname="_numPointingDevices", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualControllerOption_Def not in ns0.VirtualPS2ControllerOption_Def.__bases__:
                bases = list(ns0.VirtualPS2ControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualControllerOption_Def)
                ns0.VirtualPS2ControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualParallelPortFileBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualParallelPortFileBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualParallelPortFileBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualParallelPortFileBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualParallelPortFileBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualParallelPortFileBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualParallelPortDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualParallelPortDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualParallelPortDeviceBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualParallelPortDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualParallelPortDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualParallelPortDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualParallelPort_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualParallelPort")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualParallelPort_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualParallelPort_Def.__bases__:
                bases = list(ns0.VirtualParallelPort_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualParallelPort_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualParallelPortFileBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualParallelPortFileBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualParallelPortFileBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualParallelPortFileBackingOption_Def.__bases__:
                bases = list(ns0.VirtualParallelPortFileBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualParallelPortFileBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualParallelPortDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualParallelPortDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualParallelPortDeviceBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualParallelPortDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualParallelPortDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualParallelPortDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualParallelPortOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualParallelPortOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualParallelPortOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualParallelPortOption_Def.__bases__:
                bases = list(ns0.VirtualParallelPortOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualParallelPortOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPointingDeviceDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPointingDeviceDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPointingDeviceDeviceBackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"hostPointingDevice"), aname="_hostPointingDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualPointingDeviceDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualPointingDeviceDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualPointingDeviceDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPointingDevice_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPointingDevice")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPointingDevice_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualPointingDevice_Def.__bases__:
                bases = list(ns0.VirtualPointingDevice_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualPointingDevice_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPointingDeviceHostChoice_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualPointingDeviceHostChoice")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualPointingDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPointingDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPointingDeviceBackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"hostPointingDevice"), aname="_hostPointingDevice", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualPointingDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualPointingDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualPointingDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualPointingDeviceOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualPointingDeviceOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualPointingDeviceOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualPointingDeviceOption_Def.__bases__:
                bases = list(ns0.VirtualPointingDeviceOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualPointingDeviceOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSCSISharing_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualSCSISharing")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class ArrayOfVirtualSCSISharing_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfVirtualSCSISharing")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfVirtualSCSISharing_Def.schema
            TClist = [GTD("urn:vim25","VirtualSCSISharing",lazy=True)(pname=(ns,"VirtualSCSISharing"), aname="_VirtualSCSISharing", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._VirtualSCSISharing = []
                    return
            Holder.__name__ = "ArrayOfVirtualSCSISharing_Holder"
            self.pyclass = Holder

    class VirtualSCSIController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSCSIController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSCSIController_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"hotAddRemove"), aname="_hotAddRemove", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualSCSISharing",lazy=True)(pname=(ns,"sharedBus"), aname="_sharedBus", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"scsiCtlrUnitNumber"), aname="_scsiCtlrUnitNumber", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualController_Def not in ns0.VirtualSCSIController_Def.__bases__:
                bases = list(ns0.VirtualSCSIController_Def.__bases__)
                bases.insert(0, ns0.VirtualController_Def)
                ns0.VirtualSCSIController_Def.__bases__ = tuple(bases)

            ns0.VirtualController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSCSIControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSCSIControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSCSIControllerOption_Def.schema
            TClist = [GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numSCSIDisks"), aname="_numSCSIDisks", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numSCSICdroms"), aname="_numSCSICdroms", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numSCSIPassthrough"), aname="_numSCSIPassthrough", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","VirtualSCSISharing",lazy=True)(pname=(ns,"sharing"), aname="_sharing", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"defaultSharedIndex"), aname="_defaultSharedIndex", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"hotAddRemove"), aname="_hotAddRemove", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TCnumbers.Iint(pname=(ns,"scsiCtlrUnitNumber"), aname="_scsiCtlrUnitNumber", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualControllerOption_Def not in ns0.VirtualSCSIControllerOption_Def.__bases__:
                bases = list(ns0.VirtualSCSIControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualControllerOption_Def)
                ns0.VirtualSCSIControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSCSIPassthroughDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSCSIPassthroughDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSCSIPassthroughDeviceBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualSCSIPassthroughDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualSCSIPassthroughDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualSCSIPassthroughDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSCSIPassthrough_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSCSIPassthrough")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSCSIPassthrough_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualSCSIPassthrough_Def.__bases__:
                bases = list(ns0.VirtualSCSIPassthrough_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualSCSIPassthrough_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSCSIPassthroughDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSCSIPassthroughDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSCSIPassthroughDeviceBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualSCSIPassthroughDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualSCSIPassthroughDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualSCSIPassthroughDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSCSIPassthroughOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSCSIPassthroughOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSCSIPassthroughOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualSCSIPassthroughOption_Def.__bases__:
                bases = list(ns0.VirtualSCSIPassthroughOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualSCSIPassthroughOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSIOController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSIOController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSIOController_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualController_Def not in ns0.VirtualSIOController_Def.__bases__:
                bases = list(ns0.VirtualSIOController_Def.__bases__)
                bases.insert(0, ns0.VirtualController_Def)
                ns0.VirtualSIOController_Def.__bases__ = tuple(bases)

            ns0.VirtualController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSIOControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSIOControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSIOControllerOption_Def.schema
            TClist = [GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numFloppyDrives"), aname="_numFloppyDrives", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numSerialPorts"), aname="_numSerialPorts", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","IntOption",lazy=True)(pname=(ns,"numParallelPorts"), aname="_numParallelPorts", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualControllerOption_Def not in ns0.VirtualSIOControllerOption_Def.__bases__:
                bases = list(ns0.VirtualSIOControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualControllerOption_Def)
                ns0.VirtualSIOControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPortFileBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortFileBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPortFileBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingInfo_Def not in ns0.VirtualSerialPortFileBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualSerialPortFileBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingInfo_Def)
                ns0.VirtualSerialPortFileBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPortDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPortDeviceBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualSerialPortDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualSerialPortDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualSerialPortDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPortPipeBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortPipeBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPortPipeBackingInfo_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"endpoint"), aname="_endpoint", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"noRxLoss"), aname="_noRxLoss", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevicePipeBackingInfo_Def not in ns0.VirtualSerialPortPipeBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualSerialPortPipeBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDevicePipeBackingInfo_Def)
                ns0.VirtualSerialPortPipeBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDevicePipeBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPort_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPort")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPort_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"yieldOnPoll"), aname="_yieldOnPoll", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualSerialPort_Def.__bases__:
                bases = list(ns0.VirtualSerialPort_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualSerialPort_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPortEndPoint_Def(ZSI.TC.String, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortEndPoint")
        def __init__(self, pname, **kw):
            ZSI.TC.String.__init__(self, pname, pyclass=None, **kw)
            class Holder(str):
                typecode = self
            self.pyclass = Holder

    class VirtualSerialPortFileBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortFileBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPortFileBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceFileBackingOption_Def not in ns0.VirtualSerialPortFileBackingOption_Def.__bases__:
                bases = list(ns0.VirtualSerialPortFileBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceFileBackingOption_Def)
                ns0.VirtualSerialPortFileBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceFileBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPortDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPortDeviceBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualSerialPortDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualSerialPortDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualSerialPortDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPortPipeBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortPipeBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPortPipeBackingOption_Def.schema
            TClist = [GTD("urn:vim25","ChoiceOption",lazy=True)(pname=(ns,"endpoint"), aname="_endpoint", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"noRxLoss"), aname="_noRxLoss", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevicePipeBackingOption_Def not in ns0.VirtualSerialPortPipeBackingOption_Def.__bases__:
                bases = list(ns0.VirtualSerialPortPipeBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDevicePipeBackingOption_Def)
                ns0.VirtualSerialPortPipeBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDevicePipeBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSerialPortOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSerialPortOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSerialPortOption_Def.schema
            TClist = [GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"yieldOnPoll"), aname="_yieldOnPoll", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualSerialPortOption_Def.__bases__:
                bases = list(ns0.VirtualSerialPortOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualSerialPortOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSoundBlaster16_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSoundBlaster16")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSoundBlaster16_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSoundCard_Def not in ns0.VirtualSoundBlaster16_Def.__bases__:
                bases = list(ns0.VirtualSoundBlaster16_Def.__bases__)
                bases.insert(0, ns0.VirtualSoundCard_Def)
                ns0.VirtualSoundBlaster16_Def.__bases__ = tuple(bases)

            ns0.VirtualSoundCard_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSoundBlaster16Option_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSoundBlaster16Option")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSoundBlaster16Option_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualSoundCardOption_Def not in ns0.VirtualSoundBlaster16Option_Def.__bases__:
                bases = list(ns0.VirtualSoundBlaster16Option_Def.__bases__)
                bases.insert(0, ns0.VirtualSoundCardOption_Def)
                ns0.VirtualSoundBlaster16Option_Def.__bases__ = tuple(bases)

            ns0.VirtualSoundCardOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSoundCardDeviceBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSoundCardDeviceBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSoundCardDeviceBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualSoundCardDeviceBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualSoundCardDeviceBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualSoundCardDeviceBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSoundCard_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSoundCard")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSoundCard_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualSoundCard_Def.__bases__:
                bases = list(ns0.VirtualSoundCard_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualSoundCard_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSoundCardDeviceBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSoundCardDeviceBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSoundCardDeviceBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualSoundCardDeviceBackingOption_Def.__bases__:
                bases = list(ns0.VirtualSoundCardDeviceBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualSoundCardDeviceBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualSoundCardOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualSoundCardOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualSoundCardOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualSoundCardOption_Def.__bases__:
                bases = list(ns0.VirtualSoundCardOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualSoundCardOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualUSBUSBBackingInfo_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualUSBUSBBackingInfo")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualUSBUSBBackingInfo_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingInfo_Def not in ns0.VirtualUSBUSBBackingInfo_Def.__bases__:
                bases = list(ns0.VirtualUSBUSBBackingInfo_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingInfo_Def)
                ns0.VirtualUSBUSBBackingInfo_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingInfo_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualUSB_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualUSB")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualUSB_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"connected"), aname="_connected", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualUSB_Def.__bases__:
                bases = list(ns0.VirtualUSB_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualUSB_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualUSBController_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualUSBController")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualUSBController_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"autoConnectDevices"), aname="_autoConnectDevices", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), ZSI.TC.Boolean(pname=(ns,"ehciEnabled"), aname="_ehciEnabled", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualController_Def not in ns0.VirtualUSBController_Def.__bases__:
                bases = list(ns0.VirtualUSBController_Def.__bases__)
                bases.insert(0, ns0.VirtualController_Def)
                ns0.VirtualUSBController_Def.__bases__ = tuple(bases)

            ns0.VirtualController_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualUSBControllerOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualUSBControllerOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualUSBControllerOption_Def.schema
            TClist = [GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"autoConnectDevices"), aname="_autoConnectDevices", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded")), GTD("urn:vim25","BoolOption",lazy=True)(pname=(ns,"ehciSupported"), aname="_ehciSupported", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualControllerOption_Def not in ns0.VirtualUSBControllerOption_Def.__bases__:
                bases = list(ns0.VirtualUSBControllerOption_Def.__bases__)
                bases.insert(0, ns0.VirtualControllerOption_Def)
                ns0.VirtualUSBControllerOption_Def.__bases__ = tuple(bases)

            ns0.VirtualControllerOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualUSBUSBBackingOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualUSBUSBBackingOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualUSBUSBBackingOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceDeviceBackingOption_Def not in ns0.VirtualUSBUSBBackingOption_Def.__bases__:
                bases = list(ns0.VirtualUSBUSBBackingOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceDeviceBackingOption_Def)
                ns0.VirtualUSBUSBBackingOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceDeviceBackingOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualUSBOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualUSBOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualUSBOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualUSBOption_Def.__bases__:
                bases = list(ns0.VirtualUSBOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualUSBOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineVMIROM_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineVMIROM")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineVMIROM_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualMachineVMIROM_Def.__bases__:
                bases = list(ns0.VirtualMachineVMIROM_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualMachineVMIROM_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualVMIROMOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualVMIROMOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualVMIROMOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualVMIROMOption_Def.__bases__:
                bases = list(ns0.VirtualVMIROMOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualVMIROMOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualMachineVideoCard_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualMachineVideoCard")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualMachineVideoCard_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"videoRamSizeInKB"), aname="_videoRamSizeInKB", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDevice_Def not in ns0.VirtualMachineVideoCard_Def.__bases__:
                bases = list(ns0.VirtualMachineVideoCard_Def.__bases__)
                bases.insert(0, ns0.VirtualDevice_Def)
                ns0.VirtualMachineVideoCard_Def.__bases__ = tuple(bases)

            ns0.VirtualDevice_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualVideoCardOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualVideoCardOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualVideoCardOption_Def.schema
            TClist = [GTD("urn:vim25","LongOption",lazy=True)(pname=(ns,"videoRamSizeInKB"), aname="_videoRamSizeInKB", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualDeviceOption_Def not in ns0.VirtualVideoCardOption_Def.__bases__:
                bases = list(ns0.VirtualVideoCardOption_Def.__bases__)
                bases.insert(0, ns0.VirtualDeviceOption_Def)
                ns0.VirtualVideoCardOption_Def.__bases__ = tuple(bases)

            ns0.VirtualDeviceOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualVmxnet_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualVmxnet")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualVmxnet_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualEthernetCard_Def not in ns0.VirtualVmxnet_Def.__bases__:
                bases = list(ns0.VirtualVmxnet_Def.__bases__)
                bases.insert(0, ns0.VirtualEthernetCard_Def)
                ns0.VirtualVmxnet_Def.__bases__ = tuple(bases)

            ns0.VirtualEthernetCard_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualVmxnet2_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualVmxnet2")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualVmxnet2_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualVmxnet_Def not in ns0.VirtualVmxnet2_Def.__bases__:
                bases = list(ns0.VirtualVmxnet2_Def.__bases__)
                bases.insert(0, ns0.VirtualVmxnet_Def)
                ns0.VirtualVmxnet2_Def.__bases__ = tuple(bases)

            ns0.VirtualVmxnet_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualVmxnet2Option_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualVmxnet2Option")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualVmxnet2Option_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualVmxnetOption_Def not in ns0.VirtualVmxnet2Option_Def.__bases__:
                bases = list(ns0.VirtualVmxnet2Option_Def.__bases__)
                bases.insert(0, ns0.VirtualVmxnetOption_Def)
                ns0.VirtualVmxnet2Option_Def.__bases__ = tuple(bases)

            ns0.VirtualVmxnetOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class VirtualVmxnetOption_Def(TypeDefinition):
        #complexType/complexContent extension
        schema = "urn:vim25"
        type = (schema, "VirtualVmxnetOption")
        def __init__(self, pname, ofwhat=(), extend=False, restrict=False, attributes=None, **kw):
            ns = ns0.VirtualVmxnetOption_Def.schema
            TClist = []
            attributes = self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            if ns0.VirtualEthernetCardOption_Def not in ns0.VirtualVmxnetOption_Def.__bases__:
                bases = list(ns0.VirtualVmxnetOption_Def.__bases__)
                bases.insert(0, ns0.VirtualEthernetCardOption_Def)
                ns0.VirtualVmxnetOption_Def.__bases__ = tuple(bases)

            ns0.VirtualEthernetCardOption_Def.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)

    class ManagedObjectReference_Def(ZSI.TC.String, TypeDefinition):
        # ComplexType/SimpleContent derivation of built-in type
        schema = "urn:vim25"
        type = (schema, "ManagedObjectReference")
        def __init__(self, pname, **kw):
            if getattr(self, "attribute_typecode_dict", None) is None: self.attribute_typecode_dict = {}
            # attribute handling code
            self.attribute_typecode_dict["type"] = ZSI.TC.String()
            ZSI.TC.String.__init__(self, pname, **kw)
            class Holder(str):
                __metaclass__ = pyclass_type
                typecode = self
            self.pyclass = Holder

    class ArrayOfString_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfString")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfString_Def.schema
            TClist = [ZSI.TC.String(pname=(ns,"string"), aname="_string", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._string = []
                    return
            Holder.__name__ = "ArrayOfString_Holder"
            self.pyclass = Holder

    class ArrayOfAnyType_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfAnyType")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfAnyType_Def.schema
            TClist = [ZSI.TC.AnyType(pname=(ns,"anyType"), aname="_anyType", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._anyType = []
                    return
            Holder.__name__ = "ArrayOfAnyType_Holder"
            self.pyclass = Holder

    class ArrayOfManagedObjectReference_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfManagedObjectReference")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfManagedObjectReference_Def.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"ManagedObjectReference"), aname="_ManagedObjectReference", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._ManagedObjectReference = []
                    return
            Holder.__name__ = "ArrayOfManagedObjectReference_Holder"
            self.pyclass = Holder

    class ArrayOfBoolean_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfBoolean")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfBoolean_Def.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"boolean"), aname="_boolean", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._boolean = []
                    return
            Holder.__name__ = "ArrayOfBoolean_Holder"
            self.pyclass = Holder

    class ArrayOfByte_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfByte")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfByte_Def.schema
            TClist = [ZSI.TCnumbers.Ibyte(pname=(ns,"byte"), aname="_byte", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._byte = []
                    return
            Holder.__name__ = "ArrayOfByte_Holder"
            self.pyclass = Holder

    class ArrayOfInt_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfInt")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfInt_Def.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"int"), aname="_int", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._int = []
                    return
            Holder.__name__ = "ArrayOfInt_Holder"
            self.pyclass = Holder

    class ArrayOfLong_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfLong")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfLong_Def.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"long"), aname="_long", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._long = []
                    return
            Holder.__name__ = "ArrayOfLong_Holder"
            self.pyclass = Holder

    class ArrayOfShort_Def(ZSI.TCcompound.ComplexType, TypeDefinition):
        schema = "urn:vim25"
        type = (schema, "ArrayOfShort")
        def __init__(self, pname, ofwhat=(), attributes=None, extend=False, restrict=False, **kw):
            ns = ns0.ArrayOfShort_Def.schema
            TClist = [ZSI.TCnumbers.Ishort(pname=(ns,"short"), aname="_short", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            self.attribute_typecode_dict = attributes or {}
            if extend: TClist += ofwhat
            if restrict: TClist = ofwhat
            ZSI.TCcompound.ComplexType.__init__(self, None, TClist, pname=pname, inorder=0, **kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._short = []
                    return
            Holder.__name__ = "ArrayOfShort_Holder"
            self.pyclass = Holder

    class HostCommunicationFault_Dec(ElementDeclaration):
        literal = "HostCommunicationFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HostCommunicationFault')
            kw["aname"] = "_HostCommunicationFault"
            if ns0.HostCommunication_Def not in ns0.HostCommunicationFault_Dec.__bases__:
                bases = list(ns0.HostCommunicationFault_Dec.__bases__)
                bases.insert(0, ns0.HostCommunication_Def)
                ns0.HostCommunicationFault_Dec.__bases__ = tuple(bases)

            ns0.HostCommunication_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HostCommunicationFault_Dec_Holder"

    class HostNotConnectedFault_Dec(ElementDeclaration):
        literal = "HostNotConnectedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HostNotConnectedFault')
            kw["aname"] = "_HostNotConnectedFault"
            if ns0.HostNotConnected_Def not in ns0.HostNotConnectedFault_Dec.__bases__:
                bases = list(ns0.HostNotConnectedFault_Dec.__bases__)
                bases.insert(0, ns0.HostNotConnected_Def)
                ns0.HostNotConnectedFault_Dec.__bases__ = tuple(bases)

            ns0.HostNotConnected_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HostNotConnectedFault_Dec_Holder"

    class HostNotReachableFault_Dec(ElementDeclaration):
        literal = "HostNotReachableFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HostNotReachableFault')
            kw["aname"] = "_HostNotReachableFault"
            if ns0.HostNotReachable_Def not in ns0.HostNotReachableFault_Dec.__bases__:
                bases = list(ns0.HostNotReachableFault_Dec.__bases__)
                bases.insert(0, ns0.HostNotReachable_Def)
                ns0.HostNotReachableFault_Dec.__bases__ = tuple(bases)

            ns0.HostNotReachable_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HostNotReachableFault_Dec_Holder"

    class InvalidArgumentFault_Dec(ElementDeclaration):
        literal = "InvalidArgumentFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidArgumentFault')
            kw["aname"] = "_InvalidArgumentFault"
            if ns0.InvalidArgument_Def not in ns0.InvalidArgumentFault_Dec.__bases__:
                bases = list(ns0.InvalidArgumentFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidArgument_Def)
                ns0.InvalidArgumentFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidArgument_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidArgumentFault_Dec_Holder"

    class InvalidRequestFault_Dec(ElementDeclaration):
        literal = "InvalidRequestFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidRequestFault')
            kw["aname"] = "_InvalidRequestFault"
            if ns0.InvalidRequest_Def not in ns0.InvalidRequestFault_Dec.__bases__:
                bases = list(ns0.InvalidRequestFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidRequest_Def)
                ns0.InvalidRequestFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidRequest_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidRequestFault_Dec_Holder"

    class InvalidTypeFault_Dec(ElementDeclaration):
        literal = "InvalidTypeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidTypeFault')
            kw["aname"] = "_InvalidTypeFault"
            if ns0.InvalidType_Def not in ns0.InvalidTypeFault_Dec.__bases__:
                bases = list(ns0.InvalidTypeFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidType_Def)
                ns0.InvalidTypeFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidTypeFault_Dec_Holder"

    class ManagedObjectNotFoundFault_Dec(ElementDeclaration):
        literal = "ManagedObjectNotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ManagedObjectNotFoundFault')
            kw["aname"] = "_ManagedObjectNotFoundFault"
            if ns0.ManagedObjectNotFound_Def not in ns0.ManagedObjectNotFoundFault_Dec.__bases__:
                bases = list(ns0.ManagedObjectNotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.ManagedObjectNotFound_Def)
                ns0.ManagedObjectNotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.ManagedObjectNotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ManagedObjectNotFoundFault_Dec_Holder"

    class MethodNotFoundFault_Dec(ElementDeclaration):
        literal = "MethodNotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MethodNotFoundFault')
            kw["aname"] = "_MethodNotFoundFault"
            if ns0.MethodNotFound_Def not in ns0.MethodNotFoundFault_Dec.__bases__:
                bases = list(ns0.MethodNotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.MethodNotFound_Def)
                ns0.MethodNotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.MethodNotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MethodNotFoundFault_Dec_Holder"

    class NotEnoughLicensesFault_Dec(ElementDeclaration):
        literal = "NotEnoughLicensesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotEnoughLicensesFault')
            kw["aname"] = "_NotEnoughLicensesFault"
            if ns0.NotEnoughLicenses_Def not in ns0.NotEnoughLicensesFault_Dec.__bases__:
                bases = list(ns0.NotEnoughLicensesFault_Dec.__bases__)
                bases.insert(0, ns0.NotEnoughLicenses_Def)
                ns0.NotEnoughLicensesFault_Dec.__bases__ = tuple(bases)

            ns0.NotEnoughLicenses_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotEnoughLicensesFault_Dec_Holder"

    class NotImplementedFault_Dec(ElementDeclaration):
        literal = "NotImplementedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotImplementedFault')
            kw["aname"] = "_NotImplementedFault"
            if ns0.NotImplemented_Def not in ns0.NotImplementedFault_Dec.__bases__:
                bases = list(ns0.NotImplementedFault_Dec.__bases__)
                bases.insert(0, ns0.NotImplemented_Def)
                ns0.NotImplementedFault_Dec.__bases__ = tuple(bases)

            ns0.NotImplemented_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotImplementedFault_Dec_Holder"

    class NotSupportedFault_Dec(ElementDeclaration):
        literal = "NotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotSupportedFault')
            kw["aname"] = "_NotSupportedFault"
            if ns0.NotSupported_Def not in ns0.NotSupportedFault_Dec.__bases__:
                bases = list(ns0.NotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.NotSupported_Def)
                ns0.NotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.NotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotSupportedFault_Dec_Holder"

    class RequestCanceledFault_Dec(ElementDeclaration):
        literal = "RequestCanceledFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RequestCanceledFault')
            kw["aname"] = "_RequestCanceledFault"
            if ns0.RequestCanceled_Def not in ns0.RequestCanceledFault_Dec.__bases__:
                bases = list(ns0.RequestCanceledFault_Dec.__bases__)
                bases.insert(0, ns0.RequestCanceled_Def)
                ns0.RequestCanceledFault_Dec.__bases__ = tuple(bases)

            ns0.RequestCanceled_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RequestCanceledFault_Dec_Holder"

    class SecurityErrorFault_Dec(ElementDeclaration):
        literal = "SecurityErrorFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SecurityErrorFault')
            kw["aname"] = "_SecurityErrorFault"
            if ns0.SecurityError_Def not in ns0.SecurityErrorFault_Dec.__bases__:
                bases = list(ns0.SecurityErrorFault_Dec.__bases__)
                bases.insert(0, ns0.SecurityError_Def)
                ns0.SecurityErrorFault_Dec.__bases__ = tuple(bases)

            ns0.SecurityError_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SecurityErrorFault_Dec_Holder"

    class SystemErrorFault_Dec(ElementDeclaration):
        literal = "SystemErrorFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SystemErrorFault')
            kw["aname"] = "_SystemErrorFault"
            if ns0.SystemError_Def not in ns0.SystemErrorFault_Dec.__bases__:
                bases = list(ns0.SystemErrorFault_Dec.__bases__)
                bases.insert(0, ns0.SystemError_Def)
                ns0.SystemErrorFault_Dec.__bases__ = tuple(bases)

            ns0.SystemError_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SystemErrorFault_Dec_Holder"

    class UnexpectedFaultFault_Dec(ElementDeclaration):
        literal = "UnexpectedFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnexpectedFaultFault')
            kw["aname"] = "_UnexpectedFaultFault"
            if ns0.UnexpectedFault_Def not in ns0.UnexpectedFaultFault_Dec.__bases__:
                bases = list(ns0.UnexpectedFaultFault_Dec.__bases__)
                bases.insert(0, ns0.UnexpectedFault_Def)
                ns0.UnexpectedFaultFault_Dec.__bases__ = tuple(bases)

            ns0.UnexpectedFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnexpectedFaultFault_Dec_Holder"

    class InvalidCollectorVersionFault_Dec(ElementDeclaration):
        literal = "InvalidCollectorVersionFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidCollectorVersionFault')
            kw["aname"] = "_InvalidCollectorVersionFault"
            if ns0.InvalidCollectorVersion_Def not in ns0.InvalidCollectorVersionFault_Dec.__bases__:
                bases = list(ns0.InvalidCollectorVersionFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidCollectorVersion_Def)
                ns0.InvalidCollectorVersionFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidCollectorVersion_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidCollectorVersionFault_Dec_Holder"

    class InvalidPropertyFault_Dec(ElementDeclaration):
        literal = "InvalidPropertyFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidPropertyFault')
            kw["aname"] = "_InvalidPropertyFault"
            if ns0.InvalidProperty_Def not in ns0.InvalidPropertyFault_Dec.__bases__:
                bases = list(ns0.InvalidPropertyFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidProperty_Def)
                ns0.InvalidPropertyFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidProperty_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidPropertyFault_Dec_Holder"

    class DestroyPropertyFilter_Dec(ElementDeclaration):
        literal = "DestroyPropertyFilter"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DestroyPropertyFilter')
            kw["aname"] = "_DestroyPropertyFilter"
            if ns0.DestroyPropertyFilterRequestType_Def not in ns0.DestroyPropertyFilter_Dec.__bases__:
                bases = list(ns0.DestroyPropertyFilter_Dec.__bases__)
                bases.insert(0, ns0.DestroyPropertyFilterRequestType_Def)
                ns0.DestroyPropertyFilter_Dec.__bases__ = tuple(bases)

            ns0.DestroyPropertyFilterRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DestroyPropertyFilter_Dec_Holder"

    class DestroyPropertyFilterResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DestroyPropertyFilterResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DestroyPropertyFilterResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DestroyPropertyFilterResponse')
            kw["aname"] = "_DestroyPropertyFilterResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DestroyPropertyFilterResponse_Holder"
            self.pyclass = Holder

    class CreateFilter_Dec(ElementDeclaration):
        literal = "CreateFilter"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateFilter')
            kw["aname"] = "_CreateFilter"
            if ns0.CreateFilterRequestType_Def not in ns0.CreateFilter_Dec.__bases__:
                bases = list(ns0.CreateFilter_Dec.__bases__)
                bases.insert(0, ns0.CreateFilterRequestType_Def)
                ns0.CreateFilter_Dec.__bases__ = tuple(bases)

            ns0.CreateFilterRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateFilter_Dec_Holder"

    class CreateFilterResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateFilterResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateFilterResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateFilterResponse')
            kw["aname"] = "_CreateFilterResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateFilterResponse_Holder"
            self.pyclass = Holder

    class RetrieveProperties_Dec(ElementDeclaration):
        literal = "RetrieveProperties"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveProperties')
            kw["aname"] = "_RetrieveProperties"
            if ns0.RetrievePropertiesRequestType_Def not in ns0.RetrieveProperties_Dec.__bases__:
                bases = list(ns0.RetrieveProperties_Dec.__bases__)
                bases.insert(0, ns0.RetrievePropertiesRequestType_Def)
                ns0.RetrieveProperties_Dec.__bases__ = tuple(bases)

            ns0.RetrievePropertiesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveProperties_Dec_Holder"

    class RetrievePropertiesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrievePropertiesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrievePropertiesResponse_Dec.schema
            TClist = [GTD("urn:vim25","ObjectContent",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrievePropertiesResponse')
            kw["aname"] = "_RetrievePropertiesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrievePropertiesResponse_Holder"
            self.pyclass = Holder

    class CheckForUpdates_Dec(ElementDeclaration):
        literal = "CheckForUpdates"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CheckForUpdates')
            kw["aname"] = "_CheckForUpdates"
            if ns0.CheckForUpdatesRequestType_Def not in ns0.CheckForUpdates_Dec.__bases__:
                bases = list(ns0.CheckForUpdates_Dec.__bases__)
                bases.insert(0, ns0.CheckForUpdatesRequestType_Def)
                ns0.CheckForUpdates_Dec.__bases__ = tuple(bases)

            ns0.CheckForUpdatesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CheckForUpdates_Dec_Holder"

    class CheckForUpdatesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CheckForUpdatesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CheckForUpdatesResponse_Dec.schema
            TClist = [GTD("urn:vim25","UpdateSet",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CheckForUpdatesResponse')
            kw["aname"] = "_CheckForUpdatesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CheckForUpdatesResponse_Holder"
            self.pyclass = Holder

    class WaitForUpdates_Dec(ElementDeclaration):
        literal = "WaitForUpdates"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'WaitForUpdates')
            kw["aname"] = "_WaitForUpdates"
            if ns0.WaitForUpdatesRequestType_Def not in ns0.WaitForUpdates_Dec.__bases__:
                bases = list(ns0.WaitForUpdates_Dec.__bases__)
                bases.insert(0, ns0.WaitForUpdatesRequestType_Def)
                ns0.WaitForUpdates_Dec.__bases__ = tuple(bases)

            ns0.WaitForUpdatesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "WaitForUpdates_Dec_Holder"

    class WaitForUpdatesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "WaitForUpdatesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.WaitForUpdatesResponse_Dec.schema
            TClist = [GTD("urn:vim25","UpdateSet",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'WaitForUpdatesResponse')
            kw["aname"] = "_WaitForUpdatesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "WaitForUpdatesResponse_Holder"
            self.pyclass = Holder

    class CancelWaitForUpdates_Dec(ElementDeclaration):
        literal = "CancelWaitForUpdates"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CancelWaitForUpdates')
            kw["aname"] = "_CancelWaitForUpdates"
            if ns0.CancelWaitForUpdatesRequestType_Def not in ns0.CancelWaitForUpdates_Dec.__bases__:
                bases = list(ns0.CancelWaitForUpdates_Dec.__bases__)
                bases.insert(0, ns0.CancelWaitForUpdatesRequestType_Def)
                ns0.CancelWaitForUpdates_Dec.__bases__ = tuple(bases)

            ns0.CancelWaitForUpdatesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CancelWaitForUpdates_Dec_Holder"

    class CancelWaitForUpdatesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CancelWaitForUpdatesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CancelWaitForUpdatesResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CancelWaitForUpdatesResponse')
            kw["aname"] = "_CancelWaitForUpdatesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CancelWaitForUpdatesResponse_Holder"
            self.pyclass = Holder

    class MethodFaultFault_Dec(ElementDeclaration):
        literal = "MethodFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MethodFaultFault')
            kw["aname"] = "_MethodFaultFault"
            if ns0.MethodFault_Def not in ns0.MethodFaultFault_Dec.__bases__:
                bases = list(ns0.MethodFaultFault_Dec.__bases__)
                bases.insert(0, ns0.MethodFault_Def)
                ns0.MethodFaultFault_Dec.__bases__ = tuple(bases)

            ns0.MethodFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MethodFaultFault_Dec_Holder"

    class RuntimeFaultFault_Dec(ElementDeclaration):
        literal = "RuntimeFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RuntimeFaultFault')
            kw["aname"] = "_RuntimeFaultFault"
            if ns0.RuntimeFault_Def not in ns0.RuntimeFaultFault_Dec.__bases__:
                bases = list(ns0.RuntimeFaultFault_Dec.__bases__)
                bases.insert(0, ns0.RuntimeFault_Def)
                ns0.RuntimeFaultFault_Dec.__bases__ = tuple(bases)

            ns0.RuntimeFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RuntimeFaultFault_Dec_Holder"

    class AddAuthorizationRole_Dec(ElementDeclaration):
        literal = "AddAuthorizationRole"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddAuthorizationRole')
            kw["aname"] = "_AddAuthorizationRole"
            if ns0.AddAuthorizationRoleRequestType_Def not in ns0.AddAuthorizationRole_Dec.__bases__:
                bases = list(ns0.AddAuthorizationRole_Dec.__bases__)
                bases.insert(0, ns0.AddAuthorizationRoleRequestType_Def)
                ns0.AddAuthorizationRole_Dec.__bases__ = tuple(bases)

            ns0.AddAuthorizationRoleRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddAuthorizationRole_Dec_Holder"

    class AddAuthorizationRoleResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddAuthorizationRoleResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddAuthorizationRoleResponse_Dec.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddAuthorizationRoleResponse')
            kw["aname"] = "_AddAuthorizationRoleResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddAuthorizationRoleResponse_Holder"
            self.pyclass = Holder

    class RemoveAuthorizationRole_Dec(ElementDeclaration):
        literal = "RemoveAuthorizationRole"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveAuthorizationRole')
            kw["aname"] = "_RemoveAuthorizationRole"
            if ns0.RemoveAuthorizationRoleRequestType_Def not in ns0.RemoveAuthorizationRole_Dec.__bases__:
                bases = list(ns0.RemoveAuthorizationRole_Dec.__bases__)
                bases.insert(0, ns0.RemoveAuthorizationRoleRequestType_Def)
                ns0.RemoveAuthorizationRole_Dec.__bases__ = tuple(bases)

            ns0.RemoveAuthorizationRoleRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveAuthorizationRole_Dec_Holder"

    class RemoveAuthorizationRoleResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveAuthorizationRoleResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveAuthorizationRoleResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveAuthorizationRoleResponse')
            kw["aname"] = "_RemoveAuthorizationRoleResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveAuthorizationRoleResponse_Holder"
            self.pyclass = Holder

    class UpdateAuthorizationRole_Dec(ElementDeclaration):
        literal = "UpdateAuthorizationRole"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateAuthorizationRole')
            kw["aname"] = "_UpdateAuthorizationRole"
            if ns0.UpdateAuthorizationRoleRequestType_Def not in ns0.UpdateAuthorizationRole_Dec.__bases__:
                bases = list(ns0.UpdateAuthorizationRole_Dec.__bases__)
                bases.insert(0, ns0.UpdateAuthorizationRoleRequestType_Def)
                ns0.UpdateAuthorizationRole_Dec.__bases__ = tuple(bases)

            ns0.UpdateAuthorizationRoleRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateAuthorizationRole_Dec_Holder"

    class UpdateAuthorizationRoleResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateAuthorizationRoleResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateAuthorizationRoleResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateAuthorizationRoleResponse')
            kw["aname"] = "_UpdateAuthorizationRoleResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateAuthorizationRoleResponse_Holder"
            self.pyclass = Holder

    class MergePermissions_Dec(ElementDeclaration):
        literal = "MergePermissions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MergePermissions')
            kw["aname"] = "_MergePermissions"
            if ns0.MergePermissionsRequestType_Def not in ns0.MergePermissions_Dec.__bases__:
                bases = list(ns0.MergePermissions_Dec.__bases__)
                bases.insert(0, ns0.MergePermissionsRequestType_Def)
                ns0.MergePermissions_Dec.__bases__ = tuple(bases)

            ns0.MergePermissionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MergePermissions_Dec_Holder"

    class MergePermissionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MergePermissionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MergePermissionsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MergePermissionsResponse')
            kw["aname"] = "_MergePermissionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MergePermissionsResponse_Holder"
            self.pyclass = Holder

    class RetrieveRolePermissions_Dec(ElementDeclaration):
        literal = "RetrieveRolePermissions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveRolePermissions')
            kw["aname"] = "_RetrieveRolePermissions"
            if ns0.RetrieveRolePermissionsRequestType_Def not in ns0.RetrieveRolePermissions_Dec.__bases__:
                bases = list(ns0.RetrieveRolePermissions_Dec.__bases__)
                bases.insert(0, ns0.RetrieveRolePermissionsRequestType_Def)
                ns0.RetrieveRolePermissions_Dec.__bases__ = tuple(bases)

            ns0.RetrieveRolePermissionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveRolePermissions_Dec_Holder"

    class RetrieveRolePermissionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveRolePermissionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveRolePermissionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","Permission",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveRolePermissionsResponse')
            kw["aname"] = "_RetrieveRolePermissionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrieveRolePermissionsResponse_Holder"
            self.pyclass = Holder

    class RetrieveEntityPermissions_Dec(ElementDeclaration):
        literal = "RetrieveEntityPermissions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveEntityPermissions')
            kw["aname"] = "_RetrieveEntityPermissions"
            if ns0.RetrieveEntityPermissionsRequestType_Def not in ns0.RetrieveEntityPermissions_Dec.__bases__:
                bases = list(ns0.RetrieveEntityPermissions_Dec.__bases__)
                bases.insert(0, ns0.RetrieveEntityPermissionsRequestType_Def)
                ns0.RetrieveEntityPermissions_Dec.__bases__ = tuple(bases)

            ns0.RetrieveEntityPermissionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveEntityPermissions_Dec_Holder"

    class RetrieveEntityPermissionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveEntityPermissionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveEntityPermissionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","Permission",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveEntityPermissionsResponse')
            kw["aname"] = "_RetrieveEntityPermissionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrieveEntityPermissionsResponse_Holder"
            self.pyclass = Holder

    class RetrieveAllPermissions_Dec(ElementDeclaration):
        literal = "RetrieveAllPermissions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveAllPermissions')
            kw["aname"] = "_RetrieveAllPermissions"
            if ns0.RetrieveAllPermissionsRequestType_Def not in ns0.RetrieveAllPermissions_Dec.__bases__:
                bases = list(ns0.RetrieveAllPermissions_Dec.__bases__)
                bases.insert(0, ns0.RetrieveAllPermissionsRequestType_Def)
                ns0.RetrieveAllPermissions_Dec.__bases__ = tuple(bases)

            ns0.RetrieveAllPermissionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveAllPermissions_Dec_Holder"

    class RetrieveAllPermissionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveAllPermissionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveAllPermissionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","Permission",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveAllPermissionsResponse')
            kw["aname"] = "_RetrieveAllPermissionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrieveAllPermissionsResponse_Holder"
            self.pyclass = Holder

    class SetEntityPermissions_Dec(ElementDeclaration):
        literal = "SetEntityPermissions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetEntityPermissions')
            kw["aname"] = "_SetEntityPermissions"
            if ns0.SetEntityPermissionsRequestType_Def not in ns0.SetEntityPermissions_Dec.__bases__:
                bases = list(ns0.SetEntityPermissions_Dec.__bases__)
                bases.insert(0, ns0.SetEntityPermissionsRequestType_Def)
                ns0.SetEntityPermissions_Dec.__bases__ = tuple(bases)

            ns0.SetEntityPermissionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetEntityPermissions_Dec_Holder"

    class SetEntityPermissionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetEntityPermissionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetEntityPermissionsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetEntityPermissionsResponse')
            kw["aname"] = "_SetEntityPermissionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetEntityPermissionsResponse_Holder"
            self.pyclass = Holder

    class ResetEntityPermissions_Dec(ElementDeclaration):
        literal = "ResetEntityPermissions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetEntityPermissions')
            kw["aname"] = "_ResetEntityPermissions"
            if ns0.ResetEntityPermissionsRequestType_Def not in ns0.ResetEntityPermissions_Dec.__bases__:
                bases = list(ns0.ResetEntityPermissions_Dec.__bases__)
                bases.insert(0, ns0.ResetEntityPermissionsRequestType_Def)
                ns0.ResetEntityPermissions_Dec.__bases__ = tuple(bases)

            ns0.ResetEntityPermissionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetEntityPermissions_Dec_Holder"

    class ResetEntityPermissionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetEntityPermissionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetEntityPermissionsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ResetEntityPermissionsResponse')
            kw["aname"] = "_ResetEntityPermissionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ResetEntityPermissionsResponse_Holder"
            self.pyclass = Holder

    class RemoveEntityPermission_Dec(ElementDeclaration):
        literal = "RemoveEntityPermission"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveEntityPermission')
            kw["aname"] = "_RemoveEntityPermission"
            if ns0.RemoveEntityPermissionRequestType_Def not in ns0.RemoveEntityPermission_Dec.__bases__:
                bases = list(ns0.RemoveEntityPermission_Dec.__bases__)
                bases.insert(0, ns0.RemoveEntityPermissionRequestType_Def)
                ns0.RemoveEntityPermission_Dec.__bases__ = tuple(bases)

            ns0.RemoveEntityPermissionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveEntityPermission_Dec_Holder"

    class RemoveEntityPermissionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveEntityPermissionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveEntityPermissionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveEntityPermissionResponse')
            kw["aname"] = "_RemoveEntityPermissionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveEntityPermissionResponse_Holder"
            self.pyclass = Holder

    class ReconfigureCluster_Dec(ElementDeclaration):
        literal = "ReconfigureCluster"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureCluster')
            kw["aname"] = "_ReconfigureCluster"
            if ns0.ReconfigureClusterRequestType_Def not in ns0.ReconfigureCluster_Dec.__bases__:
                bases = list(ns0.ReconfigureCluster_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureClusterRequestType_Def)
                ns0.ReconfigureCluster_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureClusterRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureCluster_Dec_Holder"

    class ReconfigureClusterResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureClusterResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureClusterResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureClusterResponse')
            kw["aname"] = "_ReconfigureClusterResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureClusterResponse_Holder"
            self.pyclass = Holder

    class ReconfigureCluster_Task_Dec(ElementDeclaration):
        literal = "ReconfigureCluster_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureCluster_Task')
            kw["aname"] = "_ReconfigureCluster_Task"
            if ns0.ReconfigureClusterRequestType_Def not in ns0.ReconfigureCluster_Task_Dec.__bases__:
                bases = list(ns0.ReconfigureCluster_Task_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureClusterRequestType_Def)
                ns0.ReconfigureCluster_Task_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureClusterRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureCluster_Task_Dec_Holder"

    class ReconfigureCluster_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureCluster_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureCluster_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReconfigureCluster_TaskResponse')
            kw["aname"] = "_ReconfigureCluster_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ReconfigureCluster_TaskResponse_Holder"
            self.pyclass = Holder

    class ApplyRecommendation_Dec(ElementDeclaration):
        literal = "ApplyRecommendation"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ApplyRecommendation')
            kw["aname"] = "_ApplyRecommendation"
            if ns0.ApplyRecommendationRequestType_Def not in ns0.ApplyRecommendation_Dec.__bases__:
                bases = list(ns0.ApplyRecommendation_Dec.__bases__)
                bases.insert(0, ns0.ApplyRecommendationRequestType_Def)
                ns0.ApplyRecommendation_Dec.__bases__ = tuple(bases)

            ns0.ApplyRecommendationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ApplyRecommendation_Dec_Holder"

    class ApplyRecommendationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ApplyRecommendationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ApplyRecommendationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ApplyRecommendationResponse')
            kw["aname"] = "_ApplyRecommendationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ApplyRecommendationResponse_Holder"
            self.pyclass = Holder

    class RecommendHostsForVm_Dec(ElementDeclaration):
        literal = "RecommendHostsForVm"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RecommendHostsForVm')
            kw["aname"] = "_RecommendHostsForVm"
            if ns0.RecommendHostsForVmRequestType_Def not in ns0.RecommendHostsForVm_Dec.__bases__:
                bases = list(ns0.RecommendHostsForVm_Dec.__bases__)
                bases.insert(0, ns0.RecommendHostsForVmRequestType_Def)
                ns0.RecommendHostsForVm_Dec.__bases__ = tuple(bases)

            ns0.RecommendHostsForVmRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RecommendHostsForVm_Dec_Holder"

    class RecommendHostsForVmResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RecommendHostsForVmResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RecommendHostsForVmResponse_Dec.schema
            TClist = [GTD("urn:vim25","ClusterHostRecommendation",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RecommendHostsForVmResponse')
            kw["aname"] = "_RecommendHostsForVmResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RecommendHostsForVmResponse_Holder"
            self.pyclass = Holder

    class AddHost_Dec(ElementDeclaration):
        literal = "AddHost"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddHost')
            kw["aname"] = "_AddHost"
            if ns0.AddHostRequestType_Def not in ns0.AddHost_Dec.__bases__:
                bases = list(ns0.AddHost_Dec.__bases__)
                bases.insert(0, ns0.AddHostRequestType_Def)
                ns0.AddHost_Dec.__bases__ = tuple(bases)

            ns0.AddHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddHost_Dec_Holder"

    class AddHostResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddHostResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddHostResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddHostResponse')
            kw["aname"] = "_AddHostResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddHostResponse_Holder"
            self.pyclass = Holder

    class AddHost_Task_Dec(ElementDeclaration):
        literal = "AddHost_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddHost_Task')
            kw["aname"] = "_AddHost_Task"
            if ns0.AddHostRequestType_Def not in ns0.AddHost_Task_Dec.__bases__:
                bases = list(ns0.AddHost_Task_Dec.__bases__)
                bases.insert(0, ns0.AddHostRequestType_Def)
                ns0.AddHost_Task_Dec.__bases__ = tuple(bases)

            ns0.AddHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddHost_Task_Dec_Holder"

    class AddHost_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddHost_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddHost_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddHost_TaskResponse')
            kw["aname"] = "_AddHost_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddHost_TaskResponse_Holder"
            self.pyclass = Holder

    class MoveInto_Dec(ElementDeclaration):
        literal = "MoveInto"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveInto')
            kw["aname"] = "_MoveInto"
            if ns0.MoveIntoRequestType_Def not in ns0.MoveInto_Dec.__bases__:
                bases = list(ns0.MoveInto_Dec.__bases__)
                bases.insert(0, ns0.MoveIntoRequestType_Def)
                ns0.MoveInto_Dec.__bases__ = tuple(bases)

            ns0.MoveIntoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveInto_Dec_Holder"

    class MoveIntoResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveIntoResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveIntoResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MoveIntoResponse')
            kw["aname"] = "_MoveIntoResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MoveIntoResponse_Holder"
            self.pyclass = Holder

    class MoveInto_Task_Dec(ElementDeclaration):
        literal = "MoveInto_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveInto_Task')
            kw["aname"] = "_MoveInto_Task"
            if ns0.MoveIntoRequestType_Def not in ns0.MoveInto_Task_Dec.__bases__:
                bases = list(ns0.MoveInto_Task_Dec.__bases__)
                bases.insert(0, ns0.MoveIntoRequestType_Def)
                ns0.MoveInto_Task_Dec.__bases__ = tuple(bases)

            ns0.MoveIntoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveInto_Task_Dec_Holder"

    class MoveInto_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveInto_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveInto_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'MoveInto_TaskResponse')
            kw["aname"] = "_MoveInto_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "MoveInto_TaskResponse_Holder"
            self.pyclass = Holder

    class MoveHostInto_Dec(ElementDeclaration):
        literal = "MoveHostInto"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveHostInto')
            kw["aname"] = "_MoveHostInto"
            if ns0.MoveHostIntoRequestType_Def not in ns0.MoveHostInto_Dec.__bases__:
                bases = list(ns0.MoveHostInto_Dec.__bases__)
                bases.insert(0, ns0.MoveHostIntoRequestType_Def)
                ns0.MoveHostInto_Dec.__bases__ = tuple(bases)

            ns0.MoveHostIntoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveHostInto_Dec_Holder"

    class MoveHostIntoResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveHostIntoResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveHostIntoResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MoveHostIntoResponse')
            kw["aname"] = "_MoveHostIntoResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MoveHostIntoResponse_Holder"
            self.pyclass = Holder

    class MoveHostInto_Task_Dec(ElementDeclaration):
        literal = "MoveHostInto_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveHostInto_Task')
            kw["aname"] = "_MoveHostInto_Task"
            if ns0.MoveHostIntoRequestType_Def not in ns0.MoveHostInto_Task_Dec.__bases__:
                bases = list(ns0.MoveHostInto_Task_Dec.__bases__)
                bases.insert(0, ns0.MoveHostIntoRequestType_Def)
                ns0.MoveHostInto_Task_Dec.__bases__ = tuple(bases)

            ns0.MoveHostIntoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveHostInto_Task_Dec_Holder"

    class MoveHostInto_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveHostInto_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveHostInto_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'MoveHostInto_TaskResponse')
            kw["aname"] = "_MoveHostInto_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "MoveHostInto_TaskResponse_Holder"
            self.pyclass = Holder

    class RefreshRecommendation_Dec(ElementDeclaration):
        literal = "RefreshRecommendation"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshRecommendation')
            kw["aname"] = "_RefreshRecommendation"
            if ns0.RefreshRecommendationRequestType_Def not in ns0.RefreshRecommendation_Dec.__bases__:
                bases = list(ns0.RefreshRecommendation_Dec.__bases__)
                bases.insert(0, ns0.RefreshRecommendationRequestType_Def)
                ns0.RefreshRecommendation_Dec.__bases__ = tuple(bases)

            ns0.RefreshRecommendationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshRecommendation_Dec_Holder"

    class RefreshRecommendationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshRecommendationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshRecommendationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshRecommendationResponse')
            kw["aname"] = "_RefreshRecommendationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshRecommendationResponse_Holder"
            self.pyclass = Holder

    class ReconfigureComputeResource_Dec(ElementDeclaration):
        literal = "ReconfigureComputeResource"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureComputeResource')
            kw["aname"] = "_ReconfigureComputeResource"
            if ns0.ReconfigureComputeResourceRequestType_Def not in ns0.ReconfigureComputeResource_Dec.__bases__:
                bases = list(ns0.ReconfigureComputeResource_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureComputeResourceRequestType_Def)
                ns0.ReconfigureComputeResource_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureComputeResourceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureComputeResource_Dec_Holder"

    class ReconfigureComputeResourceResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureComputeResourceResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureComputeResourceResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureComputeResourceResponse')
            kw["aname"] = "_ReconfigureComputeResourceResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureComputeResourceResponse_Holder"
            self.pyclass = Holder

    class ReconfigureComputeResource_Task_Dec(ElementDeclaration):
        literal = "ReconfigureComputeResource_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureComputeResource_Task')
            kw["aname"] = "_ReconfigureComputeResource_Task"
            if ns0.ReconfigureComputeResourceRequestType_Def not in ns0.ReconfigureComputeResource_Task_Dec.__bases__:
                bases = list(ns0.ReconfigureComputeResource_Task_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureComputeResourceRequestType_Def)
                ns0.ReconfigureComputeResource_Task_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureComputeResourceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureComputeResource_Task_Dec_Holder"

    class ReconfigureComputeResource_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureComputeResource_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureComputeResource_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReconfigureComputeResource_TaskResponse')
            kw["aname"] = "_ReconfigureComputeResource_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ReconfigureComputeResource_TaskResponse_Holder"
            self.pyclass = Holder

    class AddCustomFieldDef_Dec(ElementDeclaration):
        literal = "AddCustomFieldDef"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddCustomFieldDef')
            kw["aname"] = "_AddCustomFieldDef"
            if ns0.AddCustomFieldDefRequestType_Def not in ns0.AddCustomFieldDef_Dec.__bases__:
                bases = list(ns0.AddCustomFieldDef_Dec.__bases__)
                bases.insert(0, ns0.AddCustomFieldDefRequestType_Def)
                ns0.AddCustomFieldDef_Dec.__bases__ = tuple(bases)

            ns0.AddCustomFieldDefRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddCustomFieldDef_Dec_Holder"

    class AddCustomFieldDefResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddCustomFieldDefResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddCustomFieldDefResponse_Dec.schema
            TClist = [GTD("urn:vim25","CustomFieldDef",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddCustomFieldDefResponse')
            kw["aname"] = "_AddCustomFieldDefResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddCustomFieldDefResponse_Holder"
            self.pyclass = Holder

    class RemoveCustomFieldDef_Dec(ElementDeclaration):
        literal = "RemoveCustomFieldDef"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveCustomFieldDef')
            kw["aname"] = "_RemoveCustomFieldDef"
            if ns0.RemoveCustomFieldDefRequestType_Def not in ns0.RemoveCustomFieldDef_Dec.__bases__:
                bases = list(ns0.RemoveCustomFieldDef_Dec.__bases__)
                bases.insert(0, ns0.RemoveCustomFieldDefRequestType_Def)
                ns0.RemoveCustomFieldDef_Dec.__bases__ = tuple(bases)

            ns0.RemoveCustomFieldDefRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveCustomFieldDef_Dec_Holder"

    class RemoveCustomFieldDefResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveCustomFieldDefResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveCustomFieldDefResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveCustomFieldDefResponse')
            kw["aname"] = "_RemoveCustomFieldDefResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveCustomFieldDefResponse_Holder"
            self.pyclass = Holder

    class RenameCustomFieldDef_Dec(ElementDeclaration):
        literal = "RenameCustomFieldDef"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RenameCustomFieldDef')
            kw["aname"] = "_RenameCustomFieldDef"
            if ns0.RenameCustomFieldDefRequestType_Def not in ns0.RenameCustomFieldDef_Dec.__bases__:
                bases = list(ns0.RenameCustomFieldDef_Dec.__bases__)
                bases.insert(0, ns0.RenameCustomFieldDefRequestType_Def)
                ns0.RenameCustomFieldDef_Dec.__bases__ = tuple(bases)

            ns0.RenameCustomFieldDefRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RenameCustomFieldDef_Dec_Holder"

    class RenameCustomFieldDefResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RenameCustomFieldDefResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RenameCustomFieldDefResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RenameCustomFieldDefResponse')
            kw["aname"] = "_RenameCustomFieldDefResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RenameCustomFieldDefResponse_Holder"
            self.pyclass = Holder

    class SetField_Dec(ElementDeclaration):
        literal = "SetField"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetField')
            kw["aname"] = "_SetField"
            if ns0.SetFieldRequestType_Def not in ns0.SetField_Dec.__bases__:
                bases = list(ns0.SetField_Dec.__bases__)
                bases.insert(0, ns0.SetFieldRequestType_Def)
                ns0.SetField_Dec.__bases__ = tuple(bases)

            ns0.SetFieldRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetField_Dec_Holder"

    class SetFieldResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetFieldResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetFieldResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetFieldResponse')
            kw["aname"] = "_SetFieldResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetFieldResponse_Holder"
            self.pyclass = Holder

    class DoesCustomizationSpecExist_Dec(ElementDeclaration):
        literal = "DoesCustomizationSpecExist"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DoesCustomizationSpecExist')
            kw["aname"] = "_DoesCustomizationSpecExist"
            if ns0.DoesCustomizationSpecExistRequestType_Def not in ns0.DoesCustomizationSpecExist_Dec.__bases__:
                bases = list(ns0.DoesCustomizationSpecExist_Dec.__bases__)
                bases.insert(0, ns0.DoesCustomizationSpecExistRequestType_Def)
                ns0.DoesCustomizationSpecExist_Dec.__bases__ = tuple(bases)

            ns0.DoesCustomizationSpecExistRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DoesCustomizationSpecExist_Dec_Holder"

    class DoesCustomizationSpecExistResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DoesCustomizationSpecExistResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DoesCustomizationSpecExistResponse_Dec.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'DoesCustomizationSpecExistResponse')
            kw["aname"] = "_DoesCustomizationSpecExistResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "DoesCustomizationSpecExistResponse_Holder"
            self.pyclass = Holder

    class GetCustomizationSpec_Dec(ElementDeclaration):
        literal = "GetCustomizationSpec"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GetCustomizationSpec')
            kw["aname"] = "_GetCustomizationSpec"
            if ns0.GetCustomizationSpecRequestType_Def not in ns0.GetCustomizationSpec_Dec.__bases__:
                bases = list(ns0.GetCustomizationSpec_Dec.__bases__)
                bases.insert(0, ns0.GetCustomizationSpecRequestType_Def)
                ns0.GetCustomizationSpec_Dec.__bases__ = tuple(bases)

            ns0.GetCustomizationSpecRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GetCustomizationSpec_Dec_Holder"

    class GetCustomizationSpecResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "GetCustomizationSpecResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.GetCustomizationSpecResponse_Dec.schema
            TClist = [GTD("urn:vim25","CustomizationSpecItem",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'GetCustomizationSpecResponse')
            kw["aname"] = "_GetCustomizationSpecResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "GetCustomizationSpecResponse_Holder"
            self.pyclass = Holder

    class CreateCustomizationSpec_Dec(ElementDeclaration):
        literal = "CreateCustomizationSpec"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateCustomizationSpec')
            kw["aname"] = "_CreateCustomizationSpec"
            if ns0.CreateCustomizationSpecRequestType_Def not in ns0.CreateCustomizationSpec_Dec.__bases__:
                bases = list(ns0.CreateCustomizationSpec_Dec.__bases__)
                bases.insert(0, ns0.CreateCustomizationSpecRequestType_Def)
                ns0.CreateCustomizationSpec_Dec.__bases__ = tuple(bases)

            ns0.CreateCustomizationSpecRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateCustomizationSpec_Dec_Holder"

    class CreateCustomizationSpecResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateCustomizationSpecResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateCustomizationSpecResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CreateCustomizationSpecResponse')
            kw["aname"] = "_CreateCustomizationSpecResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CreateCustomizationSpecResponse_Holder"
            self.pyclass = Holder

    class OverwriteCustomizationSpec_Dec(ElementDeclaration):
        literal = "OverwriteCustomizationSpec"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'OverwriteCustomizationSpec')
            kw["aname"] = "_OverwriteCustomizationSpec"
            if ns0.OverwriteCustomizationSpecRequestType_Def not in ns0.OverwriteCustomizationSpec_Dec.__bases__:
                bases = list(ns0.OverwriteCustomizationSpec_Dec.__bases__)
                bases.insert(0, ns0.OverwriteCustomizationSpecRequestType_Def)
                ns0.OverwriteCustomizationSpec_Dec.__bases__ = tuple(bases)

            ns0.OverwriteCustomizationSpecRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "OverwriteCustomizationSpec_Dec_Holder"

    class OverwriteCustomizationSpecResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "OverwriteCustomizationSpecResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.OverwriteCustomizationSpecResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'OverwriteCustomizationSpecResponse')
            kw["aname"] = "_OverwriteCustomizationSpecResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "OverwriteCustomizationSpecResponse_Holder"
            self.pyclass = Holder

    class DeleteCustomizationSpec_Dec(ElementDeclaration):
        literal = "DeleteCustomizationSpec"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeleteCustomizationSpec')
            kw["aname"] = "_DeleteCustomizationSpec"
            if ns0.DeleteCustomizationSpecRequestType_Def not in ns0.DeleteCustomizationSpec_Dec.__bases__:
                bases = list(ns0.DeleteCustomizationSpec_Dec.__bases__)
                bases.insert(0, ns0.DeleteCustomizationSpecRequestType_Def)
                ns0.DeleteCustomizationSpec_Dec.__bases__ = tuple(bases)

            ns0.DeleteCustomizationSpecRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeleteCustomizationSpec_Dec_Holder"

    class DeleteCustomizationSpecResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DeleteCustomizationSpecResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DeleteCustomizationSpecResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DeleteCustomizationSpecResponse')
            kw["aname"] = "_DeleteCustomizationSpecResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DeleteCustomizationSpecResponse_Holder"
            self.pyclass = Holder

    class DuplicateCustomizationSpec_Dec(ElementDeclaration):
        literal = "DuplicateCustomizationSpec"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DuplicateCustomizationSpec')
            kw["aname"] = "_DuplicateCustomizationSpec"
            if ns0.DuplicateCustomizationSpecRequestType_Def not in ns0.DuplicateCustomizationSpec_Dec.__bases__:
                bases = list(ns0.DuplicateCustomizationSpec_Dec.__bases__)
                bases.insert(0, ns0.DuplicateCustomizationSpecRequestType_Def)
                ns0.DuplicateCustomizationSpec_Dec.__bases__ = tuple(bases)

            ns0.DuplicateCustomizationSpecRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DuplicateCustomizationSpec_Dec_Holder"

    class DuplicateCustomizationSpecResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DuplicateCustomizationSpecResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DuplicateCustomizationSpecResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DuplicateCustomizationSpecResponse')
            kw["aname"] = "_DuplicateCustomizationSpecResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DuplicateCustomizationSpecResponse_Holder"
            self.pyclass = Holder

    class RenameCustomizationSpec_Dec(ElementDeclaration):
        literal = "RenameCustomizationSpec"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RenameCustomizationSpec')
            kw["aname"] = "_RenameCustomizationSpec"
            if ns0.RenameCustomizationSpecRequestType_Def not in ns0.RenameCustomizationSpec_Dec.__bases__:
                bases = list(ns0.RenameCustomizationSpec_Dec.__bases__)
                bases.insert(0, ns0.RenameCustomizationSpecRequestType_Def)
                ns0.RenameCustomizationSpec_Dec.__bases__ = tuple(bases)

            ns0.RenameCustomizationSpecRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RenameCustomizationSpec_Dec_Holder"

    class RenameCustomizationSpecResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RenameCustomizationSpecResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RenameCustomizationSpecResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RenameCustomizationSpecResponse')
            kw["aname"] = "_RenameCustomizationSpecResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RenameCustomizationSpecResponse_Holder"
            self.pyclass = Holder

    class CustomizationSpecItemToXml_Dec(ElementDeclaration):
        literal = "CustomizationSpecItemToXml"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CustomizationSpecItemToXml')
            kw["aname"] = "_CustomizationSpecItemToXml"
            if ns0.CustomizationSpecItemToXmlRequestType_Def not in ns0.CustomizationSpecItemToXml_Dec.__bases__:
                bases = list(ns0.CustomizationSpecItemToXml_Dec.__bases__)
                bases.insert(0, ns0.CustomizationSpecItemToXmlRequestType_Def)
                ns0.CustomizationSpecItemToXml_Dec.__bases__ = tuple(bases)

            ns0.CustomizationSpecItemToXmlRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CustomizationSpecItemToXml_Dec_Holder"

    class CustomizationSpecItemToXmlResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CustomizationSpecItemToXmlResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CustomizationSpecItemToXmlResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CustomizationSpecItemToXmlResponse')
            kw["aname"] = "_CustomizationSpecItemToXmlResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CustomizationSpecItemToXmlResponse_Holder"
            self.pyclass = Holder

    class XmlToCustomizationSpecItem_Dec(ElementDeclaration):
        literal = "XmlToCustomizationSpecItem"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'XmlToCustomizationSpecItem')
            kw["aname"] = "_XmlToCustomizationSpecItem"
            if ns0.XmlToCustomizationSpecItemRequestType_Def not in ns0.XmlToCustomizationSpecItem_Dec.__bases__:
                bases = list(ns0.XmlToCustomizationSpecItem_Dec.__bases__)
                bases.insert(0, ns0.XmlToCustomizationSpecItemRequestType_Def)
                ns0.XmlToCustomizationSpecItem_Dec.__bases__ = tuple(bases)

            ns0.XmlToCustomizationSpecItemRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "XmlToCustomizationSpecItem_Dec_Holder"

    class XmlToCustomizationSpecItemResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "XmlToCustomizationSpecItemResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.XmlToCustomizationSpecItemResponse_Dec.schema
            TClist = [GTD("urn:vim25","CustomizationSpecItem",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'XmlToCustomizationSpecItemResponse')
            kw["aname"] = "_XmlToCustomizationSpecItemResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "XmlToCustomizationSpecItemResponse_Holder"
            self.pyclass = Holder

    class CheckCustomizationResources_Dec(ElementDeclaration):
        literal = "CheckCustomizationResources"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CheckCustomizationResources')
            kw["aname"] = "_CheckCustomizationResources"
            if ns0.CheckCustomizationResourcesRequestType_Def not in ns0.CheckCustomizationResources_Dec.__bases__:
                bases = list(ns0.CheckCustomizationResources_Dec.__bases__)
                bases.insert(0, ns0.CheckCustomizationResourcesRequestType_Def)
                ns0.CheckCustomizationResources_Dec.__bases__ = tuple(bases)

            ns0.CheckCustomizationResourcesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CheckCustomizationResources_Dec_Holder"

    class CheckCustomizationResourcesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CheckCustomizationResourcesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CheckCustomizationResourcesResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CheckCustomizationResourcesResponse')
            kw["aname"] = "_CheckCustomizationResourcesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CheckCustomizationResourcesResponse_Holder"
            self.pyclass = Holder

    class QueryConnectionInfo_Dec(ElementDeclaration):
        literal = "QueryConnectionInfo"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryConnectionInfo')
            kw["aname"] = "_QueryConnectionInfo"
            if ns0.QueryConnectionInfoRequestType_Def not in ns0.QueryConnectionInfo_Dec.__bases__:
                bases = list(ns0.QueryConnectionInfo_Dec.__bases__)
                bases.insert(0, ns0.QueryConnectionInfoRequestType_Def)
                ns0.QueryConnectionInfo_Dec.__bases__ = tuple(bases)

            ns0.QueryConnectionInfoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryConnectionInfo_Dec_Holder"

    class QueryConnectionInfoResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryConnectionInfoResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryConnectionInfoResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostConnectInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryConnectionInfoResponse')
            kw["aname"] = "_QueryConnectionInfoResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryConnectionInfoResponse_Holder"
            self.pyclass = Holder

    class PowerOnMultiVM_Dec(ElementDeclaration):
        literal = "PowerOnMultiVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerOnMultiVM')
            kw["aname"] = "_PowerOnMultiVM"
            if ns0.PowerOnMultiVMRequestType_Def not in ns0.PowerOnMultiVM_Dec.__bases__:
                bases = list(ns0.PowerOnMultiVM_Dec.__bases__)
                bases.insert(0, ns0.PowerOnMultiVMRequestType_Def)
                ns0.PowerOnMultiVM_Dec.__bases__ = tuple(bases)

            ns0.PowerOnMultiVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerOnMultiVM_Dec_Holder"

    class PowerOnMultiVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerOnMultiVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerOnMultiVMResponse_Dec.schema
            TClist = [GTD("urn:vim25","ClusterPowerOnVmResult",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'PowerOnMultiVMResponse')
            kw["aname"] = "_PowerOnMultiVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "PowerOnMultiVMResponse_Holder"
            self.pyclass = Holder

    class PowerOnMultiVM_Task_Dec(ElementDeclaration):
        literal = "PowerOnMultiVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerOnMultiVM_Task')
            kw["aname"] = "_PowerOnMultiVM_Task"
            if ns0.PowerOnMultiVMRequestType_Def not in ns0.PowerOnMultiVM_Task_Dec.__bases__:
                bases = list(ns0.PowerOnMultiVM_Task_Dec.__bases__)
                bases.insert(0, ns0.PowerOnMultiVMRequestType_Def)
                ns0.PowerOnMultiVM_Task_Dec.__bases__ = tuple(bases)

            ns0.PowerOnMultiVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerOnMultiVM_Task_Dec_Holder"

    class PowerOnMultiVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerOnMultiVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerOnMultiVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'PowerOnMultiVM_TaskResponse')
            kw["aname"] = "_PowerOnMultiVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "PowerOnMultiVM_TaskResponse_Holder"
            self.pyclass = Holder

    class RenameDatastore_Dec(ElementDeclaration):
        literal = "RenameDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RenameDatastore')
            kw["aname"] = "_RenameDatastore"
            if ns0.RenameDatastoreRequestType_Def not in ns0.RenameDatastore_Dec.__bases__:
                bases = list(ns0.RenameDatastore_Dec.__bases__)
                bases.insert(0, ns0.RenameDatastoreRequestType_Def)
                ns0.RenameDatastore_Dec.__bases__ = tuple(bases)

            ns0.RenameDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RenameDatastore_Dec_Holder"

    class RenameDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RenameDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RenameDatastoreResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RenameDatastoreResponse')
            kw["aname"] = "_RenameDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RenameDatastoreResponse_Holder"
            self.pyclass = Holder

    class RefreshDatastore_Dec(ElementDeclaration):
        literal = "RefreshDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshDatastore')
            kw["aname"] = "_RefreshDatastore"
            if ns0.RefreshDatastoreRequestType_Def not in ns0.RefreshDatastore_Dec.__bases__:
                bases = list(ns0.RefreshDatastore_Dec.__bases__)
                bases.insert(0, ns0.RefreshDatastoreRequestType_Def)
                ns0.RefreshDatastore_Dec.__bases__ = tuple(bases)

            ns0.RefreshDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshDatastore_Dec_Holder"

    class RefreshDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshDatastoreResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshDatastoreResponse')
            kw["aname"] = "_RefreshDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshDatastoreResponse_Holder"
            self.pyclass = Holder

    class DestroyDatastore_Dec(ElementDeclaration):
        literal = "DestroyDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DestroyDatastore')
            kw["aname"] = "_DestroyDatastore"
            if ns0.DestroyDatastoreRequestType_Def not in ns0.DestroyDatastore_Dec.__bases__:
                bases = list(ns0.DestroyDatastore_Dec.__bases__)
                bases.insert(0, ns0.DestroyDatastoreRequestType_Def)
                ns0.DestroyDatastore_Dec.__bases__ = tuple(bases)

            ns0.DestroyDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DestroyDatastore_Dec_Holder"

    class DestroyDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DestroyDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DestroyDatastoreResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DestroyDatastoreResponse')
            kw["aname"] = "_DestroyDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DestroyDatastoreResponse_Holder"
            self.pyclass = Holder

    class QueryDescriptions_Dec(ElementDeclaration):
        literal = "QueryDescriptions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryDescriptions')
            kw["aname"] = "_QueryDescriptions"
            if ns0.QueryDescriptionsRequestType_Def not in ns0.QueryDescriptions_Dec.__bases__:
                bases = list(ns0.QueryDescriptions_Dec.__bases__)
                bases.insert(0, ns0.QueryDescriptionsRequestType_Def)
                ns0.QueryDescriptions_Dec.__bases__ = tuple(bases)

            ns0.QueryDescriptionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryDescriptions_Dec_Holder"

    class QueryDescriptionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryDescriptionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryDescriptionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","DiagnosticManagerLogDescriptor",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryDescriptionsResponse')
            kw["aname"] = "_QueryDescriptionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryDescriptionsResponse_Holder"
            self.pyclass = Holder

    class BrowseDiagnosticLog_Dec(ElementDeclaration):
        literal = "BrowseDiagnosticLog"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'BrowseDiagnosticLog')
            kw["aname"] = "_BrowseDiagnosticLog"
            if ns0.BrowseDiagnosticLogRequestType_Def not in ns0.BrowseDiagnosticLog_Dec.__bases__:
                bases = list(ns0.BrowseDiagnosticLog_Dec.__bases__)
                bases.insert(0, ns0.BrowseDiagnosticLogRequestType_Def)
                ns0.BrowseDiagnosticLog_Dec.__bases__ = tuple(bases)

            ns0.BrowseDiagnosticLogRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "BrowseDiagnosticLog_Dec_Holder"

    class BrowseDiagnosticLogResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "BrowseDiagnosticLogResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.BrowseDiagnosticLogResponse_Dec.schema
            TClist = [GTD("urn:vim25","DiagnosticManagerLogHeader",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'BrowseDiagnosticLogResponse')
            kw["aname"] = "_BrowseDiagnosticLogResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "BrowseDiagnosticLogResponse_Holder"
            self.pyclass = Holder

    class GenerateLogBundles_Dec(ElementDeclaration):
        literal = "GenerateLogBundles"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GenerateLogBundles')
            kw["aname"] = "_GenerateLogBundles"
            if ns0.GenerateLogBundlesRequestType_Def not in ns0.GenerateLogBundles_Dec.__bases__:
                bases = list(ns0.GenerateLogBundles_Dec.__bases__)
                bases.insert(0, ns0.GenerateLogBundlesRequestType_Def)
                ns0.GenerateLogBundles_Dec.__bases__ = tuple(bases)

            ns0.GenerateLogBundlesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GenerateLogBundles_Dec_Holder"

    class GenerateLogBundlesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "GenerateLogBundlesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.GenerateLogBundlesResponse_Dec.schema
            TClist = [GTD("urn:vim25","DiagnosticManagerBundleInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'GenerateLogBundlesResponse')
            kw["aname"] = "_GenerateLogBundlesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "GenerateLogBundlesResponse_Holder"
            self.pyclass = Holder

    class GenerateLogBundles_Task_Dec(ElementDeclaration):
        literal = "GenerateLogBundles_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GenerateLogBundles_Task')
            kw["aname"] = "_GenerateLogBundles_Task"
            if ns0.GenerateLogBundlesRequestType_Def not in ns0.GenerateLogBundles_Task_Dec.__bases__:
                bases = list(ns0.GenerateLogBundles_Task_Dec.__bases__)
                bases.insert(0, ns0.GenerateLogBundlesRequestType_Def)
                ns0.GenerateLogBundles_Task_Dec.__bases__ = tuple(bases)

            ns0.GenerateLogBundlesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GenerateLogBundles_Task_Dec_Holder"

    class GenerateLogBundles_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "GenerateLogBundles_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.GenerateLogBundles_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'GenerateLogBundles_TaskResponse')
            kw["aname"] = "_GenerateLogBundles_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "GenerateLogBundles_TaskResponse_Holder"
            self.pyclass = Holder

    class QueryConfigOptionDescriptor_Dec(ElementDeclaration):
        literal = "QueryConfigOptionDescriptor"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryConfigOptionDescriptor')
            kw["aname"] = "_QueryConfigOptionDescriptor"
            if ns0.QueryConfigOptionDescriptorRequestType_Def not in ns0.QueryConfigOptionDescriptor_Dec.__bases__:
                bases = list(ns0.QueryConfigOptionDescriptor_Dec.__bases__)
                bases.insert(0, ns0.QueryConfigOptionDescriptorRequestType_Def)
                ns0.QueryConfigOptionDescriptor_Dec.__bases__ = tuple(bases)

            ns0.QueryConfigOptionDescriptorRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryConfigOptionDescriptor_Dec_Holder"

    class QueryConfigOptionDescriptorResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryConfigOptionDescriptorResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryConfigOptionDescriptorResponse_Dec.schema
            TClist = [GTD("urn:vim25","VirtualMachineConfigOptionDescriptor",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryConfigOptionDescriptorResponse')
            kw["aname"] = "_QueryConfigOptionDescriptorResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryConfigOptionDescriptorResponse_Holder"
            self.pyclass = Holder

    class QueryConfigOption_Dec(ElementDeclaration):
        literal = "QueryConfigOption"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryConfigOption')
            kw["aname"] = "_QueryConfigOption"
            if ns0.QueryConfigOptionRequestType_Def not in ns0.QueryConfigOption_Dec.__bases__:
                bases = list(ns0.QueryConfigOption_Dec.__bases__)
                bases.insert(0, ns0.QueryConfigOptionRequestType_Def)
                ns0.QueryConfigOption_Dec.__bases__ = tuple(bases)

            ns0.QueryConfigOptionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryConfigOption_Dec_Holder"

    class QueryConfigOptionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryConfigOptionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryConfigOptionResponse_Dec.schema
            TClist = [GTD("urn:vim25","VirtualMachineConfigOption",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryConfigOptionResponse')
            kw["aname"] = "_QueryConfigOptionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryConfigOptionResponse_Holder"
            self.pyclass = Holder

    class QueryConfigTarget_Dec(ElementDeclaration):
        literal = "QueryConfigTarget"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryConfigTarget')
            kw["aname"] = "_QueryConfigTarget"
            if ns0.QueryConfigTargetRequestType_Def not in ns0.QueryConfigTarget_Dec.__bases__:
                bases = list(ns0.QueryConfigTarget_Dec.__bases__)
                bases.insert(0, ns0.QueryConfigTargetRequestType_Def)
                ns0.QueryConfigTarget_Dec.__bases__ = tuple(bases)

            ns0.QueryConfigTargetRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryConfigTarget_Dec_Holder"

    class QueryConfigTargetResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryConfigTargetResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryConfigTargetResponse_Dec.schema
            TClist = [GTD("urn:vim25","ConfigTarget",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryConfigTargetResponse')
            kw["aname"] = "_QueryConfigTargetResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryConfigTargetResponse_Holder"
            self.pyclass = Holder

    class setCustomValue_Dec(ElementDeclaration):
        literal = "setCustomValue"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'setCustomValue')
            kw["aname"] = "_setCustomValue"
            if ns0.setCustomValueRequestType_Def not in ns0.setCustomValue_Dec.__bases__:
                bases = list(ns0.setCustomValue_Dec.__bases__)
                bases.insert(0, ns0.setCustomValueRequestType_Def)
                ns0.setCustomValue_Dec.__bases__ = tuple(bases)

            ns0.setCustomValueRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "setCustomValue_Dec_Holder"

    class setCustomValueResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "setCustomValueResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.setCustomValueResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'setCustomValueResponse')
            kw["aname"] = "_setCustomValueResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "setCustomValueResponse_Holder"
            self.pyclass = Holder

    class UnregisterExtension_Dec(ElementDeclaration):
        literal = "UnregisterExtension"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnregisterExtension')
            kw["aname"] = "_UnregisterExtension"
            if ns0.UnregisterExtensionRequestType_Def not in ns0.UnregisterExtension_Dec.__bases__:
                bases = list(ns0.UnregisterExtension_Dec.__bases__)
                bases.insert(0, ns0.UnregisterExtensionRequestType_Def)
                ns0.UnregisterExtension_Dec.__bases__ = tuple(bases)

            ns0.UnregisterExtensionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnregisterExtension_Dec_Holder"

    class UnregisterExtensionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UnregisterExtensionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UnregisterExtensionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UnregisterExtensionResponse')
            kw["aname"] = "_UnregisterExtensionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UnregisterExtensionResponse_Holder"
            self.pyclass = Holder

    class FindExtension_Dec(ElementDeclaration):
        literal = "FindExtension"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FindExtension')
            kw["aname"] = "_FindExtension"
            if ns0.FindExtensionRequestType_Def not in ns0.FindExtension_Dec.__bases__:
                bases = list(ns0.FindExtension_Dec.__bases__)
                bases.insert(0, ns0.FindExtensionRequestType_Def)
                ns0.FindExtension_Dec.__bases__ = tuple(bases)

            ns0.FindExtensionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FindExtension_Dec_Holder"

    class FindExtensionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FindExtensionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FindExtensionResponse_Dec.schema
            TClist = [GTD("urn:vim25","Extension",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FindExtensionResponse')
            kw["aname"] = "_FindExtensionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FindExtensionResponse_Holder"
            self.pyclass = Holder

    class RegisterExtension_Dec(ElementDeclaration):
        literal = "RegisterExtension"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RegisterExtension')
            kw["aname"] = "_RegisterExtension"
            if ns0.RegisterExtensionRequestType_Def not in ns0.RegisterExtension_Dec.__bases__:
                bases = list(ns0.RegisterExtension_Dec.__bases__)
                bases.insert(0, ns0.RegisterExtensionRequestType_Def)
                ns0.RegisterExtension_Dec.__bases__ = tuple(bases)

            ns0.RegisterExtensionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RegisterExtension_Dec_Holder"

    class RegisterExtensionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RegisterExtensionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RegisterExtensionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RegisterExtensionResponse')
            kw["aname"] = "_RegisterExtensionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RegisterExtensionResponse_Holder"
            self.pyclass = Holder

    class UpdateExtension_Dec(ElementDeclaration):
        literal = "UpdateExtension"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateExtension')
            kw["aname"] = "_UpdateExtension"
            if ns0.UpdateExtensionRequestType_Def not in ns0.UpdateExtension_Dec.__bases__:
                bases = list(ns0.UpdateExtension_Dec.__bases__)
                bases.insert(0, ns0.UpdateExtensionRequestType_Def)
                ns0.UpdateExtension_Dec.__bases__ = tuple(bases)

            ns0.UpdateExtensionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateExtension_Dec_Holder"

    class UpdateExtensionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateExtensionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateExtensionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateExtensionResponse')
            kw["aname"] = "_UpdateExtensionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateExtensionResponse_Holder"
            self.pyclass = Holder

    class GetPublicKey_Dec(ElementDeclaration):
        literal = "GetPublicKey"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GetPublicKey')
            kw["aname"] = "_GetPublicKey"
            if ns0.GetPublicKeyRequestType_Def not in ns0.GetPublicKey_Dec.__bases__:
                bases = list(ns0.GetPublicKey_Dec.__bases__)
                bases.insert(0, ns0.GetPublicKeyRequestType_Def)
                ns0.GetPublicKey_Dec.__bases__ = tuple(bases)

            ns0.GetPublicKeyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GetPublicKey_Dec_Holder"

    class GetPublicKeyResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "GetPublicKeyResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.GetPublicKeyResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'GetPublicKeyResponse')
            kw["aname"] = "_GetPublicKeyResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "GetPublicKeyResponse_Holder"
            self.pyclass = Holder

    class SetPublicKey_Dec(ElementDeclaration):
        literal = "SetPublicKey"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetPublicKey')
            kw["aname"] = "_SetPublicKey"
            if ns0.SetPublicKeyRequestType_Def not in ns0.SetPublicKey_Dec.__bases__:
                bases = list(ns0.SetPublicKey_Dec.__bases__)
                bases.insert(0, ns0.SetPublicKeyRequestType_Def)
                ns0.SetPublicKey_Dec.__bases__ = tuple(bases)

            ns0.SetPublicKeyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetPublicKey_Dec_Holder"

    class SetPublicKeyResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetPublicKeyResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetPublicKeyResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetPublicKeyResponse')
            kw["aname"] = "_SetPublicKeyResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetPublicKeyResponse_Holder"
            self.pyclass = Holder

    class MoveDatastoreFile_Dec(ElementDeclaration):
        literal = "MoveDatastoreFile"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveDatastoreFile')
            kw["aname"] = "_MoveDatastoreFile"
            if ns0.MoveDatastoreFileRequestType_Def not in ns0.MoveDatastoreFile_Dec.__bases__:
                bases = list(ns0.MoveDatastoreFile_Dec.__bases__)
                bases.insert(0, ns0.MoveDatastoreFileRequestType_Def)
                ns0.MoveDatastoreFile_Dec.__bases__ = tuple(bases)

            ns0.MoveDatastoreFileRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveDatastoreFile_Dec_Holder"

    class MoveDatastoreFileResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveDatastoreFileResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveDatastoreFileResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MoveDatastoreFileResponse')
            kw["aname"] = "_MoveDatastoreFileResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MoveDatastoreFileResponse_Holder"
            self.pyclass = Holder

    class MoveDatastoreFile_Task_Dec(ElementDeclaration):
        literal = "MoveDatastoreFile_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveDatastoreFile_Task')
            kw["aname"] = "_MoveDatastoreFile_Task"
            if ns0.MoveDatastoreFileRequestType_Def not in ns0.MoveDatastoreFile_Task_Dec.__bases__:
                bases = list(ns0.MoveDatastoreFile_Task_Dec.__bases__)
                bases.insert(0, ns0.MoveDatastoreFileRequestType_Def)
                ns0.MoveDatastoreFile_Task_Dec.__bases__ = tuple(bases)

            ns0.MoveDatastoreFileRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveDatastoreFile_Task_Dec_Holder"

    class MoveDatastoreFile_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveDatastoreFile_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveDatastoreFile_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'MoveDatastoreFile_TaskResponse')
            kw["aname"] = "_MoveDatastoreFile_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "MoveDatastoreFile_TaskResponse_Holder"
            self.pyclass = Holder

    class CopyDatastoreFile_Dec(ElementDeclaration):
        literal = "CopyDatastoreFile"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CopyDatastoreFile')
            kw["aname"] = "_CopyDatastoreFile"
            if ns0.CopyDatastoreFileRequestType_Def not in ns0.CopyDatastoreFile_Dec.__bases__:
                bases = list(ns0.CopyDatastoreFile_Dec.__bases__)
                bases.insert(0, ns0.CopyDatastoreFileRequestType_Def)
                ns0.CopyDatastoreFile_Dec.__bases__ = tuple(bases)

            ns0.CopyDatastoreFileRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CopyDatastoreFile_Dec_Holder"

    class CopyDatastoreFileResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CopyDatastoreFileResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CopyDatastoreFileResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CopyDatastoreFileResponse')
            kw["aname"] = "_CopyDatastoreFileResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CopyDatastoreFileResponse_Holder"
            self.pyclass = Holder

    class CopyDatastoreFile_Task_Dec(ElementDeclaration):
        literal = "CopyDatastoreFile_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CopyDatastoreFile_Task')
            kw["aname"] = "_CopyDatastoreFile_Task"
            if ns0.CopyDatastoreFileRequestType_Def not in ns0.CopyDatastoreFile_Task_Dec.__bases__:
                bases = list(ns0.CopyDatastoreFile_Task_Dec.__bases__)
                bases.insert(0, ns0.CopyDatastoreFileRequestType_Def)
                ns0.CopyDatastoreFile_Task_Dec.__bases__ = tuple(bases)

            ns0.CopyDatastoreFileRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CopyDatastoreFile_Task_Dec_Holder"

    class CopyDatastoreFile_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CopyDatastoreFile_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CopyDatastoreFile_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CopyDatastoreFile_TaskResponse')
            kw["aname"] = "_CopyDatastoreFile_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CopyDatastoreFile_TaskResponse_Holder"
            self.pyclass = Holder

    class DeleteDatastoreFile_Dec(ElementDeclaration):
        literal = "DeleteDatastoreFile"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeleteDatastoreFile')
            kw["aname"] = "_DeleteDatastoreFile"
            if ns0.DeleteDatastoreFileRequestType_Def not in ns0.DeleteDatastoreFile_Dec.__bases__:
                bases = list(ns0.DeleteDatastoreFile_Dec.__bases__)
                bases.insert(0, ns0.DeleteDatastoreFileRequestType_Def)
                ns0.DeleteDatastoreFile_Dec.__bases__ = tuple(bases)

            ns0.DeleteDatastoreFileRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeleteDatastoreFile_Dec_Holder"

    class DeleteDatastoreFileResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DeleteDatastoreFileResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DeleteDatastoreFileResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DeleteDatastoreFileResponse')
            kw["aname"] = "_DeleteDatastoreFileResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DeleteDatastoreFileResponse_Holder"
            self.pyclass = Holder

    class DeleteDatastoreFile_Task_Dec(ElementDeclaration):
        literal = "DeleteDatastoreFile_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeleteDatastoreFile_Task')
            kw["aname"] = "_DeleteDatastoreFile_Task"
            if ns0.DeleteDatastoreFileRequestType_Def not in ns0.DeleteDatastoreFile_Task_Dec.__bases__:
                bases = list(ns0.DeleteDatastoreFile_Task_Dec.__bases__)
                bases.insert(0, ns0.DeleteDatastoreFileRequestType_Def)
                ns0.DeleteDatastoreFile_Task_Dec.__bases__ = tuple(bases)

            ns0.DeleteDatastoreFileRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeleteDatastoreFile_Task_Dec_Holder"

    class DeleteDatastoreFile_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DeleteDatastoreFile_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DeleteDatastoreFile_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'DeleteDatastoreFile_TaskResponse')
            kw["aname"] = "_DeleteDatastoreFile_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "DeleteDatastoreFile_TaskResponse_Holder"
            self.pyclass = Holder

    class MakeDirectory_Dec(ElementDeclaration):
        literal = "MakeDirectory"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MakeDirectory')
            kw["aname"] = "_MakeDirectory"
            if ns0.MakeDirectoryRequestType_Def not in ns0.MakeDirectory_Dec.__bases__:
                bases = list(ns0.MakeDirectory_Dec.__bases__)
                bases.insert(0, ns0.MakeDirectoryRequestType_Def)
                ns0.MakeDirectory_Dec.__bases__ = tuple(bases)

            ns0.MakeDirectoryRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MakeDirectory_Dec_Holder"

    class MakeDirectoryResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MakeDirectoryResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MakeDirectoryResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MakeDirectoryResponse')
            kw["aname"] = "_MakeDirectoryResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MakeDirectoryResponse_Holder"
            self.pyclass = Holder

    class CreateFolder_Dec(ElementDeclaration):
        literal = "CreateFolder"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateFolder')
            kw["aname"] = "_CreateFolder"
            if ns0.CreateFolderRequestType_Def not in ns0.CreateFolder_Dec.__bases__:
                bases = list(ns0.CreateFolder_Dec.__bases__)
                bases.insert(0, ns0.CreateFolderRequestType_Def)
                ns0.CreateFolder_Dec.__bases__ = tuple(bases)

            ns0.CreateFolderRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateFolder_Dec_Holder"

    class CreateFolderResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateFolderResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateFolderResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateFolderResponse')
            kw["aname"] = "_CreateFolderResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateFolderResponse_Holder"
            self.pyclass = Holder

    class MoveIntoFolder_Dec(ElementDeclaration):
        literal = "MoveIntoFolder"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveIntoFolder')
            kw["aname"] = "_MoveIntoFolder"
            if ns0.MoveIntoFolderRequestType_Def not in ns0.MoveIntoFolder_Dec.__bases__:
                bases = list(ns0.MoveIntoFolder_Dec.__bases__)
                bases.insert(0, ns0.MoveIntoFolderRequestType_Def)
                ns0.MoveIntoFolder_Dec.__bases__ = tuple(bases)

            ns0.MoveIntoFolderRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveIntoFolder_Dec_Holder"

    class MoveIntoFolderResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveIntoFolderResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveIntoFolderResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MoveIntoFolderResponse')
            kw["aname"] = "_MoveIntoFolderResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MoveIntoFolderResponse_Holder"
            self.pyclass = Holder

    class MoveIntoFolder_Task_Dec(ElementDeclaration):
        literal = "MoveIntoFolder_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveIntoFolder_Task')
            kw["aname"] = "_MoveIntoFolder_Task"
            if ns0.MoveIntoFolderRequestType_Def not in ns0.MoveIntoFolder_Task_Dec.__bases__:
                bases = list(ns0.MoveIntoFolder_Task_Dec.__bases__)
                bases.insert(0, ns0.MoveIntoFolderRequestType_Def)
                ns0.MoveIntoFolder_Task_Dec.__bases__ = tuple(bases)

            ns0.MoveIntoFolderRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveIntoFolder_Task_Dec_Holder"

    class MoveIntoFolder_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveIntoFolder_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveIntoFolder_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'MoveIntoFolder_TaskResponse')
            kw["aname"] = "_MoveIntoFolder_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "MoveIntoFolder_TaskResponse_Holder"
            self.pyclass = Holder

    class CreateVM_Dec(ElementDeclaration):
        literal = "CreateVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateVM')
            kw["aname"] = "_CreateVM"
            if ns0.CreateVMRequestType_Def not in ns0.CreateVM_Dec.__bases__:
                bases = list(ns0.CreateVM_Dec.__bases__)
                bases.insert(0, ns0.CreateVMRequestType_Def)
                ns0.CreateVM_Dec.__bases__ = tuple(bases)

            ns0.CreateVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateVM_Dec_Holder"

    class CreateVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateVMResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateVMResponse')
            kw["aname"] = "_CreateVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateVMResponse_Holder"
            self.pyclass = Holder

    class CreateVM_Task_Dec(ElementDeclaration):
        literal = "CreateVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateVM_Task')
            kw["aname"] = "_CreateVM_Task"
            if ns0.CreateVMRequestType_Def not in ns0.CreateVM_Task_Dec.__bases__:
                bases = list(ns0.CreateVM_Task_Dec.__bases__)
                bases.insert(0, ns0.CreateVMRequestType_Def)
                ns0.CreateVM_Task_Dec.__bases__ = tuple(bases)

            ns0.CreateVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateVM_Task_Dec_Holder"

    class CreateVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateVM_TaskResponse')
            kw["aname"] = "_CreateVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateVM_TaskResponse_Holder"
            self.pyclass = Holder

    class RegisterVM_Dec(ElementDeclaration):
        literal = "RegisterVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RegisterVM')
            kw["aname"] = "_RegisterVM"
            if ns0.RegisterVMRequestType_Def not in ns0.RegisterVM_Dec.__bases__:
                bases = list(ns0.RegisterVM_Dec.__bases__)
                bases.insert(0, ns0.RegisterVMRequestType_Def)
                ns0.RegisterVM_Dec.__bases__ = tuple(bases)

            ns0.RegisterVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RegisterVM_Dec_Holder"

    class RegisterVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RegisterVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RegisterVMResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RegisterVMResponse')
            kw["aname"] = "_RegisterVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RegisterVMResponse_Holder"
            self.pyclass = Holder

    class RegisterVM_Task_Dec(ElementDeclaration):
        literal = "RegisterVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RegisterVM_Task')
            kw["aname"] = "_RegisterVM_Task"
            if ns0.RegisterVMRequestType_Def not in ns0.RegisterVM_Task_Dec.__bases__:
                bases = list(ns0.RegisterVM_Task_Dec.__bases__)
                bases.insert(0, ns0.RegisterVMRequestType_Def)
                ns0.RegisterVM_Task_Dec.__bases__ = tuple(bases)

            ns0.RegisterVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RegisterVM_Task_Dec_Holder"

    class RegisterVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RegisterVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RegisterVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RegisterVM_TaskResponse')
            kw["aname"] = "_RegisterVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RegisterVM_TaskResponse_Holder"
            self.pyclass = Holder

    class CreateCluster_Dec(ElementDeclaration):
        literal = "CreateCluster"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateCluster')
            kw["aname"] = "_CreateCluster"
            if ns0.CreateClusterRequestType_Def not in ns0.CreateCluster_Dec.__bases__:
                bases = list(ns0.CreateCluster_Dec.__bases__)
                bases.insert(0, ns0.CreateClusterRequestType_Def)
                ns0.CreateCluster_Dec.__bases__ = tuple(bases)

            ns0.CreateClusterRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateCluster_Dec_Holder"

    class CreateClusterResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateClusterResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateClusterResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateClusterResponse')
            kw["aname"] = "_CreateClusterResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateClusterResponse_Holder"
            self.pyclass = Holder

    class CreateClusterEx_Dec(ElementDeclaration):
        literal = "CreateClusterEx"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateClusterEx')
            kw["aname"] = "_CreateClusterEx"
            if ns0.CreateClusterExRequestType_Def not in ns0.CreateClusterEx_Dec.__bases__:
                bases = list(ns0.CreateClusterEx_Dec.__bases__)
                bases.insert(0, ns0.CreateClusterExRequestType_Def)
                ns0.CreateClusterEx_Dec.__bases__ = tuple(bases)

            ns0.CreateClusterExRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateClusterEx_Dec_Holder"

    class CreateClusterExResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateClusterExResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateClusterExResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateClusterExResponse')
            kw["aname"] = "_CreateClusterExResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateClusterExResponse_Holder"
            self.pyclass = Holder

    class AddStandaloneHost_Dec(ElementDeclaration):
        literal = "AddStandaloneHost"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddStandaloneHost')
            kw["aname"] = "_AddStandaloneHost"
            if ns0.AddStandaloneHostRequestType_Def not in ns0.AddStandaloneHost_Dec.__bases__:
                bases = list(ns0.AddStandaloneHost_Dec.__bases__)
                bases.insert(0, ns0.AddStandaloneHostRequestType_Def)
                ns0.AddStandaloneHost_Dec.__bases__ = tuple(bases)

            ns0.AddStandaloneHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddStandaloneHost_Dec_Holder"

    class AddStandaloneHostResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddStandaloneHostResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddStandaloneHostResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddStandaloneHostResponse')
            kw["aname"] = "_AddStandaloneHostResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddStandaloneHostResponse_Holder"
            self.pyclass = Holder

    class AddStandaloneHost_Task_Dec(ElementDeclaration):
        literal = "AddStandaloneHost_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddStandaloneHost_Task')
            kw["aname"] = "_AddStandaloneHost_Task"
            if ns0.AddStandaloneHostRequestType_Def not in ns0.AddStandaloneHost_Task_Dec.__bases__:
                bases = list(ns0.AddStandaloneHost_Task_Dec.__bases__)
                bases.insert(0, ns0.AddStandaloneHostRequestType_Def)
                ns0.AddStandaloneHost_Task_Dec.__bases__ = tuple(bases)

            ns0.AddStandaloneHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddStandaloneHost_Task_Dec_Holder"

    class AddStandaloneHost_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddStandaloneHost_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddStandaloneHost_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddStandaloneHost_TaskResponse')
            kw["aname"] = "_AddStandaloneHost_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddStandaloneHost_TaskResponse_Holder"
            self.pyclass = Holder

    class CreateDatacenter_Dec(ElementDeclaration):
        literal = "CreateDatacenter"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateDatacenter')
            kw["aname"] = "_CreateDatacenter"
            if ns0.CreateDatacenterRequestType_Def not in ns0.CreateDatacenter_Dec.__bases__:
                bases = list(ns0.CreateDatacenter_Dec.__bases__)
                bases.insert(0, ns0.CreateDatacenterRequestType_Def)
                ns0.CreateDatacenter_Dec.__bases__ = tuple(bases)

            ns0.CreateDatacenterRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateDatacenter_Dec_Holder"

    class CreateDatacenterResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateDatacenterResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateDatacenterResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateDatacenterResponse')
            kw["aname"] = "_CreateDatacenterResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateDatacenterResponse_Holder"
            self.pyclass = Holder

    class UnregisterAndDestroy_Dec(ElementDeclaration):
        literal = "UnregisterAndDestroy"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnregisterAndDestroy')
            kw["aname"] = "_UnregisterAndDestroy"
            if ns0.UnregisterAndDestroyRequestType_Def not in ns0.UnregisterAndDestroy_Dec.__bases__:
                bases = list(ns0.UnregisterAndDestroy_Dec.__bases__)
                bases.insert(0, ns0.UnregisterAndDestroyRequestType_Def)
                ns0.UnregisterAndDestroy_Dec.__bases__ = tuple(bases)

            ns0.UnregisterAndDestroyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnregisterAndDestroy_Dec_Holder"

    class UnregisterAndDestroyResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UnregisterAndDestroyResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UnregisterAndDestroyResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UnregisterAndDestroyResponse')
            kw["aname"] = "_UnregisterAndDestroyResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UnregisterAndDestroyResponse_Holder"
            self.pyclass = Holder

    class UnregisterAndDestroy_Task_Dec(ElementDeclaration):
        literal = "UnregisterAndDestroy_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnregisterAndDestroy_Task')
            kw["aname"] = "_UnregisterAndDestroy_Task"
            if ns0.UnregisterAndDestroyRequestType_Def not in ns0.UnregisterAndDestroy_Task_Dec.__bases__:
                bases = list(ns0.UnregisterAndDestroy_Task_Dec.__bases__)
                bases.insert(0, ns0.UnregisterAndDestroyRequestType_Def)
                ns0.UnregisterAndDestroy_Task_Dec.__bases__ = tuple(bases)

            ns0.UnregisterAndDestroyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnregisterAndDestroy_Task_Dec_Holder"

    class UnregisterAndDestroy_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UnregisterAndDestroy_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UnregisterAndDestroy_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'UnregisterAndDestroy_TaskResponse')
            kw["aname"] = "_UnregisterAndDestroy_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "UnregisterAndDestroy_TaskResponse_Holder"
            self.pyclass = Holder

    class SetCollectorPageSize_Dec(ElementDeclaration):
        literal = "SetCollectorPageSize"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetCollectorPageSize')
            kw["aname"] = "_SetCollectorPageSize"
            if ns0.SetCollectorPageSizeRequestType_Def not in ns0.SetCollectorPageSize_Dec.__bases__:
                bases = list(ns0.SetCollectorPageSize_Dec.__bases__)
                bases.insert(0, ns0.SetCollectorPageSizeRequestType_Def)
                ns0.SetCollectorPageSize_Dec.__bases__ = tuple(bases)

            ns0.SetCollectorPageSizeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetCollectorPageSize_Dec_Holder"

    class SetCollectorPageSizeResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetCollectorPageSizeResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetCollectorPageSizeResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetCollectorPageSizeResponse')
            kw["aname"] = "_SetCollectorPageSizeResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetCollectorPageSizeResponse_Holder"
            self.pyclass = Holder

    class RewindCollector_Dec(ElementDeclaration):
        literal = "RewindCollector"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RewindCollector')
            kw["aname"] = "_RewindCollector"
            if ns0.RewindCollectorRequestType_Def not in ns0.RewindCollector_Dec.__bases__:
                bases = list(ns0.RewindCollector_Dec.__bases__)
                bases.insert(0, ns0.RewindCollectorRequestType_Def)
                ns0.RewindCollector_Dec.__bases__ = tuple(bases)

            ns0.RewindCollectorRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RewindCollector_Dec_Holder"

    class RewindCollectorResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RewindCollectorResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RewindCollectorResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RewindCollectorResponse')
            kw["aname"] = "_RewindCollectorResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RewindCollectorResponse_Holder"
            self.pyclass = Holder

    class ResetCollector_Dec(ElementDeclaration):
        literal = "ResetCollector"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetCollector')
            kw["aname"] = "_ResetCollector"
            if ns0.ResetCollectorRequestType_Def not in ns0.ResetCollector_Dec.__bases__:
                bases = list(ns0.ResetCollector_Dec.__bases__)
                bases.insert(0, ns0.ResetCollectorRequestType_Def)
                ns0.ResetCollector_Dec.__bases__ = tuple(bases)

            ns0.ResetCollectorRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetCollector_Dec_Holder"

    class ResetCollectorResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetCollectorResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetCollectorResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ResetCollectorResponse')
            kw["aname"] = "_ResetCollectorResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ResetCollectorResponse_Holder"
            self.pyclass = Holder

    class DestroyCollector_Dec(ElementDeclaration):
        literal = "DestroyCollector"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DestroyCollector')
            kw["aname"] = "_DestroyCollector"
            if ns0.DestroyCollectorRequestType_Def not in ns0.DestroyCollector_Dec.__bases__:
                bases = list(ns0.DestroyCollector_Dec.__bases__)
                bases.insert(0, ns0.DestroyCollectorRequestType_Def)
                ns0.DestroyCollector_Dec.__bases__ = tuple(bases)

            ns0.DestroyCollectorRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DestroyCollector_Dec_Holder"

    class DestroyCollectorResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DestroyCollectorResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DestroyCollectorResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DestroyCollectorResponse')
            kw["aname"] = "_DestroyCollectorResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DestroyCollectorResponse_Holder"
            self.pyclass = Holder

    class QueryHostConnectionInfo_Dec(ElementDeclaration):
        literal = "QueryHostConnectionInfo"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryHostConnectionInfo')
            kw["aname"] = "_QueryHostConnectionInfo"
            if ns0.QueryHostConnectionInfoRequestType_Def not in ns0.QueryHostConnectionInfo_Dec.__bases__:
                bases = list(ns0.QueryHostConnectionInfo_Dec.__bases__)
                bases.insert(0, ns0.QueryHostConnectionInfoRequestType_Def)
                ns0.QueryHostConnectionInfo_Dec.__bases__ = tuple(bases)

            ns0.QueryHostConnectionInfoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryHostConnectionInfo_Dec_Holder"

    class QueryHostConnectionInfoResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryHostConnectionInfoResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryHostConnectionInfoResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostConnectInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryHostConnectionInfoResponse')
            kw["aname"] = "_QueryHostConnectionInfoResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryHostConnectionInfoResponse_Holder"
            self.pyclass = Holder

    class UpdateSystemResources_Dec(ElementDeclaration):
        literal = "UpdateSystemResources"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateSystemResources')
            kw["aname"] = "_UpdateSystemResources"
            if ns0.UpdateSystemResourcesRequestType_Def not in ns0.UpdateSystemResources_Dec.__bases__:
                bases = list(ns0.UpdateSystemResources_Dec.__bases__)
                bases.insert(0, ns0.UpdateSystemResourcesRequestType_Def)
                ns0.UpdateSystemResources_Dec.__bases__ = tuple(bases)

            ns0.UpdateSystemResourcesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateSystemResources_Dec_Holder"

    class UpdateSystemResourcesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateSystemResourcesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateSystemResourcesResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateSystemResourcesResponse')
            kw["aname"] = "_UpdateSystemResourcesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateSystemResourcesResponse_Holder"
            self.pyclass = Holder

    class ReconnectHost_Dec(ElementDeclaration):
        literal = "ReconnectHost"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconnectHost')
            kw["aname"] = "_ReconnectHost"
            if ns0.ReconnectHostRequestType_Def not in ns0.ReconnectHost_Dec.__bases__:
                bases = list(ns0.ReconnectHost_Dec.__bases__)
                bases.insert(0, ns0.ReconnectHostRequestType_Def)
                ns0.ReconnectHost_Dec.__bases__ = tuple(bases)

            ns0.ReconnectHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconnectHost_Dec_Holder"

    class ReconnectHostResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconnectHostResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconnectHostResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconnectHostResponse')
            kw["aname"] = "_ReconnectHostResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconnectHostResponse_Holder"
            self.pyclass = Holder

    class ReconnectHost_Task_Dec(ElementDeclaration):
        literal = "ReconnectHost_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconnectHost_Task')
            kw["aname"] = "_ReconnectHost_Task"
            if ns0.ReconnectHostRequestType_Def not in ns0.ReconnectHost_Task_Dec.__bases__:
                bases = list(ns0.ReconnectHost_Task_Dec.__bases__)
                bases.insert(0, ns0.ReconnectHostRequestType_Def)
                ns0.ReconnectHost_Task_Dec.__bases__ = tuple(bases)

            ns0.ReconnectHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconnectHost_Task_Dec_Holder"

    class ReconnectHost_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconnectHost_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconnectHost_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReconnectHost_TaskResponse')
            kw["aname"] = "_ReconnectHost_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ReconnectHost_TaskResponse_Holder"
            self.pyclass = Holder

    class DisconnectHost_Dec(ElementDeclaration):
        literal = "DisconnectHost"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisconnectHost')
            kw["aname"] = "_DisconnectHost"
            if ns0.DisconnectHostRequestType_Def not in ns0.DisconnectHost_Dec.__bases__:
                bases = list(ns0.DisconnectHost_Dec.__bases__)
                bases.insert(0, ns0.DisconnectHostRequestType_Def)
                ns0.DisconnectHost_Dec.__bases__ = tuple(bases)

            ns0.DisconnectHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisconnectHost_Dec_Holder"

    class DisconnectHostResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DisconnectHostResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DisconnectHostResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DisconnectHostResponse')
            kw["aname"] = "_DisconnectHostResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DisconnectHostResponse_Holder"
            self.pyclass = Holder

    class DisconnectHost_Task_Dec(ElementDeclaration):
        literal = "DisconnectHost_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisconnectHost_Task')
            kw["aname"] = "_DisconnectHost_Task"
            if ns0.DisconnectHostRequestType_Def not in ns0.DisconnectHost_Task_Dec.__bases__:
                bases = list(ns0.DisconnectHost_Task_Dec.__bases__)
                bases.insert(0, ns0.DisconnectHostRequestType_Def)
                ns0.DisconnectHost_Task_Dec.__bases__ = tuple(bases)

            ns0.DisconnectHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisconnectHost_Task_Dec_Holder"

    class DisconnectHost_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DisconnectHost_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DisconnectHost_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'DisconnectHost_TaskResponse')
            kw["aname"] = "_DisconnectHost_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "DisconnectHost_TaskResponse_Holder"
            self.pyclass = Holder

    class EnterMaintenanceMode_Dec(ElementDeclaration):
        literal = "EnterMaintenanceMode"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'EnterMaintenanceMode')
            kw["aname"] = "_EnterMaintenanceMode"
            if ns0.EnterMaintenanceModeRequestType_Def not in ns0.EnterMaintenanceMode_Dec.__bases__:
                bases = list(ns0.EnterMaintenanceMode_Dec.__bases__)
                bases.insert(0, ns0.EnterMaintenanceModeRequestType_Def)
                ns0.EnterMaintenanceMode_Dec.__bases__ = tuple(bases)

            ns0.EnterMaintenanceModeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "EnterMaintenanceMode_Dec_Holder"

    class EnterMaintenanceModeResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "EnterMaintenanceModeResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.EnterMaintenanceModeResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'EnterMaintenanceModeResponse')
            kw["aname"] = "_EnterMaintenanceModeResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "EnterMaintenanceModeResponse_Holder"
            self.pyclass = Holder

    class EnterMaintenanceMode_Task_Dec(ElementDeclaration):
        literal = "EnterMaintenanceMode_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'EnterMaintenanceMode_Task')
            kw["aname"] = "_EnterMaintenanceMode_Task"
            if ns0.EnterMaintenanceModeRequestType_Def not in ns0.EnterMaintenanceMode_Task_Dec.__bases__:
                bases = list(ns0.EnterMaintenanceMode_Task_Dec.__bases__)
                bases.insert(0, ns0.EnterMaintenanceModeRequestType_Def)
                ns0.EnterMaintenanceMode_Task_Dec.__bases__ = tuple(bases)

            ns0.EnterMaintenanceModeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "EnterMaintenanceMode_Task_Dec_Holder"

    class EnterMaintenanceMode_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "EnterMaintenanceMode_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.EnterMaintenanceMode_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'EnterMaintenanceMode_TaskResponse')
            kw["aname"] = "_EnterMaintenanceMode_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "EnterMaintenanceMode_TaskResponse_Holder"
            self.pyclass = Holder

    class ExitMaintenanceMode_Dec(ElementDeclaration):
        literal = "ExitMaintenanceMode"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExitMaintenanceMode')
            kw["aname"] = "_ExitMaintenanceMode"
            if ns0.ExitMaintenanceModeRequestType_Def not in ns0.ExitMaintenanceMode_Dec.__bases__:
                bases = list(ns0.ExitMaintenanceMode_Dec.__bases__)
                bases.insert(0, ns0.ExitMaintenanceModeRequestType_Def)
                ns0.ExitMaintenanceMode_Dec.__bases__ = tuple(bases)

            ns0.ExitMaintenanceModeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExitMaintenanceMode_Dec_Holder"

    class ExitMaintenanceModeResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ExitMaintenanceModeResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ExitMaintenanceModeResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ExitMaintenanceModeResponse')
            kw["aname"] = "_ExitMaintenanceModeResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ExitMaintenanceModeResponse_Holder"
            self.pyclass = Holder

    class ExitMaintenanceMode_Task_Dec(ElementDeclaration):
        literal = "ExitMaintenanceMode_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExitMaintenanceMode_Task')
            kw["aname"] = "_ExitMaintenanceMode_Task"
            if ns0.ExitMaintenanceModeRequestType_Def not in ns0.ExitMaintenanceMode_Task_Dec.__bases__:
                bases = list(ns0.ExitMaintenanceMode_Task_Dec.__bases__)
                bases.insert(0, ns0.ExitMaintenanceModeRequestType_Def)
                ns0.ExitMaintenanceMode_Task_Dec.__bases__ = tuple(bases)

            ns0.ExitMaintenanceModeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExitMaintenanceMode_Task_Dec_Holder"

    class ExitMaintenanceMode_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ExitMaintenanceMode_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ExitMaintenanceMode_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ExitMaintenanceMode_TaskResponse')
            kw["aname"] = "_ExitMaintenanceMode_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ExitMaintenanceMode_TaskResponse_Holder"
            self.pyclass = Holder

    class RebootHost_Dec(ElementDeclaration):
        literal = "RebootHost"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RebootHost')
            kw["aname"] = "_RebootHost"
            if ns0.RebootHostRequestType_Def not in ns0.RebootHost_Dec.__bases__:
                bases = list(ns0.RebootHost_Dec.__bases__)
                bases.insert(0, ns0.RebootHostRequestType_Def)
                ns0.RebootHost_Dec.__bases__ = tuple(bases)

            ns0.RebootHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RebootHost_Dec_Holder"

    class RebootHostResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RebootHostResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RebootHostResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RebootHostResponse')
            kw["aname"] = "_RebootHostResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RebootHostResponse_Holder"
            self.pyclass = Holder

    class RebootHost_Task_Dec(ElementDeclaration):
        literal = "RebootHost_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RebootHost_Task')
            kw["aname"] = "_RebootHost_Task"
            if ns0.RebootHostRequestType_Def not in ns0.RebootHost_Task_Dec.__bases__:
                bases = list(ns0.RebootHost_Task_Dec.__bases__)
                bases.insert(0, ns0.RebootHostRequestType_Def)
                ns0.RebootHost_Task_Dec.__bases__ = tuple(bases)

            ns0.RebootHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RebootHost_Task_Dec_Holder"

    class RebootHost_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RebootHost_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RebootHost_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RebootHost_TaskResponse')
            kw["aname"] = "_RebootHost_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RebootHost_TaskResponse_Holder"
            self.pyclass = Holder

    class ShutdownHost_Dec(ElementDeclaration):
        literal = "ShutdownHost"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ShutdownHost')
            kw["aname"] = "_ShutdownHost"
            if ns0.ShutdownHostRequestType_Def not in ns0.ShutdownHost_Dec.__bases__:
                bases = list(ns0.ShutdownHost_Dec.__bases__)
                bases.insert(0, ns0.ShutdownHostRequestType_Def)
                ns0.ShutdownHost_Dec.__bases__ = tuple(bases)

            ns0.ShutdownHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ShutdownHost_Dec_Holder"

    class ShutdownHostResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ShutdownHostResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ShutdownHostResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ShutdownHostResponse')
            kw["aname"] = "_ShutdownHostResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ShutdownHostResponse_Holder"
            self.pyclass = Holder

    class ShutdownHost_Task_Dec(ElementDeclaration):
        literal = "ShutdownHost_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ShutdownHost_Task')
            kw["aname"] = "_ShutdownHost_Task"
            if ns0.ShutdownHostRequestType_Def not in ns0.ShutdownHost_Task_Dec.__bases__:
                bases = list(ns0.ShutdownHost_Task_Dec.__bases__)
                bases.insert(0, ns0.ShutdownHostRequestType_Def)
                ns0.ShutdownHost_Task_Dec.__bases__ = tuple(bases)

            ns0.ShutdownHostRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ShutdownHost_Task_Dec_Holder"

    class ShutdownHost_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ShutdownHost_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ShutdownHost_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ShutdownHost_TaskResponse')
            kw["aname"] = "_ShutdownHost_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ShutdownHost_TaskResponse_Holder"
            self.pyclass = Holder

    class PowerDownHostToStandBy_Dec(ElementDeclaration):
        literal = "PowerDownHostToStandBy"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerDownHostToStandBy')
            kw["aname"] = "_PowerDownHostToStandBy"
            if ns0.PowerDownHostToStandByRequestType_Def not in ns0.PowerDownHostToStandBy_Dec.__bases__:
                bases = list(ns0.PowerDownHostToStandBy_Dec.__bases__)
                bases.insert(0, ns0.PowerDownHostToStandByRequestType_Def)
                ns0.PowerDownHostToStandBy_Dec.__bases__ = tuple(bases)

            ns0.PowerDownHostToStandByRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerDownHostToStandBy_Dec_Holder"

    class PowerDownHostToStandByResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerDownHostToStandByResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerDownHostToStandByResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'PowerDownHostToStandByResponse')
            kw["aname"] = "_PowerDownHostToStandByResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "PowerDownHostToStandByResponse_Holder"
            self.pyclass = Holder

    class PowerDownHostToStandBy_Task_Dec(ElementDeclaration):
        literal = "PowerDownHostToStandBy_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerDownHostToStandBy_Task')
            kw["aname"] = "_PowerDownHostToStandBy_Task"
            if ns0.PowerDownHostToStandByRequestType_Def not in ns0.PowerDownHostToStandBy_Task_Dec.__bases__:
                bases = list(ns0.PowerDownHostToStandBy_Task_Dec.__bases__)
                bases.insert(0, ns0.PowerDownHostToStandByRequestType_Def)
                ns0.PowerDownHostToStandBy_Task_Dec.__bases__ = tuple(bases)

            ns0.PowerDownHostToStandByRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerDownHostToStandBy_Task_Dec_Holder"

    class PowerDownHostToStandBy_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerDownHostToStandBy_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerDownHostToStandBy_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'PowerDownHostToStandBy_TaskResponse')
            kw["aname"] = "_PowerDownHostToStandBy_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "PowerDownHostToStandBy_TaskResponse_Holder"
            self.pyclass = Holder

    class PowerUpHostFromStandBy_Dec(ElementDeclaration):
        literal = "PowerUpHostFromStandBy"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerUpHostFromStandBy')
            kw["aname"] = "_PowerUpHostFromStandBy"
            if ns0.PowerUpHostFromStandByRequestType_Def not in ns0.PowerUpHostFromStandBy_Dec.__bases__:
                bases = list(ns0.PowerUpHostFromStandBy_Dec.__bases__)
                bases.insert(0, ns0.PowerUpHostFromStandByRequestType_Def)
                ns0.PowerUpHostFromStandBy_Dec.__bases__ = tuple(bases)

            ns0.PowerUpHostFromStandByRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerUpHostFromStandBy_Dec_Holder"

    class PowerUpHostFromStandByResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerUpHostFromStandByResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerUpHostFromStandByResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'PowerUpHostFromStandByResponse')
            kw["aname"] = "_PowerUpHostFromStandByResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "PowerUpHostFromStandByResponse_Holder"
            self.pyclass = Holder

    class PowerUpHostFromStandBy_Task_Dec(ElementDeclaration):
        literal = "PowerUpHostFromStandBy_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerUpHostFromStandBy_Task')
            kw["aname"] = "_PowerUpHostFromStandBy_Task"
            if ns0.PowerUpHostFromStandByRequestType_Def not in ns0.PowerUpHostFromStandBy_Task_Dec.__bases__:
                bases = list(ns0.PowerUpHostFromStandBy_Task_Dec.__bases__)
                bases.insert(0, ns0.PowerUpHostFromStandByRequestType_Def)
                ns0.PowerUpHostFromStandBy_Task_Dec.__bases__ = tuple(bases)

            ns0.PowerUpHostFromStandByRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerUpHostFromStandBy_Task_Dec_Holder"

    class PowerUpHostFromStandBy_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerUpHostFromStandBy_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerUpHostFromStandBy_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'PowerUpHostFromStandBy_TaskResponse')
            kw["aname"] = "_PowerUpHostFromStandBy_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "PowerUpHostFromStandBy_TaskResponse_Holder"
            self.pyclass = Holder

    class QueryMemoryOverhead_Dec(ElementDeclaration):
        literal = "QueryMemoryOverhead"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryMemoryOverhead')
            kw["aname"] = "_QueryMemoryOverhead"
            if ns0.QueryMemoryOverheadRequestType_Def not in ns0.QueryMemoryOverhead_Dec.__bases__:
                bases = list(ns0.QueryMemoryOverhead_Dec.__bases__)
                bases.insert(0, ns0.QueryMemoryOverheadRequestType_Def)
                ns0.QueryMemoryOverhead_Dec.__bases__ = tuple(bases)

            ns0.QueryMemoryOverheadRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryMemoryOverhead_Dec_Holder"

    class QueryMemoryOverheadResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryMemoryOverheadResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryMemoryOverheadResponse_Dec.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryMemoryOverheadResponse')
            kw["aname"] = "_QueryMemoryOverheadResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryMemoryOverheadResponse_Holder"
            self.pyclass = Holder

    class QueryMemoryOverheadEx_Dec(ElementDeclaration):
        literal = "QueryMemoryOverheadEx"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryMemoryOverheadEx')
            kw["aname"] = "_QueryMemoryOverheadEx"
            if ns0.QueryMemoryOverheadExRequestType_Def not in ns0.QueryMemoryOverheadEx_Dec.__bases__:
                bases = list(ns0.QueryMemoryOverheadEx_Dec.__bases__)
                bases.insert(0, ns0.QueryMemoryOverheadExRequestType_Def)
                ns0.QueryMemoryOverheadEx_Dec.__bases__ = tuple(bases)

            ns0.QueryMemoryOverheadExRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryMemoryOverheadEx_Dec_Holder"

    class QueryMemoryOverheadExResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryMemoryOverheadExResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryMemoryOverheadExResponse_Dec.schema
            TClist = [ZSI.TCnumbers.Ilong(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryMemoryOverheadExResponse')
            kw["aname"] = "_QueryMemoryOverheadExResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryMemoryOverheadExResponse_Holder"
            self.pyclass = Holder

    class ReconfigureHostForDAS_Dec(ElementDeclaration):
        literal = "ReconfigureHostForDAS"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureHostForDAS')
            kw["aname"] = "_ReconfigureHostForDAS"
            if ns0.ReconfigureHostForDASRequestType_Def not in ns0.ReconfigureHostForDAS_Dec.__bases__:
                bases = list(ns0.ReconfigureHostForDAS_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureHostForDASRequestType_Def)
                ns0.ReconfigureHostForDAS_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureHostForDASRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureHostForDAS_Dec_Holder"

    class ReconfigureHostForDASResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureHostForDASResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureHostForDASResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureHostForDASResponse')
            kw["aname"] = "_ReconfigureHostForDASResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureHostForDASResponse_Holder"
            self.pyclass = Holder

    class ReconfigureHostForDAS_Task_Dec(ElementDeclaration):
        literal = "ReconfigureHostForDAS_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureHostForDAS_Task')
            kw["aname"] = "_ReconfigureHostForDAS_Task"
            if ns0.ReconfigureHostForDASRequestType_Def not in ns0.ReconfigureHostForDAS_Task_Dec.__bases__:
                bases = list(ns0.ReconfigureHostForDAS_Task_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureHostForDASRequestType_Def)
                ns0.ReconfigureHostForDAS_Task_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureHostForDASRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureHostForDAS_Task_Dec_Holder"

    class ReconfigureHostForDAS_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureHostForDAS_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureHostForDAS_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReconfigureHostForDAS_TaskResponse')
            kw["aname"] = "_ReconfigureHostForDAS_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ReconfigureHostForDAS_TaskResponse_Holder"
            self.pyclass = Holder

    class UpdateFlags_Dec(ElementDeclaration):
        literal = "UpdateFlags"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateFlags')
            kw["aname"] = "_UpdateFlags"
            if ns0.UpdateFlagsRequestType_Def not in ns0.UpdateFlags_Dec.__bases__:
                bases = list(ns0.UpdateFlags_Dec.__bases__)
                bases.insert(0, ns0.UpdateFlagsRequestType_Def)
                ns0.UpdateFlags_Dec.__bases__ = tuple(bases)

            ns0.UpdateFlagsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateFlags_Dec_Holder"

    class UpdateFlagsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateFlagsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateFlagsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateFlagsResponse')
            kw["aname"] = "_UpdateFlagsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateFlagsResponse_Holder"
            self.pyclass = Holder

    class AcquireCimServicesTicket_Dec(ElementDeclaration):
        literal = "AcquireCimServicesTicket"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AcquireCimServicesTicket')
            kw["aname"] = "_AcquireCimServicesTicket"
            if ns0.AcquireCimServicesTicketRequestType_Def not in ns0.AcquireCimServicesTicket_Dec.__bases__:
                bases = list(ns0.AcquireCimServicesTicket_Dec.__bases__)
                bases.insert(0, ns0.AcquireCimServicesTicketRequestType_Def)
                ns0.AcquireCimServicesTicket_Dec.__bases__ = tuple(bases)

            ns0.AcquireCimServicesTicketRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AcquireCimServicesTicket_Dec_Holder"

    class AcquireCimServicesTicketResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AcquireCimServicesTicketResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AcquireCimServicesTicketResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostServiceTicket",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AcquireCimServicesTicketResponse')
            kw["aname"] = "_AcquireCimServicesTicketResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AcquireCimServicesTicketResponse_Holder"
            self.pyclass = Holder

    class QuerySupportedFeatures_Dec(ElementDeclaration):
        literal = "QuerySupportedFeatures"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QuerySupportedFeatures')
            kw["aname"] = "_QuerySupportedFeatures"
            if ns0.QuerySupportedFeaturesRequestType_Def not in ns0.QuerySupportedFeatures_Dec.__bases__:
                bases = list(ns0.QuerySupportedFeatures_Dec.__bases__)
                bases.insert(0, ns0.QuerySupportedFeaturesRequestType_Def)
                ns0.QuerySupportedFeatures_Dec.__bases__ = tuple(bases)

            ns0.QuerySupportedFeaturesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QuerySupportedFeatures_Dec_Holder"

    class QuerySupportedFeaturesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QuerySupportedFeaturesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QuerySupportedFeaturesResponse_Dec.schema
            TClist = [GTD("urn:vim25","LicenseFeatureInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QuerySupportedFeaturesResponse')
            kw["aname"] = "_QuerySupportedFeaturesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QuerySupportedFeaturesResponse_Holder"
            self.pyclass = Holder

    class QueryLicenseSourceAvailability_Dec(ElementDeclaration):
        literal = "QueryLicenseSourceAvailability"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryLicenseSourceAvailability')
            kw["aname"] = "_QueryLicenseSourceAvailability"
            if ns0.QueryLicenseSourceAvailabilityRequestType_Def not in ns0.QueryLicenseSourceAvailability_Dec.__bases__:
                bases = list(ns0.QueryLicenseSourceAvailability_Dec.__bases__)
                bases.insert(0, ns0.QueryLicenseSourceAvailabilityRequestType_Def)
                ns0.QueryLicenseSourceAvailability_Dec.__bases__ = tuple(bases)

            ns0.QueryLicenseSourceAvailabilityRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryLicenseSourceAvailability_Dec_Holder"

    class QueryLicenseSourceAvailabilityResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryLicenseSourceAvailabilityResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryLicenseSourceAvailabilityResponse_Dec.schema
            TClist = [GTD("urn:vim25","LicenseAvailabilityInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryLicenseSourceAvailabilityResponse')
            kw["aname"] = "_QueryLicenseSourceAvailabilityResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryLicenseSourceAvailabilityResponse_Holder"
            self.pyclass = Holder

    class QueryLicenseUsage_Dec(ElementDeclaration):
        literal = "QueryLicenseUsage"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryLicenseUsage')
            kw["aname"] = "_QueryLicenseUsage"
            if ns0.QueryLicenseUsageRequestType_Def not in ns0.QueryLicenseUsage_Dec.__bases__:
                bases = list(ns0.QueryLicenseUsage_Dec.__bases__)
                bases.insert(0, ns0.QueryLicenseUsageRequestType_Def)
                ns0.QueryLicenseUsage_Dec.__bases__ = tuple(bases)

            ns0.QueryLicenseUsageRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryLicenseUsage_Dec_Holder"

    class QueryLicenseUsageResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryLicenseUsageResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryLicenseUsageResponse_Dec.schema
            TClist = [GTD("urn:vim25","LicenseUsageInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryLicenseUsageResponse')
            kw["aname"] = "_QueryLicenseUsageResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryLicenseUsageResponse_Holder"
            self.pyclass = Holder

    class SetLicenseEdition_Dec(ElementDeclaration):
        literal = "SetLicenseEdition"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetLicenseEdition')
            kw["aname"] = "_SetLicenseEdition"
            if ns0.SetLicenseEditionRequestType_Def not in ns0.SetLicenseEdition_Dec.__bases__:
                bases = list(ns0.SetLicenseEdition_Dec.__bases__)
                bases.insert(0, ns0.SetLicenseEditionRequestType_Def)
                ns0.SetLicenseEdition_Dec.__bases__ = tuple(bases)

            ns0.SetLicenseEditionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetLicenseEdition_Dec_Holder"

    class SetLicenseEditionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetLicenseEditionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetLicenseEditionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetLicenseEditionResponse')
            kw["aname"] = "_SetLicenseEditionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetLicenseEditionResponse_Holder"
            self.pyclass = Holder

    class CheckLicenseFeature_Dec(ElementDeclaration):
        literal = "CheckLicenseFeature"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CheckLicenseFeature')
            kw["aname"] = "_CheckLicenseFeature"
            if ns0.CheckLicenseFeatureRequestType_Def not in ns0.CheckLicenseFeature_Dec.__bases__:
                bases = list(ns0.CheckLicenseFeature_Dec.__bases__)
                bases.insert(0, ns0.CheckLicenseFeatureRequestType_Def)
                ns0.CheckLicenseFeature_Dec.__bases__ = tuple(bases)

            ns0.CheckLicenseFeatureRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CheckLicenseFeature_Dec_Holder"

    class CheckLicenseFeatureResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CheckLicenseFeatureResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CheckLicenseFeatureResponse_Dec.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CheckLicenseFeatureResponse')
            kw["aname"] = "_CheckLicenseFeatureResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CheckLicenseFeatureResponse_Holder"
            self.pyclass = Holder

    class EnableFeature_Dec(ElementDeclaration):
        literal = "EnableFeature"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'EnableFeature')
            kw["aname"] = "_EnableFeature"
            if ns0.EnableFeatureRequestType_Def not in ns0.EnableFeature_Dec.__bases__:
                bases = list(ns0.EnableFeature_Dec.__bases__)
                bases.insert(0, ns0.EnableFeatureRequestType_Def)
                ns0.EnableFeature_Dec.__bases__ = tuple(bases)

            ns0.EnableFeatureRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "EnableFeature_Dec_Holder"

    class EnableFeatureResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "EnableFeatureResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.EnableFeatureResponse_Dec.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'EnableFeatureResponse')
            kw["aname"] = "_EnableFeatureResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "EnableFeatureResponse_Holder"
            self.pyclass = Holder

    class DisableFeature_Dec(ElementDeclaration):
        literal = "DisableFeature"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisableFeature')
            kw["aname"] = "_DisableFeature"
            if ns0.DisableFeatureRequestType_Def not in ns0.DisableFeature_Dec.__bases__:
                bases = list(ns0.DisableFeature_Dec.__bases__)
                bases.insert(0, ns0.DisableFeatureRequestType_Def)
                ns0.DisableFeature_Dec.__bases__ = tuple(bases)

            ns0.DisableFeatureRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisableFeature_Dec_Holder"

    class DisableFeatureResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DisableFeatureResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DisableFeatureResponse_Dec.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'DisableFeatureResponse')
            kw["aname"] = "_DisableFeatureResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "DisableFeatureResponse_Holder"
            self.pyclass = Holder

    class ConfigureLicenseSource_Dec(ElementDeclaration):
        literal = "ConfigureLicenseSource"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ConfigureLicenseSource')
            kw["aname"] = "_ConfigureLicenseSource"
            if ns0.ConfigureLicenseSourceRequestType_Def not in ns0.ConfigureLicenseSource_Dec.__bases__:
                bases = list(ns0.ConfigureLicenseSource_Dec.__bases__)
                bases.insert(0, ns0.ConfigureLicenseSourceRequestType_Def)
                ns0.ConfigureLicenseSource_Dec.__bases__ = tuple(bases)

            ns0.ConfigureLicenseSourceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ConfigureLicenseSource_Dec_Holder"

    class ConfigureLicenseSourceResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ConfigureLicenseSourceResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ConfigureLicenseSourceResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ConfigureLicenseSourceResponse')
            kw["aname"] = "_ConfigureLicenseSourceResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ConfigureLicenseSourceResponse_Holder"
            self.pyclass = Holder

    class Reload_Dec(ElementDeclaration):
        literal = "Reload"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'Reload')
            kw["aname"] = "_Reload"
            if ns0.ReloadRequestType_Def not in ns0.Reload_Dec.__bases__:
                bases = list(ns0.Reload_Dec.__bases__)
                bases.insert(0, ns0.ReloadRequestType_Def)
                ns0.Reload_Dec.__bases__ = tuple(bases)

            ns0.ReloadRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "Reload_Dec_Holder"

    class ReloadResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReloadResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReloadResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReloadResponse')
            kw["aname"] = "_ReloadResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReloadResponse_Holder"
            self.pyclass = Holder

    class Rename_Dec(ElementDeclaration):
        literal = "Rename"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'Rename')
            kw["aname"] = "_Rename"
            if ns0.RenameRequestType_Def not in ns0.Rename_Dec.__bases__:
                bases = list(ns0.Rename_Dec.__bases__)
                bases.insert(0, ns0.RenameRequestType_Def)
                ns0.Rename_Dec.__bases__ = tuple(bases)

            ns0.RenameRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "Rename_Dec_Holder"

    class RenameResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RenameResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RenameResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RenameResponse')
            kw["aname"] = "_RenameResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RenameResponse_Holder"
            self.pyclass = Holder

    class Rename_Task_Dec(ElementDeclaration):
        literal = "Rename_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'Rename_Task')
            kw["aname"] = "_Rename_Task"
            if ns0.RenameRequestType_Def not in ns0.Rename_Task_Dec.__bases__:
                bases = list(ns0.Rename_Task_Dec.__bases__)
                bases.insert(0, ns0.RenameRequestType_Def)
                ns0.Rename_Task_Dec.__bases__ = tuple(bases)

            ns0.RenameRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "Rename_Task_Dec_Holder"

    class Rename_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "Rename_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.Rename_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'Rename_TaskResponse')
            kw["aname"] = "_Rename_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "Rename_TaskResponse_Holder"
            self.pyclass = Holder

    class Destroy_Dec(ElementDeclaration):
        literal = "Destroy"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'Destroy')
            kw["aname"] = "_Destroy"
            if ns0.DestroyRequestType_Def not in ns0.Destroy_Dec.__bases__:
                bases = list(ns0.Destroy_Dec.__bases__)
                bases.insert(0, ns0.DestroyRequestType_Def)
                ns0.Destroy_Dec.__bases__ = tuple(bases)

            ns0.DestroyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "Destroy_Dec_Holder"

    class DestroyResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DestroyResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DestroyResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DestroyResponse')
            kw["aname"] = "_DestroyResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DestroyResponse_Holder"
            self.pyclass = Holder

    class Destroy_Task_Dec(ElementDeclaration):
        literal = "Destroy_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'Destroy_Task')
            kw["aname"] = "_Destroy_Task"
            if ns0.DestroyRequestType_Def not in ns0.Destroy_Task_Dec.__bases__:
                bases = list(ns0.Destroy_Task_Dec.__bases__)
                bases.insert(0, ns0.DestroyRequestType_Def)
                ns0.Destroy_Task_Dec.__bases__ = tuple(bases)

            ns0.DestroyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "Destroy_Task_Dec_Holder"

    class Destroy_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "Destroy_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.Destroy_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'Destroy_TaskResponse')
            kw["aname"] = "_Destroy_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "Destroy_TaskResponse_Holder"
            self.pyclass = Holder

    class DestroyNetwork_Dec(ElementDeclaration):
        literal = "DestroyNetwork"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DestroyNetwork')
            kw["aname"] = "_DestroyNetwork"
            if ns0.DestroyNetworkRequestType_Def not in ns0.DestroyNetwork_Dec.__bases__:
                bases = list(ns0.DestroyNetwork_Dec.__bases__)
                bases.insert(0, ns0.DestroyNetworkRequestType_Def)
                ns0.DestroyNetwork_Dec.__bases__ = tuple(bases)

            ns0.DestroyNetworkRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DestroyNetwork_Dec_Holder"

    class DestroyNetworkResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DestroyNetworkResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DestroyNetworkResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DestroyNetworkResponse')
            kw["aname"] = "_DestroyNetworkResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DestroyNetworkResponse_Holder"
            self.pyclass = Holder

    class QueryPerfProviderSummary_Dec(ElementDeclaration):
        literal = "QueryPerfProviderSummary"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryPerfProviderSummary')
            kw["aname"] = "_QueryPerfProviderSummary"
            if ns0.QueryPerfProviderSummaryRequestType_Def not in ns0.QueryPerfProviderSummary_Dec.__bases__:
                bases = list(ns0.QueryPerfProviderSummary_Dec.__bases__)
                bases.insert(0, ns0.QueryPerfProviderSummaryRequestType_Def)
                ns0.QueryPerfProviderSummary_Dec.__bases__ = tuple(bases)

            ns0.QueryPerfProviderSummaryRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryPerfProviderSummary_Dec_Holder"

    class QueryPerfProviderSummaryResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryPerfProviderSummaryResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryPerfProviderSummaryResponse_Dec.schema
            TClist = [GTD("urn:vim25","PerfProviderSummary",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryPerfProviderSummaryResponse')
            kw["aname"] = "_QueryPerfProviderSummaryResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryPerfProviderSummaryResponse_Holder"
            self.pyclass = Holder

    class QueryAvailablePerfMetric_Dec(ElementDeclaration):
        literal = "QueryAvailablePerfMetric"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryAvailablePerfMetric')
            kw["aname"] = "_QueryAvailablePerfMetric"
            if ns0.QueryAvailablePerfMetricRequestType_Def not in ns0.QueryAvailablePerfMetric_Dec.__bases__:
                bases = list(ns0.QueryAvailablePerfMetric_Dec.__bases__)
                bases.insert(0, ns0.QueryAvailablePerfMetricRequestType_Def)
                ns0.QueryAvailablePerfMetric_Dec.__bases__ = tuple(bases)

            ns0.QueryAvailablePerfMetricRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryAvailablePerfMetric_Dec_Holder"

    class QueryAvailablePerfMetricResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryAvailablePerfMetricResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryAvailablePerfMetricResponse_Dec.schema
            TClist = [GTD("urn:vim25","PerfMetricId",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryAvailablePerfMetricResponse')
            kw["aname"] = "_QueryAvailablePerfMetricResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryAvailablePerfMetricResponse_Holder"
            self.pyclass = Holder

    class QueryPerfCounter_Dec(ElementDeclaration):
        literal = "QueryPerfCounter"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryPerfCounter')
            kw["aname"] = "_QueryPerfCounter"
            if ns0.QueryPerfCounterRequestType_Def not in ns0.QueryPerfCounter_Dec.__bases__:
                bases = list(ns0.QueryPerfCounter_Dec.__bases__)
                bases.insert(0, ns0.QueryPerfCounterRequestType_Def)
                ns0.QueryPerfCounter_Dec.__bases__ = tuple(bases)

            ns0.QueryPerfCounterRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryPerfCounter_Dec_Holder"

    class QueryPerfCounterResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryPerfCounterResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryPerfCounterResponse_Dec.schema
            TClist = [GTD("urn:vim25","PerfCounterInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryPerfCounterResponse')
            kw["aname"] = "_QueryPerfCounterResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryPerfCounterResponse_Holder"
            self.pyclass = Holder

    class QueryPerfCounterByLevel_Dec(ElementDeclaration):
        literal = "QueryPerfCounterByLevel"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryPerfCounterByLevel')
            kw["aname"] = "_QueryPerfCounterByLevel"
            if ns0.QueryPerfCounterByLevelRequestType_Def not in ns0.QueryPerfCounterByLevel_Dec.__bases__:
                bases = list(ns0.QueryPerfCounterByLevel_Dec.__bases__)
                bases.insert(0, ns0.QueryPerfCounterByLevelRequestType_Def)
                ns0.QueryPerfCounterByLevel_Dec.__bases__ = tuple(bases)

            ns0.QueryPerfCounterByLevelRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryPerfCounterByLevel_Dec_Holder"

    class QueryPerfCounterByLevelResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryPerfCounterByLevelResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryPerfCounterByLevelResponse_Dec.schema
            TClist = [GTD("urn:vim25","PerfCounterInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryPerfCounterByLevelResponse')
            kw["aname"] = "_QueryPerfCounterByLevelResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryPerfCounterByLevelResponse_Holder"
            self.pyclass = Holder

    class QueryPerf_Dec(ElementDeclaration):
        literal = "QueryPerf"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryPerf')
            kw["aname"] = "_QueryPerf"
            if ns0.QueryPerfRequestType_Def not in ns0.QueryPerf_Dec.__bases__:
                bases = list(ns0.QueryPerf_Dec.__bases__)
                bases.insert(0, ns0.QueryPerfRequestType_Def)
                ns0.QueryPerf_Dec.__bases__ = tuple(bases)

            ns0.QueryPerfRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryPerf_Dec_Holder"

    class QueryPerfResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryPerfResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryPerfResponse_Dec.schema
            TClist = [GTD("urn:vim25","PerfEntityMetricBase",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryPerfResponse')
            kw["aname"] = "_QueryPerfResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryPerfResponse_Holder"
            self.pyclass = Holder

    class QueryPerfComposite_Dec(ElementDeclaration):
        literal = "QueryPerfComposite"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryPerfComposite')
            kw["aname"] = "_QueryPerfComposite"
            if ns0.QueryPerfCompositeRequestType_Def not in ns0.QueryPerfComposite_Dec.__bases__:
                bases = list(ns0.QueryPerfComposite_Dec.__bases__)
                bases.insert(0, ns0.QueryPerfCompositeRequestType_Def)
                ns0.QueryPerfComposite_Dec.__bases__ = tuple(bases)

            ns0.QueryPerfCompositeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryPerfComposite_Dec_Holder"

    class QueryPerfCompositeResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryPerfCompositeResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryPerfCompositeResponse_Dec.schema
            TClist = [GTD("urn:vim25","PerfCompositeMetric",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryPerfCompositeResponse')
            kw["aname"] = "_QueryPerfCompositeResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryPerfCompositeResponse_Holder"
            self.pyclass = Holder

    class CreatePerfInterval_Dec(ElementDeclaration):
        literal = "CreatePerfInterval"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreatePerfInterval')
            kw["aname"] = "_CreatePerfInterval"
            if ns0.CreatePerfIntervalRequestType_Def not in ns0.CreatePerfInterval_Dec.__bases__:
                bases = list(ns0.CreatePerfInterval_Dec.__bases__)
                bases.insert(0, ns0.CreatePerfIntervalRequestType_Def)
                ns0.CreatePerfInterval_Dec.__bases__ = tuple(bases)

            ns0.CreatePerfIntervalRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreatePerfInterval_Dec_Holder"

    class CreatePerfIntervalResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreatePerfIntervalResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreatePerfIntervalResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CreatePerfIntervalResponse')
            kw["aname"] = "_CreatePerfIntervalResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CreatePerfIntervalResponse_Holder"
            self.pyclass = Holder

    class RemovePerfInterval_Dec(ElementDeclaration):
        literal = "RemovePerfInterval"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemovePerfInterval')
            kw["aname"] = "_RemovePerfInterval"
            if ns0.RemovePerfIntervalRequestType_Def not in ns0.RemovePerfInterval_Dec.__bases__:
                bases = list(ns0.RemovePerfInterval_Dec.__bases__)
                bases.insert(0, ns0.RemovePerfIntervalRequestType_Def)
                ns0.RemovePerfInterval_Dec.__bases__ = tuple(bases)

            ns0.RemovePerfIntervalRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemovePerfInterval_Dec_Holder"

    class RemovePerfIntervalResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemovePerfIntervalResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemovePerfIntervalResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemovePerfIntervalResponse')
            kw["aname"] = "_RemovePerfIntervalResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemovePerfIntervalResponse_Holder"
            self.pyclass = Holder

    class UpdatePerfInterval_Dec(ElementDeclaration):
        literal = "UpdatePerfInterval"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdatePerfInterval')
            kw["aname"] = "_UpdatePerfInterval"
            if ns0.UpdatePerfIntervalRequestType_Def not in ns0.UpdatePerfInterval_Dec.__bases__:
                bases = list(ns0.UpdatePerfInterval_Dec.__bases__)
                bases.insert(0, ns0.UpdatePerfIntervalRequestType_Def)
                ns0.UpdatePerfInterval_Dec.__bases__ = tuple(bases)

            ns0.UpdatePerfIntervalRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdatePerfInterval_Dec_Holder"

    class UpdatePerfIntervalResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdatePerfIntervalResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdatePerfIntervalResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdatePerfIntervalResponse')
            kw["aname"] = "_UpdatePerfIntervalResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdatePerfIntervalResponse_Holder"
            self.pyclass = Holder

    class UpdateConfig_Dec(ElementDeclaration):
        literal = "UpdateConfig"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateConfig')
            kw["aname"] = "_UpdateConfig"
            if ns0.UpdateConfigRequestType_Def not in ns0.UpdateConfig_Dec.__bases__:
                bases = list(ns0.UpdateConfig_Dec.__bases__)
                bases.insert(0, ns0.UpdateConfigRequestType_Def)
                ns0.UpdateConfig_Dec.__bases__ = tuple(bases)

            ns0.UpdateConfigRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateConfig_Dec_Holder"

    class UpdateConfigResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateConfigResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateConfigResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateConfigResponse')
            kw["aname"] = "_UpdateConfigResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateConfigResponse_Holder"
            self.pyclass = Holder

    class MoveIntoResourcePool_Dec(ElementDeclaration):
        literal = "MoveIntoResourcePool"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveIntoResourcePool')
            kw["aname"] = "_MoveIntoResourcePool"
            if ns0.MoveIntoResourcePoolRequestType_Def not in ns0.MoveIntoResourcePool_Dec.__bases__:
                bases = list(ns0.MoveIntoResourcePool_Dec.__bases__)
                bases.insert(0, ns0.MoveIntoResourcePoolRequestType_Def)
                ns0.MoveIntoResourcePool_Dec.__bases__ = tuple(bases)

            ns0.MoveIntoResourcePoolRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveIntoResourcePool_Dec_Holder"

    class MoveIntoResourcePoolResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveIntoResourcePoolResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveIntoResourcePoolResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MoveIntoResourcePoolResponse')
            kw["aname"] = "_MoveIntoResourcePoolResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MoveIntoResourcePoolResponse_Holder"
            self.pyclass = Holder

    class UpdateChildResourceConfiguration_Dec(ElementDeclaration):
        literal = "UpdateChildResourceConfiguration"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateChildResourceConfiguration')
            kw["aname"] = "_UpdateChildResourceConfiguration"
            if ns0.UpdateChildResourceConfigurationRequestType_Def not in ns0.UpdateChildResourceConfiguration_Dec.__bases__:
                bases = list(ns0.UpdateChildResourceConfiguration_Dec.__bases__)
                bases.insert(0, ns0.UpdateChildResourceConfigurationRequestType_Def)
                ns0.UpdateChildResourceConfiguration_Dec.__bases__ = tuple(bases)

            ns0.UpdateChildResourceConfigurationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateChildResourceConfiguration_Dec_Holder"

    class UpdateChildResourceConfigurationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateChildResourceConfigurationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateChildResourceConfigurationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateChildResourceConfigurationResponse')
            kw["aname"] = "_UpdateChildResourceConfigurationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateChildResourceConfigurationResponse_Holder"
            self.pyclass = Holder

    class CreateResourcePool_Dec(ElementDeclaration):
        literal = "CreateResourcePool"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateResourcePool')
            kw["aname"] = "_CreateResourcePool"
            if ns0.CreateResourcePoolRequestType_Def not in ns0.CreateResourcePool_Dec.__bases__:
                bases = list(ns0.CreateResourcePool_Dec.__bases__)
                bases.insert(0, ns0.CreateResourcePoolRequestType_Def)
                ns0.CreateResourcePool_Dec.__bases__ = tuple(bases)

            ns0.CreateResourcePoolRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateResourcePool_Dec_Holder"

    class CreateResourcePoolResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateResourcePoolResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateResourcePoolResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateResourcePoolResponse')
            kw["aname"] = "_CreateResourcePoolResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateResourcePoolResponse_Holder"
            self.pyclass = Holder

    class DestroyChildren_Dec(ElementDeclaration):
        literal = "DestroyChildren"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DestroyChildren')
            kw["aname"] = "_DestroyChildren"
            if ns0.DestroyChildrenRequestType_Def not in ns0.DestroyChildren_Dec.__bases__:
                bases = list(ns0.DestroyChildren_Dec.__bases__)
                bases.insert(0, ns0.DestroyChildrenRequestType_Def)
                ns0.DestroyChildren_Dec.__bases__ = tuple(bases)

            ns0.DestroyChildrenRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DestroyChildren_Dec_Holder"

    class DestroyChildrenResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DestroyChildrenResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DestroyChildrenResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DestroyChildrenResponse')
            kw["aname"] = "_DestroyChildrenResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DestroyChildrenResponse_Holder"
            self.pyclass = Holder

    class FindByUuid_Dec(ElementDeclaration):
        literal = "FindByUuid"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FindByUuid')
            kw["aname"] = "_FindByUuid"
            if ns0.FindByUuidRequestType_Def not in ns0.FindByUuid_Dec.__bases__:
                bases = list(ns0.FindByUuid_Dec.__bases__)
                bases.insert(0, ns0.FindByUuidRequestType_Def)
                ns0.FindByUuid_Dec.__bases__ = tuple(bases)

            ns0.FindByUuidRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FindByUuid_Dec_Holder"

    class FindByUuidResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FindByUuidResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FindByUuidResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FindByUuidResponse')
            kw["aname"] = "_FindByUuidResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FindByUuidResponse_Holder"
            self.pyclass = Holder

    class FindByDatastorePath_Dec(ElementDeclaration):
        literal = "FindByDatastorePath"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FindByDatastorePath')
            kw["aname"] = "_FindByDatastorePath"
            if ns0.FindByDatastorePathRequestType_Def not in ns0.FindByDatastorePath_Dec.__bases__:
                bases = list(ns0.FindByDatastorePath_Dec.__bases__)
                bases.insert(0, ns0.FindByDatastorePathRequestType_Def)
                ns0.FindByDatastorePath_Dec.__bases__ = tuple(bases)

            ns0.FindByDatastorePathRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FindByDatastorePath_Dec_Holder"

    class FindByDatastorePathResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FindByDatastorePathResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FindByDatastorePathResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FindByDatastorePathResponse')
            kw["aname"] = "_FindByDatastorePathResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FindByDatastorePathResponse_Holder"
            self.pyclass = Holder

    class FindByDnsName_Dec(ElementDeclaration):
        literal = "FindByDnsName"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FindByDnsName')
            kw["aname"] = "_FindByDnsName"
            if ns0.FindByDnsNameRequestType_Def not in ns0.FindByDnsName_Dec.__bases__:
                bases = list(ns0.FindByDnsName_Dec.__bases__)
                bases.insert(0, ns0.FindByDnsNameRequestType_Def)
                ns0.FindByDnsName_Dec.__bases__ = tuple(bases)

            ns0.FindByDnsNameRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FindByDnsName_Dec_Holder"

    class FindByDnsNameResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FindByDnsNameResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FindByDnsNameResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FindByDnsNameResponse')
            kw["aname"] = "_FindByDnsNameResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FindByDnsNameResponse_Holder"
            self.pyclass = Holder

    class FindByIp_Dec(ElementDeclaration):
        literal = "FindByIp"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FindByIp')
            kw["aname"] = "_FindByIp"
            if ns0.FindByIpRequestType_Def not in ns0.FindByIp_Dec.__bases__:
                bases = list(ns0.FindByIp_Dec.__bases__)
                bases.insert(0, ns0.FindByIpRequestType_Def)
                ns0.FindByIp_Dec.__bases__ = tuple(bases)

            ns0.FindByIpRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FindByIp_Dec_Holder"

    class FindByIpResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FindByIpResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FindByIpResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FindByIpResponse')
            kw["aname"] = "_FindByIpResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FindByIpResponse_Holder"
            self.pyclass = Holder

    class FindByInventoryPath_Dec(ElementDeclaration):
        literal = "FindByInventoryPath"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FindByInventoryPath')
            kw["aname"] = "_FindByInventoryPath"
            if ns0.FindByInventoryPathRequestType_Def not in ns0.FindByInventoryPath_Dec.__bases__:
                bases = list(ns0.FindByInventoryPath_Dec.__bases__)
                bases.insert(0, ns0.FindByInventoryPathRequestType_Def)
                ns0.FindByInventoryPath_Dec.__bases__ = tuple(bases)

            ns0.FindByInventoryPathRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FindByInventoryPath_Dec_Holder"

    class FindByInventoryPathResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FindByInventoryPathResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FindByInventoryPathResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FindByInventoryPathResponse')
            kw["aname"] = "_FindByInventoryPathResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FindByInventoryPathResponse_Holder"
            self.pyclass = Holder

    class FindChild_Dec(ElementDeclaration):
        literal = "FindChild"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FindChild')
            kw["aname"] = "_FindChild"
            if ns0.FindChildRequestType_Def not in ns0.FindChild_Dec.__bases__:
                bases = list(ns0.FindChild_Dec.__bases__)
                bases.insert(0, ns0.FindChildRequestType_Def)
                ns0.FindChild_Dec.__bases__ = tuple(bases)

            ns0.FindChildRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FindChild_Dec_Holder"

    class FindChildResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FindChildResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FindChildResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FindChildResponse')
            kw["aname"] = "_FindChildResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FindChildResponse_Holder"
            self.pyclass = Holder

    class CurrentTime_Dec(ElementDeclaration):
        literal = "CurrentTime"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CurrentTime')
            kw["aname"] = "_CurrentTime"
            if ns0.CurrentTimeRequestType_Def not in ns0.CurrentTime_Dec.__bases__:
                bases = list(ns0.CurrentTime_Dec.__bases__)
                bases.insert(0, ns0.CurrentTimeRequestType_Def)
                ns0.CurrentTime_Dec.__bases__ = tuple(bases)

            ns0.CurrentTimeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CurrentTime_Dec_Holder"

    class CurrentTimeResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CurrentTimeResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CurrentTimeResponse_Dec.schema
            TClist = [ZSI.TCtimes.gDateTime(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CurrentTimeResponse')
            kw["aname"] = "_CurrentTimeResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CurrentTimeResponse_Holder"
            self.pyclass = Holder

    class RetrieveServiceContent_Dec(ElementDeclaration):
        literal = "RetrieveServiceContent"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveServiceContent')
            kw["aname"] = "_RetrieveServiceContent"
            if ns0.RetrieveServiceContentRequestType_Def not in ns0.RetrieveServiceContent_Dec.__bases__:
                bases = list(ns0.RetrieveServiceContent_Dec.__bases__)
                bases.insert(0, ns0.RetrieveServiceContentRequestType_Def)
                ns0.RetrieveServiceContent_Dec.__bases__ = tuple(bases)

            ns0.RetrieveServiceContentRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveServiceContent_Dec_Holder"

    class RetrieveServiceContentResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveServiceContentResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveServiceContentResponse_Dec.schema
            TClist = [GTD("urn:vim25","ServiceContent",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveServiceContentResponse')
            kw["aname"] = "_RetrieveServiceContentResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RetrieveServiceContentResponse_Holder"
            self.pyclass = Holder

    class ValidateMigration_Dec(ElementDeclaration):
        literal = "ValidateMigration"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ValidateMigration')
            kw["aname"] = "_ValidateMigration"
            if ns0.ValidateMigrationRequestType_Def not in ns0.ValidateMigration_Dec.__bases__:
                bases = list(ns0.ValidateMigration_Dec.__bases__)
                bases.insert(0, ns0.ValidateMigrationRequestType_Def)
                ns0.ValidateMigration_Dec.__bases__ = tuple(bases)

            ns0.ValidateMigrationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ValidateMigration_Dec_Holder"

    class ValidateMigrationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ValidateMigrationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ValidateMigrationResponse_Dec.schema
            TClist = [GTD("urn:vim25","Event",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ValidateMigrationResponse')
            kw["aname"] = "_ValidateMigrationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ValidateMigrationResponse_Holder"
            self.pyclass = Holder

    class QueryVMotionCompatibility_Dec(ElementDeclaration):
        literal = "QueryVMotionCompatibility"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryVMotionCompatibility')
            kw["aname"] = "_QueryVMotionCompatibility"
            if ns0.QueryVMotionCompatibilityRequestType_Def not in ns0.QueryVMotionCompatibility_Dec.__bases__:
                bases = list(ns0.QueryVMotionCompatibility_Dec.__bases__)
                bases.insert(0, ns0.QueryVMotionCompatibilityRequestType_Def)
                ns0.QueryVMotionCompatibility_Dec.__bases__ = tuple(bases)

            ns0.QueryVMotionCompatibilityRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryVMotionCompatibility_Dec_Holder"

    class QueryVMotionCompatibilityResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryVMotionCompatibilityResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryVMotionCompatibilityResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostVMotionCompatibility",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryVMotionCompatibilityResponse')
            kw["aname"] = "_QueryVMotionCompatibilityResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryVMotionCompatibilityResponse_Holder"
            self.pyclass = Holder

    class RetrieveProductComponents_Dec(ElementDeclaration):
        literal = "RetrieveProductComponents"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveProductComponents')
            kw["aname"] = "_RetrieveProductComponents"
            if ns0.RetrieveProductComponentsRequestType_Def not in ns0.RetrieveProductComponents_Dec.__bases__:
                bases = list(ns0.RetrieveProductComponents_Dec.__bases__)
                bases.insert(0, ns0.RetrieveProductComponentsRequestType_Def)
                ns0.RetrieveProductComponents_Dec.__bases__ = tuple(bases)

            ns0.RetrieveProductComponentsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveProductComponents_Dec_Holder"

    class RetrieveProductComponentsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveProductComponentsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveProductComponentsResponse_Dec.schema
            TClist = [GTD("urn:vim25","ProductComponentInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveProductComponentsResponse')
            kw["aname"] = "_RetrieveProductComponentsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrieveProductComponentsResponse_Holder"
            self.pyclass = Holder

    class UpdateServiceMessage_Dec(ElementDeclaration):
        literal = "UpdateServiceMessage"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateServiceMessage')
            kw["aname"] = "_UpdateServiceMessage"
            if ns0.UpdateServiceMessageRequestType_Def not in ns0.UpdateServiceMessage_Dec.__bases__:
                bases = list(ns0.UpdateServiceMessage_Dec.__bases__)
                bases.insert(0, ns0.UpdateServiceMessageRequestType_Def)
                ns0.UpdateServiceMessage_Dec.__bases__ = tuple(bases)

            ns0.UpdateServiceMessageRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateServiceMessage_Dec_Holder"

    class UpdateServiceMessageResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateServiceMessageResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateServiceMessageResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateServiceMessageResponse')
            kw["aname"] = "_UpdateServiceMessageResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateServiceMessageResponse_Holder"
            self.pyclass = Holder

    class Login_Dec(ElementDeclaration):
        literal = "Login"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'Login')
            kw["aname"] = "_Login"
            if ns0.LoginRequestType_Def not in ns0.Login_Dec.__bases__:
                bases = list(ns0.Login_Dec.__bases__)
                bases.insert(0, ns0.LoginRequestType_Def)
                ns0.Login_Dec.__bases__ = tuple(bases)

            ns0.LoginRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "Login_Dec_Holder"

    class LoginResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "LoginResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.LoginResponse_Dec.schema
            TClist = [GTD("urn:vim25","UserSession",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'LoginResponse')
            kw["aname"] = "_LoginResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "LoginResponse_Holder"
            self.pyclass = Holder

    class LoginBySSPI_Dec(ElementDeclaration):
        literal = "LoginBySSPI"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LoginBySSPI')
            kw["aname"] = "_LoginBySSPI"
            if ns0.LoginBySSPIRequestType_Def not in ns0.LoginBySSPI_Dec.__bases__:
                bases = list(ns0.LoginBySSPI_Dec.__bases__)
                bases.insert(0, ns0.LoginBySSPIRequestType_Def)
                ns0.LoginBySSPI_Dec.__bases__ = tuple(bases)

            ns0.LoginBySSPIRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LoginBySSPI_Dec_Holder"

    class LoginBySSPIResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "LoginBySSPIResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.LoginBySSPIResponse_Dec.schema
            TClist = [GTD("urn:vim25","UserSession",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'LoginBySSPIResponse')
            kw["aname"] = "_LoginBySSPIResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "LoginBySSPIResponse_Holder"
            self.pyclass = Holder

    class Logout_Dec(ElementDeclaration):
        literal = "Logout"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'Logout')
            kw["aname"] = "_Logout"
            if ns0.LogoutRequestType_Def not in ns0.Logout_Dec.__bases__:
                bases = list(ns0.Logout_Dec.__bases__)
                bases.insert(0, ns0.LogoutRequestType_Def)
                ns0.Logout_Dec.__bases__ = tuple(bases)

            ns0.LogoutRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "Logout_Dec_Holder"

    class LogoutResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "LogoutResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.LogoutResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'LogoutResponse')
            kw["aname"] = "_LogoutResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "LogoutResponse_Holder"
            self.pyclass = Holder

    class AcquireLocalTicket_Dec(ElementDeclaration):
        literal = "AcquireLocalTicket"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AcquireLocalTicket')
            kw["aname"] = "_AcquireLocalTicket"
            if ns0.AcquireLocalTicketRequestType_Def not in ns0.AcquireLocalTicket_Dec.__bases__:
                bases = list(ns0.AcquireLocalTicket_Dec.__bases__)
                bases.insert(0, ns0.AcquireLocalTicketRequestType_Def)
                ns0.AcquireLocalTicket_Dec.__bases__ = tuple(bases)

            ns0.AcquireLocalTicketRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AcquireLocalTicket_Dec_Holder"

    class AcquireLocalTicketResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AcquireLocalTicketResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AcquireLocalTicketResponse_Dec.schema
            TClist = [GTD("urn:vim25","SessionManagerLocalTicket",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AcquireLocalTicketResponse')
            kw["aname"] = "_AcquireLocalTicketResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AcquireLocalTicketResponse_Holder"
            self.pyclass = Holder

    class TerminateSession_Dec(ElementDeclaration):
        literal = "TerminateSession"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TerminateSession')
            kw["aname"] = "_TerminateSession"
            if ns0.TerminateSessionRequestType_Def not in ns0.TerminateSession_Dec.__bases__:
                bases = list(ns0.TerminateSession_Dec.__bases__)
                bases.insert(0, ns0.TerminateSessionRequestType_Def)
                ns0.TerminateSession_Dec.__bases__ = tuple(bases)

            ns0.TerminateSessionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TerminateSession_Dec_Holder"

    class TerminateSessionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "TerminateSessionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.TerminateSessionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'TerminateSessionResponse')
            kw["aname"] = "_TerminateSessionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "TerminateSessionResponse_Holder"
            self.pyclass = Holder

    class SetLocale_Dec(ElementDeclaration):
        literal = "SetLocale"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetLocale')
            kw["aname"] = "_SetLocale"
            if ns0.SetLocaleRequestType_Def not in ns0.SetLocale_Dec.__bases__:
                bases = list(ns0.SetLocale_Dec.__bases__)
                bases.insert(0, ns0.SetLocaleRequestType_Def)
                ns0.SetLocale_Dec.__bases__ = tuple(bases)

            ns0.SetLocaleRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetLocale_Dec_Holder"

    class SetLocaleResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetLocaleResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetLocaleResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetLocaleResponse')
            kw["aname"] = "_SetLocaleResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetLocaleResponse_Holder"
            self.pyclass = Holder

    class ImpersonateUser_Dec(ElementDeclaration):
        literal = "ImpersonateUser"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ImpersonateUser')
            kw["aname"] = "_ImpersonateUser"
            if ns0.ImpersonateUserRequestType_Def not in ns0.ImpersonateUser_Dec.__bases__:
                bases = list(ns0.ImpersonateUser_Dec.__bases__)
                bases.insert(0, ns0.ImpersonateUserRequestType_Def)
                ns0.ImpersonateUser_Dec.__bases__ = tuple(bases)

            ns0.ImpersonateUserRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ImpersonateUser_Dec_Holder"

    class ImpersonateUserResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ImpersonateUserResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ImpersonateUserResponse_Dec.schema
            TClist = [GTD("urn:vim25","UserSession",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ImpersonateUserResponse')
            kw["aname"] = "_ImpersonateUserResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ImpersonateUserResponse_Holder"
            self.pyclass = Holder

    class SessionIsActive_Dec(ElementDeclaration):
        literal = "SessionIsActive"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SessionIsActive')
            kw["aname"] = "_SessionIsActive"
            if ns0.SessionIsActiveRequestType_Def not in ns0.SessionIsActive_Dec.__bases__:
                bases = list(ns0.SessionIsActive_Dec.__bases__)
                bases.insert(0, ns0.SessionIsActiveRequestType_Def)
                ns0.SessionIsActive_Dec.__bases__ = tuple(bases)

            ns0.SessionIsActiveRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SessionIsActive_Dec_Holder"

    class SessionIsActiveResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SessionIsActiveResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SessionIsActiveResponse_Dec.schema
            TClist = [ZSI.TC.Boolean(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'SessionIsActiveResponse')
            kw["aname"] = "_SessionIsActiveResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "SessionIsActiveResponse_Holder"
            self.pyclass = Holder

    class CancelTask_Dec(ElementDeclaration):
        literal = "CancelTask"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CancelTask')
            kw["aname"] = "_CancelTask"
            if ns0.CancelTaskRequestType_Def not in ns0.CancelTask_Dec.__bases__:
                bases = list(ns0.CancelTask_Dec.__bases__)
                bases.insert(0, ns0.CancelTaskRequestType_Def)
                ns0.CancelTask_Dec.__bases__ = tuple(bases)

            ns0.CancelTaskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CancelTask_Dec_Holder"

    class CancelTaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CancelTaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CancelTaskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CancelTaskResponse')
            kw["aname"] = "_CancelTaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CancelTaskResponse_Holder"
            self.pyclass = Holder

    class UpdateProgress_Dec(ElementDeclaration):
        literal = "UpdateProgress"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateProgress')
            kw["aname"] = "_UpdateProgress"
            if ns0.UpdateProgressRequestType_Def not in ns0.UpdateProgress_Dec.__bases__:
                bases = list(ns0.UpdateProgress_Dec.__bases__)
                bases.insert(0, ns0.UpdateProgressRequestType_Def)
                ns0.UpdateProgress_Dec.__bases__ = tuple(bases)

            ns0.UpdateProgressRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateProgress_Dec_Holder"

    class UpdateProgressResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateProgressResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateProgressResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateProgressResponse')
            kw["aname"] = "_UpdateProgressResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateProgressResponse_Holder"
            self.pyclass = Holder

    class SetTaskState_Dec(ElementDeclaration):
        literal = "SetTaskState"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetTaskState')
            kw["aname"] = "_SetTaskState"
            if ns0.SetTaskStateRequestType_Def not in ns0.SetTaskState_Dec.__bases__:
                bases = list(ns0.SetTaskState_Dec.__bases__)
                bases.insert(0, ns0.SetTaskStateRequestType_Def)
                ns0.SetTaskState_Dec.__bases__ = tuple(bases)

            ns0.SetTaskStateRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetTaskState_Dec_Holder"

    class SetTaskStateResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetTaskStateResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetTaskStateResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetTaskStateResponse')
            kw["aname"] = "_SetTaskStateResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetTaskStateResponse_Holder"
            self.pyclass = Holder

    class ReadNextTasks_Dec(ElementDeclaration):
        literal = "ReadNextTasks"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReadNextTasks')
            kw["aname"] = "_ReadNextTasks"
            if ns0.ReadNextTasksRequestType_Def not in ns0.ReadNextTasks_Dec.__bases__:
                bases = list(ns0.ReadNextTasks_Dec.__bases__)
                bases.insert(0, ns0.ReadNextTasksRequestType_Def)
                ns0.ReadNextTasks_Dec.__bases__ = tuple(bases)

            ns0.ReadNextTasksRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReadNextTasks_Dec_Holder"

    class ReadNextTasksResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReadNextTasksResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReadNextTasksResponse_Dec.schema
            TClist = [GTD("urn:vim25","TaskInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReadNextTasksResponse')
            kw["aname"] = "_ReadNextTasksResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ReadNextTasksResponse_Holder"
            self.pyclass = Holder

    class ReadPreviousTasks_Dec(ElementDeclaration):
        literal = "ReadPreviousTasks"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReadPreviousTasks')
            kw["aname"] = "_ReadPreviousTasks"
            if ns0.ReadPreviousTasksRequestType_Def not in ns0.ReadPreviousTasks_Dec.__bases__:
                bases = list(ns0.ReadPreviousTasks_Dec.__bases__)
                bases.insert(0, ns0.ReadPreviousTasksRequestType_Def)
                ns0.ReadPreviousTasks_Dec.__bases__ = tuple(bases)

            ns0.ReadPreviousTasksRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReadPreviousTasks_Dec_Holder"

    class ReadPreviousTasksResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReadPreviousTasksResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReadPreviousTasksResponse_Dec.schema
            TClist = [GTD("urn:vim25","TaskInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReadPreviousTasksResponse')
            kw["aname"] = "_ReadPreviousTasksResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ReadPreviousTasksResponse_Holder"
            self.pyclass = Holder

    class CreateCollectorForTasks_Dec(ElementDeclaration):
        literal = "CreateCollectorForTasks"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateCollectorForTasks')
            kw["aname"] = "_CreateCollectorForTasks"
            if ns0.CreateCollectorForTasksRequestType_Def not in ns0.CreateCollectorForTasks_Dec.__bases__:
                bases = list(ns0.CreateCollectorForTasks_Dec.__bases__)
                bases.insert(0, ns0.CreateCollectorForTasksRequestType_Def)
                ns0.CreateCollectorForTasks_Dec.__bases__ = tuple(bases)

            ns0.CreateCollectorForTasksRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateCollectorForTasks_Dec_Holder"

    class CreateCollectorForTasksResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateCollectorForTasksResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateCollectorForTasksResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateCollectorForTasksResponse')
            kw["aname"] = "_CreateCollectorForTasksResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateCollectorForTasksResponse_Holder"
            self.pyclass = Holder

    class CreateTask_Dec(ElementDeclaration):
        literal = "CreateTask"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateTask')
            kw["aname"] = "_CreateTask"
            if ns0.CreateTaskRequestType_Def not in ns0.CreateTask_Dec.__bases__:
                bases = list(ns0.CreateTask_Dec.__bases__)
                bases.insert(0, ns0.CreateTaskRequestType_Def)
                ns0.CreateTask_Dec.__bases__ = tuple(bases)

            ns0.CreateTaskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateTask_Dec_Holder"

    class CreateTaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateTaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateTaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","TaskInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateTaskResponse')
            kw["aname"] = "_CreateTaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateTaskResponse_Holder"
            self.pyclass = Holder

    class RetrieveUserGroups_Dec(ElementDeclaration):
        literal = "RetrieveUserGroups"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveUserGroups')
            kw["aname"] = "_RetrieveUserGroups"
            if ns0.RetrieveUserGroupsRequestType_Def not in ns0.RetrieveUserGroups_Dec.__bases__:
                bases = list(ns0.RetrieveUserGroups_Dec.__bases__)
                bases.insert(0, ns0.RetrieveUserGroupsRequestType_Def)
                ns0.RetrieveUserGroups_Dec.__bases__ = tuple(bases)

            ns0.RetrieveUserGroupsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveUserGroups_Dec_Holder"

    class RetrieveUserGroupsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveUserGroupsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveUserGroupsResponse_Dec.schema
            TClist = [GTD("urn:vim25","UserSearchResult",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveUserGroupsResponse')
            kw["aname"] = "_RetrieveUserGroupsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrieveUserGroupsResponse_Holder"
            self.pyclass = Holder

    class CreateVirtualDisk_Dec(ElementDeclaration):
        literal = "CreateVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateVirtualDisk')
            kw["aname"] = "_CreateVirtualDisk"
            if ns0.CreateVirtualDiskRequestType_Def not in ns0.CreateVirtualDisk_Dec.__bases__:
                bases = list(ns0.CreateVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.CreateVirtualDiskRequestType_Def)
                ns0.CreateVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.CreateVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateVirtualDisk_Dec_Holder"

    class CreateVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateVirtualDiskResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateVirtualDiskResponse')
            kw["aname"] = "_CreateVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class CreateVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "CreateVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateVirtualDisk_Task')
            kw["aname"] = "_CreateVirtualDisk_Task"
            if ns0.CreateVirtualDiskRequestType_Def not in ns0.CreateVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.CreateVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.CreateVirtualDiskRequestType_Def)
                ns0.CreateVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.CreateVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateVirtualDisk_Task_Dec_Holder"

    class CreateVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateVirtualDisk_TaskResponse')
            kw["aname"] = "_CreateVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class DeleteVirtualDisk_Dec(ElementDeclaration):
        literal = "DeleteVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeleteVirtualDisk')
            kw["aname"] = "_DeleteVirtualDisk"
            if ns0.DeleteVirtualDiskRequestType_Def not in ns0.DeleteVirtualDisk_Dec.__bases__:
                bases = list(ns0.DeleteVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.DeleteVirtualDiskRequestType_Def)
                ns0.DeleteVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.DeleteVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeleteVirtualDisk_Dec_Holder"

    class DeleteVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DeleteVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DeleteVirtualDiskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DeleteVirtualDiskResponse')
            kw["aname"] = "_DeleteVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DeleteVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class DeleteVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "DeleteVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeleteVirtualDisk_Task')
            kw["aname"] = "_DeleteVirtualDisk_Task"
            if ns0.DeleteVirtualDiskRequestType_Def not in ns0.DeleteVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.DeleteVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.DeleteVirtualDiskRequestType_Def)
                ns0.DeleteVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.DeleteVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeleteVirtualDisk_Task_Dec_Holder"

    class DeleteVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DeleteVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DeleteVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'DeleteVirtualDisk_TaskResponse')
            kw["aname"] = "_DeleteVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "DeleteVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class MoveVirtualDisk_Dec(ElementDeclaration):
        literal = "MoveVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveVirtualDisk')
            kw["aname"] = "_MoveVirtualDisk"
            if ns0.MoveVirtualDiskRequestType_Def not in ns0.MoveVirtualDisk_Dec.__bases__:
                bases = list(ns0.MoveVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.MoveVirtualDiskRequestType_Def)
                ns0.MoveVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.MoveVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveVirtualDisk_Dec_Holder"

    class MoveVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveVirtualDiskResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'MoveVirtualDiskResponse')
            kw["aname"] = "_MoveVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "MoveVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class MoveVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "MoveVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MoveVirtualDisk_Task')
            kw["aname"] = "_MoveVirtualDisk_Task"
            if ns0.MoveVirtualDiskRequestType_Def not in ns0.MoveVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.MoveVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.MoveVirtualDiskRequestType_Def)
                ns0.MoveVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.MoveVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MoveVirtualDisk_Task_Dec_Holder"

    class MoveVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MoveVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MoveVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'MoveVirtualDisk_TaskResponse')
            kw["aname"] = "_MoveVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "MoveVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class CopyVirtualDisk_Dec(ElementDeclaration):
        literal = "CopyVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CopyVirtualDisk')
            kw["aname"] = "_CopyVirtualDisk"
            if ns0.CopyVirtualDiskRequestType_Def not in ns0.CopyVirtualDisk_Dec.__bases__:
                bases = list(ns0.CopyVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.CopyVirtualDiskRequestType_Def)
                ns0.CopyVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.CopyVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CopyVirtualDisk_Dec_Holder"

    class CopyVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CopyVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CopyVirtualDiskResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CopyVirtualDiskResponse')
            kw["aname"] = "_CopyVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CopyVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class CopyVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "CopyVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CopyVirtualDisk_Task')
            kw["aname"] = "_CopyVirtualDisk_Task"
            if ns0.CopyVirtualDiskRequestType_Def not in ns0.CopyVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.CopyVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.CopyVirtualDiskRequestType_Def)
                ns0.CopyVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.CopyVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CopyVirtualDisk_Task_Dec_Holder"

    class CopyVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CopyVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CopyVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CopyVirtualDisk_TaskResponse')
            kw["aname"] = "_CopyVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CopyVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class ExtendVirtualDisk_Dec(ElementDeclaration):
        literal = "ExtendVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExtendVirtualDisk')
            kw["aname"] = "_ExtendVirtualDisk"
            if ns0.ExtendVirtualDiskRequestType_Def not in ns0.ExtendVirtualDisk_Dec.__bases__:
                bases = list(ns0.ExtendVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.ExtendVirtualDiskRequestType_Def)
                ns0.ExtendVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.ExtendVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExtendVirtualDisk_Dec_Holder"

    class ExtendVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ExtendVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ExtendVirtualDiskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ExtendVirtualDiskResponse')
            kw["aname"] = "_ExtendVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ExtendVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class ExtendVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "ExtendVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExtendVirtualDisk_Task')
            kw["aname"] = "_ExtendVirtualDisk_Task"
            if ns0.ExtendVirtualDiskRequestType_Def not in ns0.ExtendVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.ExtendVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.ExtendVirtualDiskRequestType_Def)
                ns0.ExtendVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.ExtendVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExtendVirtualDisk_Task_Dec_Holder"

    class ExtendVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ExtendVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ExtendVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ExtendVirtualDisk_TaskResponse')
            kw["aname"] = "_ExtendVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ExtendVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class QueryVirtualDiskFragmentation_Dec(ElementDeclaration):
        literal = "QueryVirtualDiskFragmentation"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryVirtualDiskFragmentation')
            kw["aname"] = "_QueryVirtualDiskFragmentation"
            if ns0.QueryVirtualDiskFragmentationRequestType_Def not in ns0.QueryVirtualDiskFragmentation_Dec.__bases__:
                bases = list(ns0.QueryVirtualDiskFragmentation_Dec.__bases__)
                bases.insert(0, ns0.QueryVirtualDiskFragmentationRequestType_Def)
                ns0.QueryVirtualDiskFragmentation_Dec.__bases__ = tuple(bases)

            ns0.QueryVirtualDiskFragmentationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryVirtualDiskFragmentation_Dec_Holder"

    class QueryVirtualDiskFragmentationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryVirtualDiskFragmentationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryVirtualDiskFragmentationResponse_Dec.schema
            TClist = [ZSI.TCnumbers.Iint(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryVirtualDiskFragmentationResponse')
            kw["aname"] = "_QueryVirtualDiskFragmentationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryVirtualDiskFragmentationResponse_Holder"
            self.pyclass = Holder

    class DefragmentVirtualDisk_Dec(ElementDeclaration):
        literal = "DefragmentVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DefragmentVirtualDisk')
            kw["aname"] = "_DefragmentVirtualDisk"
            if ns0.DefragmentVirtualDiskRequestType_Def not in ns0.DefragmentVirtualDisk_Dec.__bases__:
                bases = list(ns0.DefragmentVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.DefragmentVirtualDiskRequestType_Def)
                ns0.DefragmentVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.DefragmentVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DefragmentVirtualDisk_Dec_Holder"

    class DefragmentVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DefragmentVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DefragmentVirtualDiskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DefragmentVirtualDiskResponse')
            kw["aname"] = "_DefragmentVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DefragmentVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class DefragmentVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "DefragmentVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DefragmentVirtualDisk_Task')
            kw["aname"] = "_DefragmentVirtualDisk_Task"
            if ns0.DefragmentVirtualDiskRequestType_Def not in ns0.DefragmentVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.DefragmentVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.DefragmentVirtualDiskRequestType_Def)
                ns0.DefragmentVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.DefragmentVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DefragmentVirtualDisk_Task_Dec_Holder"

    class DefragmentVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DefragmentVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DefragmentVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'DefragmentVirtualDisk_TaskResponse')
            kw["aname"] = "_DefragmentVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "DefragmentVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class ShrinkVirtualDisk_Dec(ElementDeclaration):
        literal = "ShrinkVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ShrinkVirtualDisk')
            kw["aname"] = "_ShrinkVirtualDisk"
            if ns0.ShrinkVirtualDiskRequestType_Def not in ns0.ShrinkVirtualDisk_Dec.__bases__:
                bases = list(ns0.ShrinkVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.ShrinkVirtualDiskRequestType_Def)
                ns0.ShrinkVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.ShrinkVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ShrinkVirtualDisk_Dec_Holder"

    class ShrinkVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ShrinkVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ShrinkVirtualDiskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ShrinkVirtualDiskResponse')
            kw["aname"] = "_ShrinkVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ShrinkVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class ShrinkVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "ShrinkVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ShrinkVirtualDisk_Task')
            kw["aname"] = "_ShrinkVirtualDisk_Task"
            if ns0.ShrinkVirtualDiskRequestType_Def not in ns0.ShrinkVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.ShrinkVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.ShrinkVirtualDiskRequestType_Def)
                ns0.ShrinkVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.ShrinkVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ShrinkVirtualDisk_Task_Dec_Holder"

    class ShrinkVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ShrinkVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ShrinkVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ShrinkVirtualDisk_TaskResponse')
            kw["aname"] = "_ShrinkVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ShrinkVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class InflateVirtualDisk_Dec(ElementDeclaration):
        literal = "InflateVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InflateVirtualDisk')
            kw["aname"] = "_InflateVirtualDisk"
            if ns0.InflateVirtualDiskRequestType_Def not in ns0.InflateVirtualDisk_Dec.__bases__:
                bases = list(ns0.InflateVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.InflateVirtualDiskRequestType_Def)
                ns0.InflateVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.InflateVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InflateVirtualDisk_Dec_Holder"

    class InflateVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "InflateVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.InflateVirtualDiskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'InflateVirtualDiskResponse')
            kw["aname"] = "_InflateVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "InflateVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class InflateVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "InflateVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InflateVirtualDisk_Task')
            kw["aname"] = "_InflateVirtualDisk_Task"
            if ns0.InflateVirtualDiskRequestType_Def not in ns0.InflateVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.InflateVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.InflateVirtualDiskRequestType_Def)
                ns0.InflateVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.InflateVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InflateVirtualDisk_Task_Dec_Holder"

    class InflateVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "InflateVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.InflateVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'InflateVirtualDisk_TaskResponse')
            kw["aname"] = "_InflateVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "InflateVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class ZeroFillVirtualDisk_Dec(ElementDeclaration):
        literal = "ZeroFillVirtualDisk"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ZeroFillVirtualDisk')
            kw["aname"] = "_ZeroFillVirtualDisk"
            if ns0.ZeroFillVirtualDiskRequestType_Def not in ns0.ZeroFillVirtualDisk_Dec.__bases__:
                bases = list(ns0.ZeroFillVirtualDisk_Dec.__bases__)
                bases.insert(0, ns0.ZeroFillVirtualDiskRequestType_Def)
                ns0.ZeroFillVirtualDisk_Dec.__bases__ = tuple(bases)

            ns0.ZeroFillVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ZeroFillVirtualDisk_Dec_Holder"

    class ZeroFillVirtualDiskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ZeroFillVirtualDiskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ZeroFillVirtualDiskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ZeroFillVirtualDiskResponse')
            kw["aname"] = "_ZeroFillVirtualDiskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ZeroFillVirtualDiskResponse_Holder"
            self.pyclass = Holder

    class ZeroFillVirtualDisk_Task_Dec(ElementDeclaration):
        literal = "ZeroFillVirtualDisk_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ZeroFillVirtualDisk_Task')
            kw["aname"] = "_ZeroFillVirtualDisk_Task"
            if ns0.ZeroFillVirtualDiskRequestType_Def not in ns0.ZeroFillVirtualDisk_Task_Dec.__bases__:
                bases = list(ns0.ZeroFillVirtualDisk_Task_Dec.__bases__)
                bases.insert(0, ns0.ZeroFillVirtualDiskRequestType_Def)
                ns0.ZeroFillVirtualDisk_Task_Dec.__bases__ = tuple(bases)

            ns0.ZeroFillVirtualDiskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ZeroFillVirtualDisk_Task_Dec_Holder"

    class ZeroFillVirtualDisk_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ZeroFillVirtualDisk_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ZeroFillVirtualDisk_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ZeroFillVirtualDisk_TaskResponse')
            kw["aname"] = "_ZeroFillVirtualDisk_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ZeroFillVirtualDisk_TaskResponse_Holder"
            self.pyclass = Holder

    class SetVirtualDiskUuid_Dec(ElementDeclaration):
        literal = "SetVirtualDiskUuid"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetVirtualDiskUuid')
            kw["aname"] = "_SetVirtualDiskUuid"
            if ns0.SetVirtualDiskUuidRequestType_Def not in ns0.SetVirtualDiskUuid_Dec.__bases__:
                bases = list(ns0.SetVirtualDiskUuid_Dec.__bases__)
                bases.insert(0, ns0.SetVirtualDiskUuidRequestType_Def)
                ns0.SetVirtualDiskUuid_Dec.__bases__ = tuple(bases)

            ns0.SetVirtualDiskUuidRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetVirtualDiskUuid_Dec_Holder"

    class SetVirtualDiskUuidResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetVirtualDiskUuidResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetVirtualDiskUuidResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetVirtualDiskUuidResponse')
            kw["aname"] = "_SetVirtualDiskUuidResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetVirtualDiskUuidResponse_Holder"
            self.pyclass = Holder

    class QueryVirtualDiskUuid_Dec(ElementDeclaration):
        literal = "QueryVirtualDiskUuid"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryVirtualDiskUuid')
            kw["aname"] = "_QueryVirtualDiskUuid"
            if ns0.QueryVirtualDiskUuidRequestType_Def not in ns0.QueryVirtualDiskUuid_Dec.__bases__:
                bases = list(ns0.QueryVirtualDiskUuid_Dec.__bases__)
                bases.insert(0, ns0.QueryVirtualDiskUuidRequestType_Def)
                ns0.QueryVirtualDiskUuid_Dec.__bases__ = tuple(bases)

            ns0.QueryVirtualDiskUuidRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryVirtualDiskUuid_Dec_Holder"

    class QueryVirtualDiskUuidResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryVirtualDiskUuidResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryVirtualDiskUuidResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryVirtualDiskUuidResponse')
            kw["aname"] = "_QueryVirtualDiskUuidResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryVirtualDiskUuidResponse_Holder"
            self.pyclass = Holder

    class QueryVirtualDiskGeometry_Dec(ElementDeclaration):
        literal = "QueryVirtualDiskGeometry"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryVirtualDiskGeometry')
            kw["aname"] = "_QueryVirtualDiskGeometry"
            if ns0.QueryVirtualDiskGeometryRequestType_Def not in ns0.QueryVirtualDiskGeometry_Dec.__bases__:
                bases = list(ns0.QueryVirtualDiskGeometry_Dec.__bases__)
                bases.insert(0, ns0.QueryVirtualDiskGeometryRequestType_Def)
                ns0.QueryVirtualDiskGeometry_Dec.__bases__ = tuple(bases)

            ns0.QueryVirtualDiskGeometryRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryVirtualDiskGeometry_Dec_Holder"

    class QueryVirtualDiskGeometryResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryVirtualDiskGeometryResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryVirtualDiskGeometryResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDiskDimensionsChs",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryVirtualDiskGeometryResponse')
            kw["aname"] = "_QueryVirtualDiskGeometryResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryVirtualDiskGeometryResponse_Holder"
            self.pyclass = Holder

    class CreateSnapshot_Dec(ElementDeclaration):
        literal = "CreateSnapshot"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateSnapshot')
            kw["aname"] = "_CreateSnapshot"
            if ns0.CreateSnapshotRequestType_Def not in ns0.CreateSnapshot_Dec.__bases__:
                bases = list(ns0.CreateSnapshot_Dec.__bases__)
                bases.insert(0, ns0.CreateSnapshotRequestType_Def)
                ns0.CreateSnapshot_Dec.__bases__ = tuple(bases)

            ns0.CreateSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateSnapshot_Dec_Holder"

    class CreateSnapshotResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateSnapshotResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateSnapshotResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateSnapshotResponse')
            kw["aname"] = "_CreateSnapshotResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateSnapshotResponse_Holder"
            self.pyclass = Holder

    class CreateSnapshot_Task_Dec(ElementDeclaration):
        literal = "CreateSnapshot_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateSnapshot_Task')
            kw["aname"] = "_CreateSnapshot_Task"
            if ns0.CreateSnapshotRequestType_Def not in ns0.CreateSnapshot_Task_Dec.__bases__:
                bases = list(ns0.CreateSnapshot_Task_Dec.__bases__)
                bases.insert(0, ns0.CreateSnapshotRequestType_Def)
                ns0.CreateSnapshot_Task_Dec.__bases__ = tuple(bases)

            ns0.CreateSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateSnapshot_Task_Dec_Holder"

    class CreateSnapshot_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateSnapshot_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateSnapshot_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateSnapshot_TaskResponse')
            kw["aname"] = "_CreateSnapshot_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateSnapshot_TaskResponse_Holder"
            self.pyclass = Holder

    class RevertToCurrentSnapshot_Dec(ElementDeclaration):
        literal = "RevertToCurrentSnapshot"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RevertToCurrentSnapshot')
            kw["aname"] = "_RevertToCurrentSnapshot"
            if ns0.RevertToCurrentSnapshotRequestType_Def not in ns0.RevertToCurrentSnapshot_Dec.__bases__:
                bases = list(ns0.RevertToCurrentSnapshot_Dec.__bases__)
                bases.insert(0, ns0.RevertToCurrentSnapshotRequestType_Def)
                ns0.RevertToCurrentSnapshot_Dec.__bases__ = tuple(bases)

            ns0.RevertToCurrentSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RevertToCurrentSnapshot_Dec_Holder"

    class RevertToCurrentSnapshotResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RevertToCurrentSnapshotResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RevertToCurrentSnapshotResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RevertToCurrentSnapshotResponse')
            kw["aname"] = "_RevertToCurrentSnapshotResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RevertToCurrentSnapshotResponse_Holder"
            self.pyclass = Holder

    class RevertToCurrentSnapshot_Task_Dec(ElementDeclaration):
        literal = "RevertToCurrentSnapshot_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RevertToCurrentSnapshot_Task')
            kw["aname"] = "_RevertToCurrentSnapshot_Task"
            if ns0.RevertToCurrentSnapshotRequestType_Def not in ns0.RevertToCurrentSnapshot_Task_Dec.__bases__:
                bases = list(ns0.RevertToCurrentSnapshot_Task_Dec.__bases__)
                bases.insert(0, ns0.RevertToCurrentSnapshotRequestType_Def)
                ns0.RevertToCurrentSnapshot_Task_Dec.__bases__ = tuple(bases)

            ns0.RevertToCurrentSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RevertToCurrentSnapshot_Task_Dec_Holder"

    class RevertToCurrentSnapshot_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RevertToCurrentSnapshot_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RevertToCurrentSnapshot_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RevertToCurrentSnapshot_TaskResponse')
            kw["aname"] = "_RevertToCurrentSnapshot_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RevertToCurrentSnapshot_TaskResponse_Holder"
            self.pyclass = Holder

    class RemoveAllSnapshots_Dec(ElementDeclaration):
        literal = "RemoveAllSnapshots"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveAllSnapshots')
            kw["aname"] = "_RemoveAllSnapshots"
            if ns0.RemoveAllSnapshotsRequestType_Def not in ns0.RemoveAllSnapshots_Dec.__bases__:
                bases = list(ns0.RemoveAllSnapshots_Dec.__bases__)
                bases.insert(0, ns0.RemoveAllSnapshotsRequestType_Def)
                ns0.RemoveAllSnapshots_Dec.__bases__ = tuple(bases)

            ns0.RemoveAllSnapshotsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveAllSnapshots_Dec_Holder"

    class RemoveAllSnapshotsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveAllSnapshotsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveAllSnapshotsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveAllSnapshotsResponse')
            kw["aname"] = "_RemoveAllSnapshotsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveAllSnapshotsResponse_Holder"
            self.pyclass = Holder

    class RemoveAllSnapshots_Task_Dec(ElementDeclaration):
        literal = "RemoveAllSnapshots_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveAllSnapshots_Task')
            kw["aname"] = "_RemoveAllSnapshots_Task"
            if ns0.RemoveAllSnapshotsRequestType_Def not in ns0.RemoveAllSnapshots_Task_Dec.__bases__:
                bases = list(ns0.RemoveAllSnapshots_Task_Dec.__bases__)
                bases.insert(0, ns0.RemoveAllSnapshotsRequestType_Def)
                ns0.RemoveAllSnapshots_Task_Dec.__bases__ = tuple(bases)

            ns0.RemoveAllSnapshotsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveAllSnapshots_Task_Dec_Holder"

    class RemoveAllSnapshots_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveAllSnapshots_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveAllSnapshots_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RemoveAllSnapshots_TaskResponse')
            kw["aname"] = "_RemoveAllSnapshots_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RemoveAllSnapshots_TaskResponse_Holder"
            self.pyclass = Holder

    class ReconfigVM_Dec(ElementDeclaration):
        literal = "ReconfigVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigVM')
            kw["aname"] = "_ReconfigVM"
            if ns0.ReconfigVMRequestType_Def not in ns0.ReconfigVM_Dec.__bases__:
                bases = list(ns0.ReconfigVM_Dec.__bases__)
                bases.insert(0, ns0.ReconfigVMRequestType_Def)
                ns0.ReconfigVM_Dec.__bases__ = tuple(bases)

            ns0.ReconfigVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigVM_Dec_Holder"

    class ReconfigVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigVMResponse')
            kw["aname"] = "_ReconfigVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigVMResponse_Holder"
            self.pyclass = Holder

    class ReconfigVM_Task_Dec(ElementDeclaration):
        literal = "ReconfigVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigVM_Task')
            kw["aname"] = "_ReconfigVM_Task"
            if ns0.ReconfigVMRequestType_Def not in ns0.ReconfigVM_Task_Dec.__bases__:
                bases = list(ns0.ReconfigVM_Task_Dec.__bases__)
                bases.insert(0, ns0.ReconfigVMRequestType_Def)
                ns0.ReconfigVM_Task_Dec.__bases__ = tuple(bases)

            ns0.ReconfigVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigVM_Task_Dec_Holder"

    class ReconfigVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReconfigVM_TaskResponse')
            kw["aname"] = "_ReconfigVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ReconfigVM_TaskResponse_Holder"
            self.pyclass = Holder

    class UpgradeVM_Dec(ElementDeclaration):
        literal = "UpgradeVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpgradeVM')
            kw["aname"] = "_UpgradeVM"
            if ns0.UpgradeVMRequestType_Def not in ns0.UpgradeVM_Dec.__bases__:
                bases = list(ns0.UpgradeVM_Dec.__bases__)
                bases.insert(0, ns0.UpgradeVMRequestType_Def)
                ns0.UpgradeVM_Dec.__bases__ = tuple(bases)

            ns0.UpgradeVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpgradeVM_Dec_Holder"

    class UpgradeVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpgradeVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpgradeVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpgradeVMResponse')
            kw["aname"] = "_UpgradeVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpgradeVMResponse_Holder"
            self.pyclass = Holder

    class UpgradeVM_Task_Dec(ElementDeclaration):
        literal = "UpgradeVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpgradeVM_Task')
            kw["aname"] = "_UpgradeVM_Task"
            if ns0.UpgradeVMRequestType_Def not in ns0.UpgradeVM_Task_Dec.__bases__:
                bases = list(ns0.UpgradeVM_Task_Dec.__bases__)
                bases.insert(0, ns0.UpgradeVMRequestType_Def)
                ns0.UpgradeVM_Task_Dec.__bases__ = tuple(bases)

            ns0.UpgradeVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpgradeVM_Task_Dec_Holder"

    class UpgradeVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpgradeVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpgradeVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'UpgradeVM_TaskResponse')
            kw["aname"] = "_UpgradeVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "UpgradeVM_TaskResponse_Holder"
            self.pyclass = Holder

    class PowerOnVM_Dec(ElementDeclaration):
        literal = "PowerOnVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerOnVM')
            kw["aname"] = "_PowerOnVM"
            if ns0.PowerOnVMRequestType_Def not in ns0.PowerOnVM_Dec.__bases__:
                bases = list(ns0.PowerOnVM_Dec.__bases__)
                bases.insert(0, ns0.PowerOnVMRequestType_Def)
                ns0.PowerOnVM_Dec.__bases__ = tuple(bases)

            ns0.PowerOnVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerOnVM_Dec_Holder"

    class PowerOnVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerOnVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerOnVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'PowerOnVMResponse')
            kw["aname"] = "_PowerOnVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "PowerOnVMResponse_Holder"
            self.pyclass = Holder

    class PowerOnVM_Task_Dec(ElementDeclaration):
        literal = "PowerOnVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerOnVM_Task')
            kw["aname"] = "_PowerOnVM_Task"
            if ns0.PowerOnVMRequestType_Def not in ns0.PowerOnVM_Task_Dec.__bases__:
                bases = list(ns0.PowerOnVM_Task_Dec.__bases__)
                bases.insert(0, ns0.PowerOnVMRequestType_Def)
                ns0.PowerOnVM_Task_Dec.__bases__ = tuple(bases)

            ns0.PowerOnVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerOnVM_Task_Dec_Holder"

    class PowerOnVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerOnVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerOnVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'PowerOnVM_TaskResponse')
            kw["aname"] = "_PowerOnVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "PowerOnVM_TaskResponse_Holder"
            self.pyclass = Holder

    class PowerOffVM_Dec(ElementDeclaration):
        literal = "PowerOffVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerOffVM')
            kw["aname"] = "_PowerOffVM"
            if ns0.PowerOffVMRequestType_Def not in ns0.PowerOffVM_Dec.__bases__:
                bases = list(ns0.PowerOffVM_Dec.__bases__)
                bases.insert(0, ns0.PowerOffVMRequestType_Def)
                ns0.PowerOffVM_Dec.__bases__ = tuple(bases)

            ns0.PowerOffVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerOffVM_Dec_Holder"

    class PowerOffVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerOffVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerOffVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'PowerOffVMResponse')
            kw["aname"] = "_PowerOffVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "PowerOffVMResponse_Holder"
            self.pyclass = Holder

    class PowerOffVM_Task_Dec(ElementDeclaration):
        literal = "PowerOffVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PowerOffVM_Task')
            kw["aname"] = "_PowerOffVM_Task"
            if ns0.PowerOffVMRequestType_Def not in ns0.PowerOffVM_Task_Dec.__bases__:
                bases = list(ns0.PowerOffVM_Task_Dec.__bases__)
                bases.insert(0, ns0.PowerOffVMRequestType_Def)
                ns0.PowerOffVM_Task_Dec.__bases__ = tuple(bases)

            ns0.PowerOffVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PowerOffVM_Task_Dec_Holder"

    class PowerOffVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PowerOffVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PowerOffVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'PowerOffVM_TaskResponse')
            kw["aname"] = "_PowerOffVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "PowerOffVM_TaskResponse_Holder"
            self.pyclass = Holder

    class SuspendVM_Dec(ElementDeclaration):
        literal = "SuspendVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SuspendVM')
            kw["aname"] = "_SuspendVM"
            if ns0.SuspendVMRequestType_Def not in ns0.SuspendVM_Dec.__bases__:
                bases = list(ns0.SuspendVM_Dec.__bases__)
                bases.insert(0, ns0.SuspendVMRequestType_Def)
                ns0.SuspendVM_Dec.__bases__ = tuple(bases)

            ns0.SuspendVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SuspendVM_Dec_Holder"

    class SuspendVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SuspendVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SuspendVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SuspendVMResponse')
            kw["aname"] = "_SuspendVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SuspendVMResponse_Holder"
            self.pyclass = Holder

    class SuspendVM_Task_Dec(ElementDeclaration):
        literal = "SuspendVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SuspendVM_Task')
            kw["aname"] = "_SuspendVM_Task"
            if ns0.SuspendVMRequestType_Def not in ns0.SuspendVM_Task_Dec.__bases__:
                bases = list(ns0.SuspendVM_Task_Dec.__bases__)
                bases.insert(0, ns0.SuspendVMRequestType_Def)
                ns0.SuspendVM_Task_Dec.__bases__ = tuple(bases)

            ns0.SuspendVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SuspendVM_Task_Dec_Holder"

    class SuspendVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SuspendVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SuspendVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'SuspendVM_TaskResponse')
            kw["aname"] = "_SuspendVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "SuspendVM_TaskResponse_Holder"
            self.pyclass = Holder

    class ResetVM_Dec(ElementDeclaration):
        literal = "ResetVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetVM')
            kw["aname"] = "_ResetVM"
            if ns0.ResetVMRequestType_Def not in ns0.ResetVM_Dec.__bases__:
                bases = list(ns0.ResetVM_Dec.__bases__)
                bases.insert(0, ns0.ResetVMRequestType_Def)
                ns0.ResetVM_Dec.__bases__ = tuple(bases)

            ns0.ResetVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetVM_Dec_Holder"

    class ResetVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ResetVMResponse')
            kw["aname"] = "_ResetVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ResetVMResponse_Holder"
            self.pyclass = Holder

    class ResetVM_Task_Dec(ElementDeclaration):
        literal = "ResetVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetVM_Task')
            kw["aname"] = "_ResetVM_Task"
            if ns0.ResetVMRequestType_Def not in ns0.ResetVM_Task_Dec.__bases__:
                bases = list(ns0.ResetVM_Task_Dec.__bases__)
                bases.insert(0, ns0.ResetVMRequestType_Def)
                ns0.ResetVM_Task_Dec.__bases__ = tuple(bases)

            ns0.ResetVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetVM_Task_Dec_Holder"

    class ResetVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ResetVM_TaskResponse')
            kw["aname"] = "_ResetVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ResetVM_TaskResponse_Holder"
            self.pyclass = Holder

    class ShutdownGuest_Dec(ElementDeclaration):
        literal = "ShutdownGuest"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ShutdownGuest')
            kw["aname"] = "_ShutdownGuest"
            if ns0.ShutdownGuestRequestType_Def not in ns0.ShutdownGuest_Dec.__bases__:
                bases = list(ns0.ShutdownGuest_Dec.__bases__)
                bases.insert(0, ns0.ShutdownGuestRequestType_Def)
                ns0.ShutdownGuest_Dec.__bases__ = tuple(bases)

            ns0.ShutdownGuestRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ShutdownGuest_Dec_Holder"

    class ShutdownGuestResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ShutdownGuestResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ShutdownGuestResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ShutdownGuestResponse')
            kw["aname"] = "_ShutdownGuestResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ShutdownGuestResponse_Holder"
            self.pyclass = Holder

    class RebootGuest_Dec(ElementDeclaration):
        literal = "RebootGuest"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RebootGuest')
            kw["aname"] = "_RebootGuest"
            if ns0.RebootGuestRequestType_Def not in ns0.RebootGuest_Dec.__bases__:
                bases = list(ns0.RebootGuest_Dec.__bases__)
                bases.insert(0, ns0.RebootGuestRequestType_Def)
                ns0.RebootGuest_Dec.__bases__ = tuple(bases)

            ns0.RebootGuestRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RebootGuest_Dec_Holder"

    class RebootGuestResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RebootGuestResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RebootGuestResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RebootGuestResponse')
            kw["aname"] = "_RebootGuestResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RebootGuestResponse_Holder"
            self.pyclass = Holder

    class StandbyGuest_Dec(ElementDeclaration):
        literal = "StandbyGuest"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'StandbyGuest')
            kw["aname"] = "_StandbyGuest"
            if ns0.StandbyGuestRequestType_Def not in ns0.StandbyGuest_Dec.__bases__:
                bases = list(ns0.StandbyGuest_Dec.__bases__)
                bases.insert(0, ns0.StandbyGuestRequestType_Def)
                ns0.StandbyGuest_Dec.__bases__ = tuple(bases)

            ns0.StandbyGuestRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "StandbyGuest_Dec_Holder"

    class StandbyGuestResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "StandbyGuestResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.StandbyGuestResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'StandbyGuestResponse')
            kw["aname"] = "_StandbyGuestResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "StandbyGuestResponse_Holder"
            self.pyclass = Holder

    class AnswerVM_Dec(ElementDeclaration):
        literal = "AnswerVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AnswerVM')
            kw["aname"] = "_AnswerVM"
            if ns0.AnswerVMRequestType_Def not in ns0.AnswerVM_Dec.__bases__:
                bases = list(ns0.AnswerVM_Dec.__bases__)
                bases.insert(0, ns0.AnswerVMRequestType_Def)
                ns0.AnswerVM_Dec.__bases__ = tuple(bases)

            ns0.AnswerVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AnswerVM_Dec_Holder"

    class AnswerVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AnswerVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AnswerVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AnswerVMResponse')
            kw["aname"] = "_AnswerVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AnswerVMResponse_Holder"
            self.pyclass = Holder

    class CustomizeVM_Dec(ElementDeclaration):
        literal = "CustomizeVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CustomizeVM')
            kw["aname"] = "_CustomizeVM"
            if ns0.CustomizeVMRequestType_Def not in ns0.CustomizeVM_Dec.__bases__:
                bases = list(ns0.CustomizeVM_Dec.__bases__)
                bases.insert(0, ns0.CustomizeVMRequestType_Def)
                ns0.CustomizeVM_Dec.__bases__ = tuple(bases)

            ns0.CustomizeVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CustomizeVM_Dec_Holder"

    class CustomizeVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CustomizeVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CustomizeVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CustomizeVMResponse')
            kw["aname"] = "_CustomizeVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CustomizeVMResponse_Holder"
            self.pyclass = Holder

    class CustomizeVM_Task_Dec(ElementDeclaration):
        literal = "CustomizeVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CustomizeVM_Task')
            kw["aname"] = "_CustomizeVM_Task"
            if ns0.CustomizeVMRequestType_Def not in ns0.CustomizeVM_Task_Dec.__bases__:
                bases = list(ns0.CustomizeVM_Task_Dec.__bases__)
                bases.insert(0, ns0.CustomizeVMRequestType_Def)
                ns0.CustomizeVM_Task_Dec.__bases__ = tuple(bases)

            ns0.CustomizeVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CustomizeVM_Task_Dec_Holder"

    class CustomizeVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CustomizeVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CustomizeVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CustomizeVM_TaskResponse')
            kw["aname"] = "_CustomizeVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CustomizeVM_TaskResponse_Holder"
            self.pyclass = Holder

    class CheckCustomizationSpec_Dec(ElementDeclaration):
        literal = "CheckCustomizationSpec"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CheckCustomizationSpec')
            kw["aname"] = "_CheckCustomizationSpec"
            if ns0.CheckCustomizationSpecRequestType_Def not in ns0.CheckCustomizationSpec_Dec.__bases__:
                bases = list(ns0.CheckCustomizationSpec_Dec.__bases__)
                bases.insert(0, ns0.CheckCustomizationSpecRequestType_Def)
                ns0.CheckCustomizationSpec_Dec.__bases__ = tuple(bases)

            ns0.CheckCustomizationSpecRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CheckCustomizationSpec_Dec_Holder"

    class CheckCustomizationSpecResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CheckCustomizationSpecResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CheckCustomizationSpecResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CheckCustomizationSpecResponse')
            kw["aname"] = "_CheckCustomizationSpecResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CheckCustomizationSpecResponse_Holder"
            self.pyclass = Holder

    class MigrateVM_Dec(ElementDeclaration):
        literal = "MigrateVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MigrateVM')
            kw["aname"] = "_MigrateVM"
            if ns0.MigrateVMRequestType_Def not in ns0.MigrateVM_Dec.__bases__:
                bases = list(ns0.MigrateVM_Dec.__bases__)
                bases.insert(0, ns0.MigrateVMRequestType_Def)
                ns0.MigrateVM_Dec.__bases__ = tuple(bases)

            ns0.MigrateVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MigrateVM_Dec_Holder"

    class MigrateVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MigrateVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MigrateVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MigrateVMResponse')
            kw["aname"] = "_MigrateVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MigrateVMResponse_Holder"
            self.pyclass = Holder

    class MigrateVM_Task_Dec(ElementDeclaration):
        literal = "MigrateVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MigrateVM_Task')
            kw["aname"] = "_MigrateVM_Task"
            if ns0.MigrateVMRequestType_Def not in ns0.MigrateVM_Task_Dec.__bases__:
                bases = list(ns0.MigrateVM_Task_Dec.__bases__)
                bases.insert(0, ns0.MigrateVMRequestType_Def)
                ns0.MigrateVM_Task_Dec.__bases__ = tuple(bases)

            ns0.MigrateVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MigrateVM_Task_Dec_Holder"

    class MigrateVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MigrateVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MigrateVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'MigrateVM_TaskResponse')
            kw["aname"] = "_MigrateVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "MigrateVM_TaskResponse_Holder"
            self.pyclass = Holder

    class RelocateVM_Dec(ElementDeclaration):
        literal = "RelocateVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RelocateVM')
            kw["aname"] = "_RelocateVM"
            if ns0.RelocateVMRequestType_Def not in ns0.RelocateVM_Dec.__bases__:
                bases = list(ns0.RelocateVM_Dec.__bases__)
                bases.insert(0, ns0.RelocateVMRequestType_Def)
                ns0.RelocateVM_Dec.__bases__ = tuple(bases)

            ns0.RelocateVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RelocateVM_Dec_Holder"

    class RelocateVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RelocateVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RelocateVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RelocateVMResponse')
            kw["aname"] = "_RelocateVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RelocateVMResponse_Holder"
            self.pyclass = Holder

    class RelocateVM_Task_Dec(ElementDeclaration):
        literal = "RelocateVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RelocateVM_Task')
            kw["aname"] = "_RelocateVM_Task"
            if ns0.RelocateVMRequestType_Def not in ns0.RelocateVM_Task_Dec.__bases__:
                bases = list(ns0.RelocateVM_Task_Dec.__bases__)
                bases.insert(0, ns0.RelocateVMRequestType_Def)
                ns0.RelocateVM_Task_Dec.__bases__ = tuple(bases)

            ns0.RelocateVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RelocateVM_Task_Dec_Holder"

    class RelocateVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RelocateVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RelocateVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RelocateVM_TaskResponse')
            kw["aname"] = "_RelocateVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RelocateVM_TaskResponse_Holder"
            self.pyclass = Holder

    class CloneVM_Dec(ElementDeclaration):
        literal = "CloneVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CloneVM')
            kw["aname"] = "_CloneVM"
            if ns0.CloneVMRequestType_Def not in ns0.CloneVM_Dec.__bases__:
                bases = list(ns0.CloneVM_Dec.__bases__)
                bases.insert(0, ns0.CloneVMRequestType_Def)
                ns0.CloneVM_Dec.__bases__ = tuple(bases)

            ns0.CloneVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CloneVM_Dec_Holder"

    class CloneVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CloneVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CloneVMResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CloneVMResponse')
            kw["aname"] = "_CloneVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CloneVMResponse_Holder"
            self.pyclass = Holder

    class CloneVM_Task_Dec(ElementDeclaration):
        literal = "CloneVM_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CloneVM_Task')
            kw["aname"] = "_CloneVM_Task"
            if ns0.CloneVMRequestType_Def not in ns0.CloneVM_Task_Dec.__bases__:
                bases = list(ns0.CloneVM_Task_Dec.__bases__)
                bases.insert(0, ns0.CloneVMRequestType_Def)
                ns0.CloneVM_Task_Dec.__bases__ = tuple(bases)

            ns0.CloneVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CloneVM_Task_Dec_Holder"

    class CloneVM_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CloneVM_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CloneVM_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CloneVM_TaskResponse')
            kw["aname"] = "_CloneVM_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CloneVM_TaskResponse_Holder"
            self.pyclass = Holder

    class MarkAsTemplate_Dec(ElementDeclaration):
        literal = "MarkAsTemplate"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MarkAsTemplate')
            kw["aname"] = "_MarkAsTemplate"
            if ns0.MarkAsTemplateRequestType_Def not in ns0.MarkAsTemplate_Dec.__bases__:
                bases = list(ns0.MarkAsTemplate_Dec.__bases__)
                bases.insert(0, ns0.MarkAsTemplateRequestType_Def)
                ns0.MarkAsTemplate_Dec.__bases__ = tuple(bases)

            ns0.MarkAsTemplateRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MarkAsTemplate_Dec_Holder"

    class MarkAsTemplateResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MarkAsTemplateResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MarkAsTemplateResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MarkAsTemplateResponse')
            kw["aname"] = "_MarkAsTemplateResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MarkAsTemplateResponse_Holder"
            self.pyclass = Holder

    class MarkAsVirtualMachine_Dec(ElementDeclaration):
        literal = "MarkAsVirtualMachine"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MarkAsVirtualMachine')
            kw["aname"] = "_MarkAsVirtualMachine"
            if ns0.MarkAsVirtualMachineRequestType_Def not in ns0.MarkAsVirtualMachine_Dec.__bases__:
                bases = list(ns0.MarkAsVirtualMachine_Dec.__bases__)
                bases.insert(0, ns0.MarkAsVirtualMachineRequestType_Def)
                ns0.MarkAsVirtualMachine_Dec.__bases__ = tuple(bases)

            ns0.MarkAsVirtualMachineRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MarkAsVirtualMachine_Dec_Holder"

    class MarkAsVirtualMachineResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MarkAsVirtualMachineResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MarkAsVirtualMachineResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MarkAsVirtualMachineResponse')
            kw["aname"] = "_MarkAsVirtualMachineResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MarkAsVirtualMachineResponse_Holder"
            self.pyclass = Holder

    class UnregisterVM_Dec(ElementDeclaration):
        literal = "UnregisterVM"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnregisterVM')
            kw["aname"] = "_UnregisterVM"
            if ns0.UnregisterVMRequestType_Def not in ns0.UnregisterVM_Dec.__bases__:
                bases = list(ns0.UnregisterVM_Dec.__bases__)
                bases.insert(0, ns0.UnregisterVMRequestType_Def)
                ns0.UnregisterVM_Dec.__bases__ = tuple(bases)

            ns0.UnregisterVMRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnregisterVM_Dec_Holder"

    class UnregisterVMResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UnregisterVMResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UnregisterVMResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UnregisterVMResponse')
            kw["aname"] = "_UnregisterVMResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UnregisterVMResponse_Holder"
            self.pyclass = Holder

    class ResetGuestInformation_Dec(ElementDeclaration):
        literal = "ResetGuestInformation"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetGuestInformation')
            kw["aname"] = "_ResetGuestInformation"
            if ns0.ResetGuestInformationRequestType_Def not in ns0.ResetGuestInformation_Dec.__bases__:
                bases = list(ns0.ResetGuestInformation_Dec.__bases__)
                bases.insert(0, ns0.ResetGuestInformationRequestType_Def)
                ns0.ResetGuestInformation_Dec.__bases__ = tuple(bases)

            ns0.ResetGuestInformationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetGuestInformation_Dec_Holder"

    class ResetGuestInformationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetGuestInformationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetGuestInformationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ResetGuestInformationResponse')
            kw["aname"] = "_ResetGuestInformationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ResetGuestInformationResponse_Holder"
            self.pyclass = Holder

    class MountToolsInstaller_Dec(ElementDeclaration):
        literal = "MountToolsInstaller"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MountToolsInstaller')
            kw["aname"] = "_MountToolsInstaller"
            if ns0.MountToolsInstallerRequestType_Def not in ns0.MountToolsInstaller_Dec.__bases__:
                bases = list(ns0.MountToolsInstaller_Dec.__bases__)
                bases.insert(0, ns0.MountToolsInstallerRequestType_Def)
                ns0.MountToolsInstaller_Dec.__bases__ = tuple(bases)

            ns0.MountToolsInstallerRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MountToolsInstaller_Dec_Holder"

    class MountToolsInstallerResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "MountToolsInstallerResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.MountToolsInstallerResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'MountToolsInstallerResponse')
            kw["aname"] = "_MountToolsInstallerResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "MountToolsInstallerResponse_Holder"
            self.pyclass = Holder

    class UnmountToolsInstaller_Dec(ElementDeclaration):
        literal = "UnmountToolsInstaller"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnmountToolsInstaller')
            kw["aname"] = "_UnmountToolsInstaller"
            if ns0.UnmountToolsInstallerRequestType_Def not in ns0.UnmountToolsInstaller_Dec.__bases__:
                bases = list(ns0.UnmountToolsInstaller_Dec.__bases__)
                bases.insert(0, ns0.UnmountToolsInstallerRequestType_Def)
                ns0.UnmountToolsInstaller_Dec.__bases__ = tuple(bases)

            ns0.UnmountToolsInstallerRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnmountToolsInstaller_Dec_Holder"

    class UnmountToolsInstallerResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UnmountToolsInstallerResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UnmountToolsInstallerResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UnmountToolsInstallerResponse')
            kw["aname"] = "_UnmountToolsInstallerResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UnmountToolsInstallerResponse_Holder"
            self.pyclass = Holder

    class UpgradeTools_Dec(ElementDeclaration):
        literal = "UpgradeTools"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpgradeTools')
            kw["aname"] = "_UpgradeTools"
            if ns0.UpgradeToolsRequestType_Def not in ns0.UpgradeTools_Dec.__bases__:
                bases = list(ns0.UpgradeTools_Dec.__bases__)
                bases.insert(0, ns0.UpgradeToolsRequestType_Def)
                ns0.UpgradeTools_Dec.__bases__ = tuple(bases)

            ns0.UpgradeToolsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpgradeTools_Dec_Holder"

    class UpgradeToolsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpgradeToolsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpgradeToolsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpgradeToolsResponse')
            kw["aname"] = "_UpgradeToolsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpgradeToolsResponse_Holder"
            self.pyclass = Holder

    class UpgradeTools_Task_Dec(ElementDeclaration):
        literal = "UpgradeTools_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpgradeTools_Task')
            kw["aname"] = "_UpgradeTools_Task"
            if ns0.UpgradeToolsRequestType_Def not in ns0.UpgradeTools_Task_Dec.__bases__:
                bases = list(ns0.UpgradeTools_Task_Dec.__bases__)
                bases.insert(0, ns0.UpgradeToolsRequestType_Def)
                ns0.UpgradeTools_Task_Dec.__bases__ = tuple(bases)

            ns0.UpgradeToolsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpgradeTools_Task_Dec_Holder"

    class UpgradeTools_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpgradeTools_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpgradeTools_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'UpgradeTools_TaskResponse')
            kw["aname"] = "_UpgradeTools_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "UpgradeTools_TaskResponse_Holder"
            self.pyclass = Holder

    class AcquireMksTicket_Dec(ElementDeclaration):
        literal = "AcquireMksTicket"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AcquireMksTicket')
            kw["aname"] = "_AcquireMksTicket"
            if ns0.AcquireMksTicketRequestType_Def not in ns0.AcquireMksTicket_Dec.__bases__:
                bases = list(ns0.AcquireMksTicket_Dec.__bases__)
                bases.insert(0, ns0.AcquireMksTicketRequestType_Def)
                ns0.AcquireMksTicket_Dec.__bases__ = tuple(bases)

            ns0.AcquireMksTicketRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AcquireMksTicket_Dec_Holder"

    class AcquireMksTicketResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AcquireMksTicketResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AcquireMksTicketResponse_Dec.schema
            TClist = [GTD("urn:vim25","VirtualMachineMksTicket",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AcquireMksTicketResponse')
            kw["aname"] = "_AcquireMksTicketResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AcquireMksTicketResponse_Holder"
            self.pyclass = Holder

    class SetScreenResolution_Dec(ElementDeclaration):
        literal = "SetScreenResolution"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetScreenResolution')
            kw["aname"] = "_SetScreenResolution"
            if ns0.SetScreenResolutionRequestType_Def not in ns0.SetScreenResolution_Dec.__bases__:
                bases = list(ns0.SetScreenResolution_Dec.__bases__)
                bases.insert(0, ns0.SetScreenResolutionRequestType_Def)
                ns0.SetScreenResolution_Dec.__bases__ = tuple(bases)

            ns0.SetScreenResolutionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetScreenResolution_Dec_Holder"

    class SetScreenResolutionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetScreenResolutionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetScreenResolutionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetScreenResolutionResponse')
            kw["aname"] = "_SetScreenResolutionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetScreenResolutionResponse_Holder"
            self.pyclass = Holder

    class DefragmentAllDisks_Dec(ElementDeclaration):
        literal = "DefragmentAllDisks"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DefragmentAllDisks')
            kw["aname"] = "_DefragmentAllDisks"
            if ns0.DefragmentAllDisksRequestType_Def not in ns0.DefragmentAllDisks_Dec.__bases__:
                bases = list(ns0.DefragmentAllDisks_Dec.__bases__)
                bases.insert(0, ns0.DefragmentAllDisksRequestType_Def)
                ns0.DefragmentAllDisks_Dec.__bases__ = tuple(bases)

            ns0.DefragmentAllDisksRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DefragmentAllDisks_Dec_Holder"

    class DefragmentAllDisksResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DefragmentAllDisksResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DefragmentAllDisksResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DefragmentAllDisksResponse')
            kw["aname"] = "_DefragmentAllDisksResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DefragmentAllDisksResponse_Holder"
            self.pyclass = Holder

    class RemoveAlarm_Dec(ElementDeclaration):
        literal = "RemoveAlarm"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveAlarm')
            kw["aname"] = "_RemoveAlarm"
            if ns0.RemoveAlarmRequestType_Def not in ns0.RemoveAlarm_Dec.__bases__:
                bases = list(ns0.RemoveAlarm_Dec.__bases__)
                bases.insert(0, ns0.RemoveAlarmRequestType_Def)
                ns0.RemoveAlarm_Dec.__bases__ = tuple(bases)

            ns0.RemoveAlarmRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveAlarm_Dec_Holder"

    class RemoveAlarmResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveAlarmResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveAlarmResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveAlarmResponse')
            kw["aname"] = "_RemoveAlarmResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveAlarmResponse_Holder"
            self.pyclass = Holder

    class ReconfigureAlarm_Dec(ElementDeclaration):
        literal = "ReconfigureAlarm"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureAlarm')
            kw["aname"] = "_ReconfigureAlarm"
            if ns0.ReconfigureAlarmRequestType_Def not in ns0.ReconfigureAlarm_Dec.__bases__:
                bases = list(ns0.ReconfigureAlarm_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureAlarmRequestType_Def)
                ns0.ReconfigureAlarm_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureAlarmRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureAlarm_Dec_Holder"

    class ReconfigureAlarmResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureAlarmResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureAlarmResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureAlarmResponse')
            kw["aname"] = "_ReconfigureAlarmResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureAlarmResponse_Holder"
            self.pyclass = Holder

    class CreateAlarm_Dec(ElementDeclaration):
        literal = "CreateAlarm"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateAlarm')
            kw["aname"] = "_CreateAlarm"
            if ns0.CreateAlarmRequestType_Def not in ns0.CreateAlarm_Dec.__bases__:
                bases = list(ns0.CreateAlarm_Dec.__bases__)
                bases.insert(0, ns0.CreateAlarmRequestType_Def)
                ns0.CreateAlarm_Dec.__bases__ = tuple(bases)

            ns0.CreateAlarmRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateAlarm_Dec_Holder"

    class CreateAlarmResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateAlarmResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateAlarmResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateAlarmResponse')
            kw["aname"] = "_CreateAlarmResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateAlarmResponse_Holder"
            self.pyclass = Holder

    class GetAlarm_Dec(ElementDeclaration):
        literal = "GetAlarm"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GetAlarm')
            kw["aname"] = "_GetAlarm"
            if ns0.GetAlarmRequestType_Def not in ns0.GetAlarm_Dec.__bases__:
                bases = list(ns0.GetAlarm_Dec.__bases__)
                bases.insert(0, ns0.GetAlarmRequestType_Def)
                ns0.GetAlarm_Dec.__bases__ = tuple(bases)

            ns0.GetAlarmRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GetAlarm_Dec_Holder"

    class GetAlarmResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "GetAlarmResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.GetAlarmResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'GetAlarmResponse')
            kw["aname"] = "_GetAlarmResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "GetAlarmResponse_Holder"
            self.pyclass = Holder

    class GetAlarmState_Dec(ElementDeclaration):
        literal = "GetAlarmState"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GetAlarmState')
            kw["aname"] = "_GetAlarmState"
            if ns0.GetAlarmStateRequestType_Def not in ns0.GetAlarmState_Dec.__bases__:
                bases = list(ns0.GetAlarmState_Dec.__bases__)
                bases.insert(0, ns0.GetAlarmStateRequestType_Def)
                ns0.GetAlarmState_Dec.__bases__ = tuple(bases)

            ns0.GetAlarmStateRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GetAlarmState_Dec_Holder"

    class GetAlarmStateResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "GetAlarmStateResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.GetAlarmStateResponse_Dec.schema
            TClist = [GTD("urn:vim25","AlarmState",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'GetAlarmStateResponse')
            kw["aname"] = "_GetAlarmStateResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "GetAlarmStateResponse_Holder"
            self.pyclass = Holder

    class ReadNextEvents_Dec(ElementDeclaration):
        literal = "ReadNextEvents"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReadNextEvents')
            kw["aname"] = "_ReadNextEvents"
            if ns0.ReadNextEventsRequestType_Def not in ns0.ReadNextEvents_Dec.__bases__:
                bases = list(ns0.ReadNextEvents_Dec.__bases__)
                bases.insert(0, ns0.ReadNextEventsRequestType_Def)
                ns0.ReadNextEvents_Dec.__bases__ = tuple(bases)

            ns0.ReadNextEventsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReadNextEvents_Dec_Holder"

    class ReadNextEventsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReadNextEventsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReadNextEventsResponse_Dec.schema
            TClist = [GTD("urn:vim25","Event",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReadNextEventsResponse')
            kw["aname"] = "_ReadNextEventsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ReadNextEventsResponse_Holder"
            self.pyclass = Holder

    class ReadPreviousEvents_Dec(ElementDeclaration):
        literal = "ReadPreviousEvents"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReadPreviousEvents')
            kw["aname"] = "_ReadPreviousEvents"
            if ns0.ReadPreviousEventsRequestType_Def not in ns0.ReadPreviousEvents_Dec.__bases__:
                bases = list(ns0.ReadPreviousEvents_Dec.__bases__)
                bases.insert(0, ns0.ReadPreviousEventsRequestType_Def)
                ns0.ReadPreviousEvents_Dec.__bases__ = tuple(bases)

            ns0.ReadPreviousEventsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReadPreviousEvents_Dec_Holder"

    class ReadPreviousEventsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReadPreviousEventsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReadPreviousEventsResponse_Dec.schema
            TClist = [GTD("urn:vim25","Event",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ReadPreviousEventsResponse')
            kw["aname"] = "_ReadPreviousEventsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ReadPreviousEventsResponse_Holder"
            self.pyclass = Holder

    class CreateCollectorForEvents_Dec(ElementDeclaration):
        literal = "CreateCollectorForEvents"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateCollectorForEvents')
            kw["aname"] = "_CreateCollectorForEvents"
            if ns0.CreateCollectorForEventsRequestType_Def not in ns0.CreateCollectorForEvents_Dec.__bases__:
                bases = list(ns0.CreateCollectorForEvents_Dec.__bases__)
                bases.insert(0, ns0.CreateCollectorForEventsRequestType_Def)
                ns0.CreateCollectorForEvents_Dec.__bases__ = tuple(bases)

            ns0.CreateCollectorForEventsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateCollectorForEvents_Dec_Holder"

    class CreateCollectorForEventsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateCollectorForEventsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateCollectorForEventsResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateCollectorForEventsResponse')
            kw["aname"] = "_CreateCollectorForEventsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateCollectorForEventsResponse_Holder"
            self.pyclass = Holder

    class LogUserEvent_Dec(ElementDeclaration):
        literal = "LogUserEvent"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LogUserEvent')
            kw["aname"] = "_LogUserEvent"
            if ns0.LogUserEventRequestType_Def not in ns0.LogUserEvent_Dec.__bases__:
                bases = list(ns0.LogUserEvent_Dec.__bases__)
                bases.insert(0, ns0.LogUserEventRequestType_Def)
                ns0.LogUserEvent_Dec.__bases__ = tuple(bases)

            ns0.LogUserEventRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LogUserEvent_Dec_Holder"

    class LogUserEventResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "LogUserEventResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.LogUserEventResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'LogUserEventResponse')
            kw["aname"] = "_LogUserEventResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "LogUserEventResponse_Holder"
            self.pyclass = Holder

    class QueryEvents_Dec(ElementDeclaration):
        literal = "QueryEvents"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryEvents')
            kw["aname"] = "_QueryEvents"
            if ns0.QueryEventsRequestType_Def not in ns0.QueryEvents_Dec.__bases__:
                bases = list(ns0.QueryEvents_Dec.__bases__)
                bases.insert(0, ns0.QueryEventsRequestType_Def)
                ns0.QueryEvents_Dec.__bases__ = tuple(bases)

            ns0.QueryEventsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryEvents_Dec_Holder"

    class QueryEventsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryEventsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryEventsResponse_Dec.schema
            TClist = [GTD("urn:vim25","Event",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryEventsResponse')
            kw["aname"] = "_QueryEventsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryEventsResponse_Holder"
            self.pyclass = Holder

    class PostEvent_Dec(ElementDeclaration):
        literal = "PostEvent"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PostEvent')
            kw["aname"] = "_PostEvent"
            if ns0.PostEventRequestType_Def not in ns0.PostEvent_Dec.__bases__:
                bases = list(ns0.PostEvent_Dec.__bases__)
                bases.insert(0, ns0.PostEventRequestType_Def)
                ns0.PostEvent_Dec.__bases__ = tuple(bases)

            ns0.PostEventRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PostEvent_Dec_Holder"

    class PostEventResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "PostEventResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.PostEventResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'PostEventResponse')
            kw["aname"] = "_PostEventResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "PostEventResponse_Holder"
            self.pyclass = Holder

    class AdminDisabledFault_Dec(ElementDeclaration):
        literal = "AdminDisabledFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AdminDisabledFault')
            kw["aname"] = "_AdminDisabledFault"
            if ns0.AdminDisabled_Def not in ns0.AdminDisabledFault_Dec.__bases__:
                bases = list(ns0.AdminDisabledFault_Dec.__bases__)
                bases.insert(0, ns0.AdminDisabled_Def)
                ns0.AdminDisabledFault_Dec.__bases__ = tuple(bases)

            ns0.AdminDisabled_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AdminDisabledFault_Dec_Holder"

    class AdminNotDisabledFault_Dec(ElementDeclaration):
        literal = "AdminNotDisabledFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AdminNotDisabledFault')
            kw["aname"] = "_AdminNotDisabledFault"
            if ns0.AdminNotDisabled_Def not in ns0.AdminNotDisabledFault_Dec.__bases__:
                bases = list(ns0.AdminNotDisabledFault_Dec.__bases__)
                bases.insert(0, ns0.AdminNotDisabled_Def)
                ns0.AdminNotDisabledFault_Dec.__bases__ = tuple(bases)

            ns0.AdminNotDisabled_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AdminNotDisabledFault_Dec_Holder"

    class AffinityConfiguredFault_Dec(ElementDeclaration):
        literal = "AffinityConfiguredFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AffinityConfiguredFault')
            kw["aname"] = "_AffinityConfiguredFault"
            if ns0.AffinityConfigured_Def not in ns0.AffinityConfiguredFault_Dec.__bases__:
                bases = list(ns0.AffinityConfiguredFault_Dec.__bases__)
                bases.insert(0, ns0.AffinityConfigured_Def)
                ns0.AffinityConfiguredFault_Dec.__bases__ = tuple(bases)

            ns0.AffinityConfigured_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AffinityConfiguredFault_Dec_Holder"

    class AgentInstallFailedFault_Dec(ElementDeclaration):
        literal = "AgentInstallFailedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AgentInstallFailedFault')
            kw["aname"] = "_AgentInstallFailedFault"
            if ns0.AgentInstallFailed_Def not in ns0.AgentInstallFailedFault_Dec.__bases__:
                bases = list(ns0.AgentInstallFailedFault_Dec.__bases__)
                bases.insert(0, ns0.AgentInstallFailed_Def)
                ns0.AgentInstallFailedFault_Dec.__bases__ = tuple(bases)

            ns0.AgentInstallFailed_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AgentInstallFailedFault_Dec_Holder"

    class AlreadyBeingManagedFault_Dec(ElementDeclaration):
        literal = "AlreadyBeingManagedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AlreadyBeingManagedFault')
            kw["aname"] = "_AlreadyBeingManagedFault"
            if ns0.AlreadyBeingManaged_Def not in ns0.AlreadyBeingManagedFault_Dec.__bases__:
                bases = list(ns0.AlreadyBeingManagedFault_Dec.__bases__)
                bases.insert(0, ns0.AlreadyBeingManaged_Def)
                ns0.AlreadyBeingManagedFault_Dec.__bases__ = tuple(bases)

            ns0.AlreadyBeingManaged_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AlreadyBeingManagedFault_Dec_Holder"

    class AlreadyConnectedFault_Dec(ElementDeclaration):
        literal = "AlreadyConnectedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AlreadyConnectedFault')
            kw["aname"] = "_AlreadyConnectedFault"
            if ns0.AlreadyConnected_Def not in ns0.AlreadyConnectedFault_Dec.__bases__:
                bases = list(ns0.AlreadyConnectedFault_Dec.__bases__)
                bases.insert(0, ns0.AlreadyConnected_Def)
                ns0.AlreadyConnectedFault_Dec.__bases__ = tuple(bases)

            ns0.AlreadyConnected_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AlreadyConnectedFault_Dec_Holder"

    class AlreadyExistsFault_Dec(ElementDeclaration):
        literal = "AlreadyExistsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AlreadyExistsFault')
            kw["aname"] = "_AlreadyExistsFault"
            if ns0.AlreadyExists_Def not in ns0.AlreadyExistsFault_Dec.__bases__:
                bases = list(ns0.AlreadyExistsFault_Dec.__bases__)
                bases.insert(0, ns0.AlreadyExists_Def)
                ns0.AlreadyExistsFault_Dec.__bases__ = tuple(bases)

            ns0.AlreadyExists_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AlreadyExistsFault_Dec_Holder"

    class AlreadyUpgradedFault_Dec(ElementDeclaration):
        literal = "AlreadyUpgradedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AlreadyUpgradedFault')
            kw["aname"] = "_AlreadyUpgradedFault"
            if ns0.AlreadyUpgraded_Def not in ns0.AlreadyUpgradedFault_Dec.__bases__:
                bases = list(ns0.AlreadyUpgradedFault_Dec.__bases__)
                bases.insert(0, ns0.AlreadyUpgraded_Def)
                ns0.AlreadyUpgradedFault_Dec.__bases__ = tuple(bases)

            ns0.AlreadyUpgraded_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AlreadyUpgradedFault_Dec_Holder"

    class ApplicationQuiesceFaultFault_Dec(ElementDeclaration):
        literal = "ApplicationQuiesceFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ApplicationQuiesceFaultFault')
            kw["aname"] = "_ApplicationQuiesceFaultFault"
            if ns0.ApplicationQuiesceFault_Def not in ns0.ApplicationQuiesceFaultFault_Dec.__bases__:
                bases = list(ns0.ApplicationQuiesceFaultFault_Dec.__bases__)
                bases.insert(0, ns0.ApplicationQuiesceFault_Def)
                ns0.ApplicationQuiesceFaultFault_Dec.__bases__ = tuple(bases)

            ns0.ApplicationQuiesceFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ApplicationQuiesceFaultFault_Dec_Holder"

    class AuthMinimumAdminPermissionFault_Dec(ElementDeclaration):
        literal = "AuthMinimumAdminPermissionFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AuthMinimumAdminPermissionFault')
            kw["aname"] = "_AuthMinimumAdminPermissionFault"
            if ns0.AuthMinimumAdminPermission_Def not in ns0.AuthMinimumAdminPermissionFault_Dec.__bases__:
                bases = list(ns0.AuthMinimumAdminPermissionFault_Dec.__bases__)
                bases.insert(0, ns0.AuthMinimumAdminPermission_Def)
                ns0.AuthMinimumAdminPermissionFault_Dec.__bases__ = tuple(bases)

            ns0.AuthMinimumAdminPermission_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AuthMinimumAdminPermissionFault_Dec_Holder"

    class CannotAccessFileFault_Dec(ElementDeclaration):
        literal = "CannotAccessFileFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotAccessFileFault')
            kw["aname"] = "_CannotAccessFileFault"
            if ns0.CannotAccessFile_Def not in ns0.CannotAccessFileFault_Dec.__bases__:
                bases = list(ns0.CannotAccessFileFault_Dec.__bases__)
                bases.insert(0, ns0.CannotAccessFile_Def)
                ns0.CannotAccessFileFault_Dec.__bases__ = tuple(bases)

            ns0.CannotAccessFile_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotAccessFileFault_Dec_Holder"

    class CannotAccessLocalSourceFault_Dec(ElementDeclaration):
        literal = "CannotAccessLocalSourceFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotAccessLocalSourceFault')
            kw["aname"] = "_CannotAccessLocalSourceFault"
            if ns0.CannotAccessLocalSource_Def not in ns0.CannotAccessLocalSourceFault_Dec.__bases__:
                bases = list(ns0.CannotAccessLocalSourceFault_Dec.__bases__)
                bases.insert(0, ns0.CannotAccessLocalSource_Def)
                ns0.CannotAccessLocalSourceFault_Dec.__bases__ = tuple(bases)

            ns0.CannotAccessLocalSource_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotAccessLocalSourceFault_Dec_Holder"

    class CannotAccessNetworkFault_Dec(ElementDeclaration):
        literal = "CannotAccessNetworkFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotAccessNetworkFault')
            kw["aname"] = "_CannotAccessNetworkFault"
            if ns0.CannotAccessNetwork_Def not in ns0.CannotAccessNetworkFault_Dec.__bases__:
                bases = list(ns0.CannotAccessNetworkFault_Dec.__bases__)
                bases.insert(0, ns0.CannotAccessNetwork_Def)
                ns0.CannotAccessNetworkFault_Dec.__bases__ = tuple(bases)

            ns0.CannotAccessNetwork_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotAccessNetworkFault_Dec_Holder"

    class CannotAccessVmComponentFault_Dec(ElementDeclaration):
        literal = "CannotAccessVmComponentFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotAccessVmComponentFault')
            kw["aname"] = "_CannotAccessVmComponentFault"
            if ns0.CannotAccessVmComponent_Def not in ns0.CannotAccessVmComponentFault_Dec.__bases__:
                bases = list(ns0.CannotAccessVmComponentFault_Dec.__bases__)
                bases.insert(0, ns0.CannotAccessVmComponent_Def)
                ns0.CannotAccessVmComponentFault_Dec.__bases__ = tuple(bases)

            ns0.CannotAccessVmComponent_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotAccessVmComponentFault_Dec_Holder"

    class CannotAccessVmConfigFault_Dec(ElementDeclaration):
        literal = "CannotAccessVmConfigFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotAccessVmConfigFault')
            kw["aname"] = "_CannotAccessVmConfigFault"
            if ns0.CannotAccessVmConfig_Def not in ns0.CannotAccessVmConfigFault_Dec.__bases__:
                bases = list(ns0.CannotAccessVmConfigFault_Dec.__bases__)
                bases.insert(0, ns0.CannotAccessVmConfig_Def)
                ns0.CannotAccessVmConfigFault_Dec.__bases__ = tuple(bases)

            ns0.CannotAccessVmConfig_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotAccessVmConfigFault_Dec_Holder"

    class CannotAccessVmDeviceFault_Dec(ElementDeclaration):
        literal = "CannotAccessVmDeviceFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotAccessVmDeviceFault')
            kw["aname"] = "_CannotAccessVmDeviceFault"
            if ns0.CannotAccessVmDevice_Def not in ns0.CannotAccessVmDeviceFault_Dec.__bases__:
                bases = list(ns0.CannotAccessVmDeviceFault_Dec.__bases__)
                bases.insert(0, ns0.CannotAccessVmDevice_Def)
                ns0.CannotAccessVmDeviceFault_Dec.__bases__ = tuple(bases)

            ns0.CannotAccessVmDevice_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotAccessVmDeviceFault_Dec_Holder"

    class CannotAccessVmDiskFault_Dec(ElementDeclaration):
        literal = "CannotAccessVmDiskFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotAccessVmDiskFault')
            kw["aname"] = "_CannotAccessVmDiskFault"
            if ns0.CannotAccessVmDisk_Def not in ns0.CannotAccessVmDiskFault_Dec.__bases__:
                bases = list(ns0.CannotAccessVmDiskFault_Dec.__bases__)
                bases.insert(0, ns0.CannotAccessVmDisk_Def)
                ns0.CannotAccessVmDiskFault_Dec.__bases__ = tuple(bases)

            ns0.CannotAccessVmDisk_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotAccessVmDiskFault_Dec_Holder"

    class CannotCreateFileFault_Dec(ElementDeclaration):
        literal = "CannotCreateFileFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotCreateFileFault')
            kw["aname"] = "_CannotCreateFileFault"
            if ns0.CannotCreateFile_Def not in ns0.CannotCreateFileFault_Dec.__bases__:
                bases = list(ns0.CannotCreateFileFault_Dec.__bases__)
                bases.insert(0, ns0.CannotCreateFile_Def)
                ns0.CannotCreateFileFault_Dec.__bases__ = tuple(bases)

            ns0.CannotCreateFile_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotCreateFileFault_Dec_Holder"

    class CannotDecryptPasswordsFault_Dec(ElementDeclaration):
        literal = "CannotDecryptPasswordsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotDecryptPasswordsFault')
            kw["aname"] = "_CannotDecryptPasswordsFault"
            if ns0.CannotDecryptPasswords_Def not in ns0.CannotDecryptPasswordsFault_Dec.__bases__:
                bases = list(ns0.CannotDecryptPasswordsFault_Dec.__bases__)
                bases.insert(0, ns0.CannotDecryptPasswords_Def)
                ns0.CannotDecryptPasswordsFault_Dec.__bases__ = tuple(bases)

            ns0.CannotDecryptPasswords_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotDecryptPasswordsFault_Dec_Holder"

    class CannotDeleteFileFault_Dec(ElementDeclaration):
        literal = "CannotDeleteFileFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotDeleteFileFault')
            kw["aname"] = "_CannotDeleteFileFault"
            if ns0.CannotDeleteFile_Def not in ns0.CannotDeleteFileFault_Dec.__bases__:
                bases = list(ns0.CannotDeleteFileFault_Dec.__bases__)
                bases.insert(0, ns0.CannotDeleteFile_Def)
                ns0.CannotDeleteFileFault_Dec.__bases__ = tuple(bases)

            ns0.CannotDeleteFile_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotDeleteFileFault_Dec_Holder"

    class CannotDisableSnapshotFault_Dec(ElementDeclaration):
        literal = "CannotDisableSnapshotFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotDisableSnapshotFault')
            kw["aname"] = "_CannotDisableSnapshotFault"
            if ns0.CannotDisableSnapshot_Def not in ns0.CannotDisableSnapshotFault_Dec.__bases__:
                bases = list(ns0.CannotDisableSnapshotFault_Dec.__bases__)
                bases.insert(0, ns0.CannotDisableSnapshot_Def)
                ns0.CannotDisableSnapshotFault_Dec.__bases__ = tuple(bases)

            ns0.CannotDisableSnapshot_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotDisableSnapshotFault_Dec_Holder"

    class CannotModifyConfigCpuRequirementsFault_Dec(ElementDeclaration):
        literal = "CannotModifyConfigCpuRequirementsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CannotModifyConfigCpuRequirementsFault')
            kw["aname"] = "_CannotModifyConfigCpuRequirementsFault"
            if ns0.CannotModifyConfigCpuRequirements_Def not in ns0.CannotModifyConfigCpuRequirementsFault_Dec.__bases__:
                bases = list(ns0.CannotModifyConfigCpuRequirementsFault_Dec.__bases__)
                bases.insert(0, ns0.CannotModifyConfigCpuRequirements_Def)
                ns0.CannotModifyConfigCpuRequirementsFault_Dec.__bases__ = tuple(bases)

            ns0.CannotModifyConfigCpuRequirements_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CannotModifyConfigCpuRequirementsFault_Dec_Holder"

    class ConcurrentAccessFault_Dec(ElementDeclaration):
        literal = "ConcurrentAccessFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ConcurrentAccessFault')
            kw["aname"] = "_ConcurrentAccessFault"
            if ns0.ConcurrentAccess_Def not in ns0.ConcurrentAccessFault_Dec.__bases__:
                bases = list(ns0.ConcurrentAccessFault_Dec.__bases__)
                bases.insert(0, ns0.ConcurrentAccess_Def)
                ns0.ConcurrentAccessFault_Dec.__bases__ = tuple(bases)

            ns0.ConcurrentAccess_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ConcurrentAccessFault_Dec_Holder"

    class CpuCompatibilityUnknownFault_Dec(ElementDeclaration):
        literal = "CpuCompatibilityUnknownFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CpuCompatibilityUnknownFault')
            kw["aname"] = "_CpuCompatibilityUnknownFault"
            if ns0.CpuCompatibilityUnknown_Def not in ns0.CpuCompatibilityUnknownFault_Dec.__bases__:
                bases = list(ns0.CpuCompatibilityUnknownFault_Dec.__bases__)
                bases.insert(0, ns0.CpuCompatibilityUnknown_Def)
                ns0.CpuCompatibilityUnknownFault_Dec.__bases__ = tuple(bases)

            ns0.CpuCompatibilityUnknown_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CpuCompatibilityUnknownFault_Dec_Holder"

    class CpuIncompatibleFault_Dec(ElementDeclaration):
        literal = "CpuIncompatibleFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CpuIncompatibleFault')
            kw["aname"] = "_CpuIncompatibleFault"
            if ns0.CpuIncompatible_Def not in ns0.CpuIncompatibleFault_Dec.__bases__:
                bases = list(ns0.CpuIncompatibleFault_Dec.__bases__)
                bases.insert(0, ns0.CpuIncompatible_Def)
                ns0.CpuIncompatibleFault_Dec.__bases__ = tuple(bases)

            ns0.CpuIncompatible_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CpuIncompatibleFault_Dec_Holder"

    class CpuIncompatible1ECXFault_Dec(ElementDeclaration):
        literal = "CpuIncompatible1ECXFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CpuIncompatible1ECXFault')
            kw["aname"] = "_CpuIncompatible1ECXFault"
            if ns0.CpuIncompatible1ECX_Def not in ns0.CpuIncompatible1ECXFault_Dec.__bases__:
                bases = list(ns0.CpuIncompatible1ECXFault_Dec.__bases__)
                bases.insert(0, ns0.CpuIncompatible1ECX_Def)
                ns0.CpuIncompatible1ECXFault_Dec.__bases__ = tuple(bases)

            ns0.CpuIncompatible1ECX_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CpuIncompatible1ECXFault_Dec_Holder"

    class CpuIncompatible81EDXFault_Dec(ElementDeclaration):
        literal = "CpuIncompatible81EDXFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CpuIncompatible81EDXFault')
            kw["aname"] = "_CpuIncompatible81EDXFault"
            if ns0.CpuIncompatible81EDX_Def not in ns0.CpuIncompatible81EDXFault_Dec.__bases__:
                bases = list(ns0.CpuIncompatible81EDXFault_Dec.__bases__)
                bases.insert(0, ns0.CpuIncompatible81EDX_Def)
                ns0.CpuIncompatible81EDXFault_Dec.__bases__ = tuple(bases)

            ns0.CpuIncompatible81EDX_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CpuIncompatible81EDXFault_Dec_Holder"

    class CustomizationFaultFault_Dec(ElementDeclaration):
        literal = "CustomizationFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CustomizationFaultFault')
            kw["aname"] = "_CustomizationFaultFault"
            if ns0.CustomizationFault_Def not in ns0.CustomizationFaultFault_Dec.__bases__:
                bases = list(ns0.CustomizationFaultFault_Dec.__bases__)
                bases.insert(0, ns0.CustomizationFault_Def)
                ns0.CustomizationFaultFault_Dec.__bases__ = tuple(bases)

            ns0.CustomizationFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CustomizationFaultFault_Dec_Holder"

    class CustomizationPendingFault_Dec(ElementDeclaration):
        literal = "CustomizationPendingFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CustomizationPendingFault')
            kw["aname"] = "_CustomizationPendingFault"
            if ns0.CustomizationPending_Def not in ns0.CustomizationPendingFault_Dec.__bases__:
                bases = list(ns0.CustomizationPendingFault_Dec.__bases__)
                bases.insert(0, ns0.CustomizationPending_Def)
                ns0.CustomizationPendingFault_Dec.__bases__ = tuple(bases)

            ns0.CustomizationPending_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CustomizationPendingFault_Dec_Holder"

    class DasConfigFaultFault_Dec(ElementDeclaration):
        literal = "DasConfigFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DasConfigFaultFault')
            kw["aname"] = "_DasConfigFaultFault"
            if ns0.DasConfigFault_Def not in ns0.DasConfigFaultFault_Dec.__bases__:
                bases = list(ns0.DasConfigFaultFault_Dec.__bases__)
                bases.insert(0, ns0.DasConfigFault_Def)
                ns0.DasConfigFaultFault_Dec.__bases__ = tuple(bases)

            ns0.DasConfigFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DasConfigFaultFault_Dec_Holder"

    class DatabaseErrorFault_Dec(ElementDeclaration):
        literal = "DatabaseErrorFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DatabaseErrorFault')
            kw["aname"] = "_DatabaseErrorFault"
            if ns0.DatabaseError_Def not in ns0.DatabaseErrorFault_Dec.__bases__:
                bases = list(ns0.DatabaseErrorFault_Dec.__bases__)
                bases.insert(0, ns0.DatabaseError_Def)
                ns0.DatabaseErrorFault_Dec.__bases__ = tuple(bases)

            ns0.DatabaseError_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DatabaseErrorFault_Dec_Holder"

    class DatacenterMismatchFault_Dec(ElementDeclaration):
        literal = "DatacenterMismatchFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DatacenterMismatchFault')
            kw["aname"] = "_DatacenterMismatchFault"
            if ns0.DatacenterMismatch_Def not in ns0.DatacenterMismatchFault_Dec.__bases__:
                bases = list(ns0.DatacenterMismatchFault_Dec.__bases__)
                bases.insert(0, ns0.DatacenterMismatch_Def)
                ns0.DatacenterMismatchFault_Dec.__bases__ = tuple(bases)

            ns0.DatacenterMismatch_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DatacenterMismatchFault_Dec_Holder"

    class DatastoreNotWritableOnHostFault_Dec(ElementDeclaration):
        literal = "DatastoreNotWritableOnHostFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DatastoreNotWritableOnHostFault')
            kw["aname"] = "_DatastoreNotWritableOnHostFault"
            if ns0.DatastoreNotWritableOnHost_Def not in ns0.DatastoreNotWritableOnHostFault_Dec.__bases__:
                bases = list(ns0.DatastoreNotWritableOnHostFault_Dec.__bases__)
                bases.insert(0, ns0.DatastoreNotWritableOnHost_Def)
                ns0.DatastoreNotWritableOnHostFault_Dec.__bases__ = tuple(bases)

            ns0.DatastoreNotWritableOnHost_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DatastoreNotWritableOnHostFault_Dec_Holder"

    class DestinationSwitchFullFault_Dec(ElementDeclaration):
        literal = "DestinationSwitchFullFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DestinationSwitchFullFault')
            kw["aname"] = "_DestinationSwitchFullFault"
            if ns0.DestinationSwitchFull_Def not in ns0.DestinationSwitchFullFault_Dec.__bases__:
                bases = list(ns0.DestinationSwitchFullFault_Dec.__bases__)
                bases.insert(0, ns0.DestinationSwitchFull_Def)
                ns0.DestinationSwitchFullFault_Dec.__bases__ = tuple(bases)

            ns0.DestinationSwitchFull_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DestinationSwitchFullFault_Dec_Holder"

    class DeviceBackingNotSupportedFault_Dec(ElementDeclaration):
        literal = "DeviceBackingNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeviceBackingNotSupportedFault')
            kw["aname"] = "_DeviceBackingNotSupportedFault"
            if ns0.DeviceBackingNotSupported_Def not in ns0.DeviceBackingNotSupportedFault_Dec.__bases__:
                bases = list(ns0.DeviceBackingNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.DeviceBackingNotSupported_Def)
                ns0.DeviceBackingNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.DeviceBackingNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeviceBackingNotSupportedFault_Dec_Holder"

    class DeviceControllerNotSupportedFault_Dec(ElementDeclaration):
        literal = "DeviceControllerNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeviceControllerNotSupportedFault')
            kw["aname"] = "_DeviceControllerNotSupportedFault"
            if ns0.DeviceControllerNotSupported_Def not in ns0.DeviceControllerNotSupportedFault_Dec.__bases__:
                bases = list(ns0.DeviceControllerNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.DeviceControllerNotSupported_Def)
                ns0.DeviceControllerNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.DeviceControllerNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeviceControllerNotSupportedFault_Dec_Holder"

    class DeviceNotFoundFault_Dec(ElementDeclaration):
        literal = "DeviceNotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeviceNotFoundFault')
            kw["aname"] = "_DeviceNotFoundFault"
            if ns0.DeviceNotFound_Def not in ns0.DeviceNotFoundFault_Dec.__bases__:
                bases = list(ns0.DeviceNotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.DeviceNotFound_Def)
                ns0.DeviceNotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.DeviceNotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeviceNotFoundFault_Dec_Holder"

    class DeviceNotSupportedFault_Dec(ElementDeclaration):
        literal = "DeviceNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeviceNotSupportedFault')
            kw["aname"] = "_DeviceNotSupportedFault"
            if ns0.DeviceNotSupported_Def not in ns0.DeviceNotSupportedFault_Dec.__bases__:
                bases = list(ns0.DeviceNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.DeviceNotSupported_Def)
                ns0.DeviceNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.DeviceNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeviceNotSupportedFault_Dec_Holder"

    class DisableAdminNotSupportedFault_Dec(ElementDeclaration):
        literal = "DisableAdminNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisableAdminNotSupportedFault')
            kw["aname"] = "_DisableAdminNotSupportedFault"
            if ns0.DisableAdminNotSupported_Def not in ns0.DisableAdminNotSupportedFault_Dec.__bases__:
                bases = list(ns0.DisableAdminNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.DisableAdminNotSupported_Def)
                ns0.DisableAdminNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.DisableAdminNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisableAdminNotSupportedFault_Dec_Holder"

    class DisallowedDiskModeChangeFault_Dec(ElementDeclaration):
        literal = "DisallowedDiskModeChangeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisallowedDiskModeChangeFault')
            kw["aname"] = "_DisallowedDiskModeChangeFault"
            if ns0.DisallowedDiskModeChange_Def not in ns0.DisallowedDiskModeChangeFault_Dec.__bases__:
                bases = list(ns0.DisallowedDiskModeChangeFault_Dec.__bases__)
                bases.insert(0, ns0.DisallowedDiskModeChange_Def)
                ns0.DisallowedDiskModeChangeFault_Dec.__bases__ = tuple(bases)

            ns0.DisallowedDiskModeChange_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisallowedDiskModeChangeFault_Dec_Holder"

    class DisallowedMigrationDeviceAttachedFault_Dec(ElementDeclaration):
        literal = "DisallowedMigrationDeviceAttachedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisallowedMigrationDeviceAttachedFault')
            kw["aname"] = "_DisallowedMigrationDeviceAttachedFault"
            if ns0.DisallowedMigrationDeviceAttached_Def not in ns0.DisallowedMigrationDeviceAttachedFault_Dec.__bases__:
                bases = list(ns0.DisallowedMigrationDeviceAttachedFault_Dec.__bases__)
                bases.insert(0, ns0.DisallowedMigrationDeviceAttached_Def)
                ns0.DisallowedMigrationDeviceAttachedFault_Dec.__bases__ = tuple(bases)

            ns0.DisallowedMigrationDeviceAttached_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisallowedMigrationDeviceAttachedFault_Dec_Holder"

    class DiskNotSupportedFault_Dec(ElementDeclaration):
        literal = "DiskNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DiskNotSupportedFault')
            kw["aname"] = "_DiskNotSupportedFault"
            if ns0.DiskNotSupported_Def not in ns0.DiskNotSupportedFault_Dec.__bases__:
                bases = list(ns0.DiskNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.DiskNotSupported_Def)
                ns0.DiskNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.DiskNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DiskNotSupportedFault_Dec_Holder"

    class DuplicateNameFault_Dec(ElementDeclaration):
        literal = "DuplicateNameFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DuplicateNameFault')
            kw["aname"] = "_DuplicateNameFault"
            if ns0.DuplicateName_Def not in ns0.DuplicateNameFault_Dec.__bases__:
                bases = list(ns0.DuplicateNameFault_Dec.__bases__)
                bases.insert(0, ns0.DuplicateName_Def)
                ns0.DuplicateNameFault_Dec.__bases__ = tuple(bases)

            ns0.DuplicateName_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DuplicateNameFault_Dec_Holder"

    class ExpiredAddonLicenseFault_Dec(ElementDeclaration):
        literal = "ExpiredAddonLicenseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExpiredAddonLicenseFault')
            kw["aname"] = "_ExpiredAddonLicenseFault"
            if ns0.ExpiredAddonLicense_Def not in ns0.ExpiredAddonLicenseFault_Dec.__bases__:
                bases = list(ns0.ExpiredAddonLicenseFault_Dec.__bases__)
                bases.insert(0, ns0.ExpiredAddonLicense_Def)
                ns0.ExpiredAddonLicenseFault_Dec.__bases__ = tuple(bases)

            ns0.ExpiredAddonLicense_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExpiredAddonLicenseFault_Dec_Holder"

    class ExpiredEditionLicenseFault_Dec(ElementDeclaration):
        literal = "ExpiredEditionLicenseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExpiredEditionLicenseFault')
            kw["aname"] = "_ExpiredEditionLicenseFault"
            if ns0.ExpiredEditionLicense_Def not in ns0.ExpiredEditionLicenseFault_Dec.__bases__:
                bases = list(ns0.ExpiredEditionLicenseFault_Dec.__bases__)
                bases.insert(0, ns0.ExpiredEditionLicense_Def)
                ns0.ExpiredEditionLicenseFault_Dec.__bases__ = tuple(bases)

            ns0.ExpiredEditionLicense_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExpiredEditionLicenseFault_Dec_Holder"

    class ExpiredFeatureLicenseFault_Dec(ElementDeclaration):
        literal = "ExpiredFeatureLicenseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExpiredFeatureLicenseFault')
            kw["aname"] = "_ExpiredFeatureLicenseFault"
            if ns0.ExpiredFeatureLicense_Def not in ns0.ExpiredFeatureLicenseFault_Dec.__bases__:
                bases = list(ns0.ExpiredFeatureLicenseFault_Dec.__bases__)
                bases.insert(0, ns0.ExpiredFeatureLicense_Def)
                ns0.ExpiredFeatureLicenseFault_Dec.__bases__ = tuple(bases)

            ns0.ExpiredFeatureLicense_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExpiredFeatureLicenseFault_Dec_Holder"

    class ExtendedFaultFault_Dec(ElementDeclaration):
        literal = "ExtendedFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExtendedFaultFault')
            kw["aname"] = "_ExtendedFaultFault"
            if ns0.ExtendedFault_Def not in ns0.ExtendedFaultFault_Dec.__bases__:
                bases = list(ns0.ExtendedFaultFault_Dec.__bases__)
                bases.insert(0, ns0.ExtendedFault_Def)
                ns0.ExtendedFaultFault_Dec.__bases__ = tuple(bases)

            ns0.ExtendedFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExtendedFaultFault_Dec_Holder"

    class FileAlreadyExistsFault_Dec(ElementDeclaration):
        literal = "FileAlreadyExistsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FileAlreadyExistsFault')
            kw["aname"] = "_FileAlreadyExistsFault"
            if ns0.FileAlreadyExists_Def not in ns0.FileAlreadyExistsFault_Dec.__bases__:
                bases = list(ns0.FileAlreadyExistsFault_Dec.__bases__)
                bases.insert(0, ns0.FileAlreadyExists_Def)
                ns0.FileAlreadyExistsFault_Dec.__bases__ = tuple(bases)

            ns0.FileAlreadyExists_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FileAlreadyExistsFault_Dec_Holder"

    class FileBackedPortNotSupportedFault_Dec(ElementDeclaration):
        literal = "FileBackedPortNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FileBackedPortNotSupportedFault')
            kw["aname"] = "_FileBackedPortNotSupportedFault"
            if ns0.FileBackedPortNotSupported_Def not in ns0.FileBackedPortNotSupportedFault_Dec.__bases__:
                bases = list(ns0.FileBackedPortNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.FileBackedPortNotSupported_Def)
                ns0.FileBackedPortNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.FileBackedPortNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FileBackedPortNotSupportedFault_Dec_Holder"

    class FileFaultFault_Dec(ElementDeclaration):
        literal = "FileFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FileFaultFault')
            kw["aname"] = "_FileFaultFault"
            if ns0.FileFault_Def not in ns0.FileFaultFault_Dec.__bases__:
                bases = list(ns0.FileFaultFault_Dec.__bases__)
                bases.insert(0, ns0.FileFault_Def)
                ns0.FileFaultFault_Dec.__bases__ = tuple(bases)

            ns0.FileFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FileFaultFault_Dec_Holder"

    class FileLockedFault_Dec(ElementDeclaration):
        literal = "FileLockedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FileLockedFault')
            kw["aname"] = "_FileLockedFault"
            if ns0.FileLocked_Def not in ns0.FileLockedFault_Dec.__bases__:
                bases = list(ns0.FileLockedFault_Dec.__bases__)
                bases.insert(0, ns0.FileLocked_Def)
                ns0.FileLockedFault_Dec.__bases__ = tuple(bases)

            ns0.FileLocked_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FileLockedFault_Dec_Holder"

    class FileNotFoundFault_Dec(ElementDeclaration):
        literal = "FileNotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FileNotFoundFault')
            kw["aname"] = "_FileNotFoundFault"
            if ns0.FileNotFound_Def not in ns0.FileNotFoundFault_Dec.__bases__:
                bases = list(ns0.FileNotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.FileNotFound_Def)
                ns0.FileNotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.FileNotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FileNotFoundFault_Dec_Holder"

    class FileNotWritableFault_Dec(ElementDeclaration):
        literal = "FileNotWritableFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FileNotWritableFault')
            kw["aname"] = "_FileNotWritableFault"
            if ns0.FileNotWritable_Def not in ns0.FileNotWritableFault_Dec.__bases__:
                bases = list(ns0.FileNotWritableFault_Dec.__bases__)
                bases.insert(0, ns0.FileNotWritable_Def)
                ns0.FileNotWritableFault_Dec.__bases__ = tuple(bases)

            ns0.FileNotWritable_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FileNotWritableFault_Dec_Holder"

    class FileTooLargeFault_Dec(ElementDeclaration):
        literal = "FileTooLargeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FileTooLargeFault')
            kw["aname"] = "_FileTooLargeFault"
            if ns0.FileTooLarge_Def not in ns0.FileTooLargeFault_Dec.__bases__:
                bases = list(ns0.FileTooLargeFault_Dec.__bases__)
                bases.insert(0, ns0.FileTooLarge_Def)
                ns0.FileTooLargeFault_Dec.__bases__ = tuple(bases)

            ns0.FileTooLarge_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FileTooLargeFault_Dec_Holder"

    class FilesystemQuiesceFaultFault_Dec(ElementDeclaration):
        literal = "FilesystemQuiesceFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FilesystemQuiesceFaultFault')
            kw["aname"] = "_FilesystemQuiesceFaultFault"
            if ns0.FilesystemQuiesceFault_Def not in ns0.FilesystemQuiesceFaultFault_Dec.__bases__:
                bases = list(ns0.FilesystemQuiesceFaultFault_Dec.__bases__)
                bases.insert(0, ns0.FilesystemQuiesceFault_Def)
                ns0.FilesystemQuiesceFaultFault_Dec.__bases__ = tuple(bases)

            ns0.FilesystemQuiesceFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FilesystemQuiesceFaultFault_Dec_Holder"

    class FullStorageVMotionNotSupportedFault_Dec(ElementDeclaration):
        literal = "FullStorageVMotionNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FullStorageVMotionNotSupportedFault')
            kw["aname"] = "_FullStorageVMotionNotSupportedFault"
            if ns0.FullStorageVMotionNotSupported_Def not in ns0.FullStorageVMotionNotSupportedFault_Dec.__bases__:
                bases = list(ns0.FullStorageVMotionNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.FullStorageVMotionNotSupported_Def)
                ns0.FullStorageVMotionNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.FullStorageVMotionNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FullStorageVMotionNotSupportedFault_Dec_Holder"

    class GenericDrsFaultFault_Dec(ElementDeclaration):
        literal = "GenericDrsFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GenericDrsFaultFault')
            kw["aname"] = "_GenericDrsFaultFault"
            if ns0.GenericDrsFault_Def not in ns0.GenericDrsFaultFault_Dec.__bases__:
                bases = list(ns0.GenericDrsFaultFault_Dec.__bases__)
                bases.insert(0, ns0.GenericDrsFault_Def)
                ns0.GenericDrsFaultFault_Dec.__bases__ = tuple(bases)

            ns0.GenericDrsFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GenericDrsFaultFault_Dec_Holder"

    class GenericVmConfigFaultFault_Dec(ElementDeclaration):
        literal = "GenericVmConfigFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'GenericVmConfigFaultFault')
            kw["aname"] = "_GenericVmConfigFaultFault"
            if ns0.GenericVmConfigFault_Def not in ns0.GenericVmConfigFaultFault_Dec.__bases__:
                bases = list(ns0.GenericVmConfigFaultFault_Dec.__bases__)
                bases.insert(0, ns0.GenericVmConfigFault_Def)
                ns0.GenericVmConfigFaultFault_Dec.__bases__ = tuple(bases)

            ns0.GenericVmConfigFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "GenericVmConfigFaultFault_Dec_Holder"

    class HAErrorsAtDestFault_Dec(ElementDeclaration):
        literal = "HAErrorsAtDestFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HAErrorsAtDestFault')
            kw["aname"] = "_HAErrorsAtDestFault"
            if ns0.HAErrorsAtDest_Def not in ns0.HAErrorsAtDestFault_Dec.__bases__:
                bases = list(ns0.HAErrorsAtDestFault_Dec.__bases__)
                bases.insert(0, ns0.HAErrorsAtDest_Def)
                ns0.HAErrorsAtDestFault_Dec.__bases__ = tuple(bases)

            ns0.HAErrorsAtDest_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HAErrorsAtDestFault_Dec_Holder"

    class HostConfigFaultFault_Dec(ElementDeclaration):
        literal = "HostConfigFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HostConfigFaultFault')
            kw["aname"] = "_HostConfigFaultFault"
            if ns0.HostConfigFault_Def not in ns0.HostConfigFaultFault_Dec.__bases__:
                bases = list(ns0.HostConfigFaultFault_Dec.__bases__)
                bases.insert(0, ns0.HostConfigFault_Def)
                ns0.HostConfigFaultFault_Dec.__bases__ = tuple(bases)

            ns0.HostConfigFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HostConfigFaultFault_Dec_Holder"

    class HostConnectFaultFault_Dec(ElementDeclaration):
        literal = "HostConnectFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HostConnectFaultFault')
            kw["aname"] = "_HostConnectFaultFault"
            if ns0.HostConnectFault_Def not in ns0.HostConnectFaultFault_Dec.__bases__:
                bases = list(ns0.HostConnectFaultFault_Dec.__bases__)
                bases.insert(0, ns0.HostConnectFault_Def)
                ns0.HostConnectFaultFault_Dec.__bases__ = tuple(bases)

            ns0.HostConnectFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HostConnectFaultFault_Dec_Holder"

    class HostInventoryFullFault_Dec(ElementDeclaration):
        literal = "HostInventoryFullFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HostInventoryFullFault')
            kw["aname"] = "_HostInventoryFullFault"
            if ns0.HostInventoryFull_Def not in ns0.HostInventoryFullFault_Dec.__bases__:
                bases = list(ns0.HostInventoryFullFault_Dec.__bases__)
                bases.insert(0, ns0.HostInventoryFull_Def)
                ns0.HostInventoryFullFault_Dec.__bases__ = tuple(bases)

            ns0.HostInventoryFull_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HostInventoryFullFault_Dec_Holder"

    class HostPowerOpFailedFault_Dec(ElementDeclaration):
        literal = "HostPowerOpFailedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HostPowerOpFailedFault')
            kw["aname"] = "_HostPowerOpFailedFault"
            if ns0.HostPowerOpFailed_Def not in ns0.HostPowerOpFailedFault_Dec.__bases__:
                bases = list(ns0.HostPowerOpFailedFault_Dec.__bases__)
                bases.insert(0, ns0.HostPowerOpFailed_Def)
                ns0.HostPowerOpFailedFault_Dec.__bases__ = tuple(bases)

            ns0.HostPowerOpFailed_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HostPowerOpFailedFault_Dec_Holder"

    class HotSnapshotMoveNotSupportedFault_Dec(ElementDeclaration):
        literal = "HotSnapshotMoveNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'HotSnapshotMoveNotSupportedFault')
            kw["aname"] = "_HotSnapshotMoveNotSupportedFault"
            if ns0.HotSnapshotMoveNotSupported_Def not in ns0.HotSnapshotMoveNotSupportedFault_Dec.__bases__:
                bases = list(ns0.HotSnapshotMoveNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.HotSnapshotMoveNotSupported_Def)
                ns0.HotSnapshotMoveNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.HotSnapshotMoveNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "HotSnapshotMoveNotSupportedFault_Dec_Holder"

    class IDEDiskNotSupportedFault_Dec(ElementDeclaration):
        literal = "IDEDiskNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'IDEDiskNotSupportedFault')
            kw["aname"] = "_IDEDiskNotSupportedFault"
            if ns0.IDEDiskNotSupported_Def not in ns0.IDEDiskNotSupportedFault_Dec.__bases__:
                bases = list(ns0.IDEDiskNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.IDEDiskNotSupported_Def)
                ns0.IDEDiskNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.IDEDiskNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "IDEDiskNotSupportedFault_Dec_Holder"

    class InaccessibleDatastoreFault_Dec(ElementDeclaration):
        literal = "InaccessibleDatastoreFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InaccessibleDatastoreFault')
            kw["aname"] = "_InaccessibleDatastoreFault"
            if ns0.InaccessibleDatastore_Def not in ns0.InaccessibleDatastoreFault_Dec.__bases__:
                bases = list(ns0.InaccessibleDatastoreFault_Dec.__bases__)
                bases.insert(0, ns0.InaccessibleDatastore_Def)
                ns0.InaccessibleDatastoreFault_Dec.__bases__ = tuple(bases)

            ns0.InaccessibleDatastore_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InaccessibleDatastoreFault_Dec_Holder"

    class IncompatibleDefaultDeviceFault_Dec(ElementDeclaration):
        literal = "IncompatibleDefaultDeviceFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'IncompatibleDefaultDeviceFault')
            kw["aname"] = "_IncompatibleDefaultDeviceFault"
            if ns0.IncompatibleDefaultDevice_Def not in ns0.IncompatibleDefaultDeviceFault_Dec.__bases__:
                bases = list(ns0.IncompatibleDefaultDeviceFault_Dec.__bases__)
                bases.insert(0, ns0.IncompatibleDefaultDevice_Def)
                ns0.IncompatibleDefaultDeviceFault_Dec.__bases__ = tuple(bases)

            ns0.IncompatibleDefaultDevice_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "IncompatibleDefaultDeviceFault_Dec_Holder"

    class IncompatibleSettingFault_Dec(ElementDeclaration):
        literal = "IncompatibleSettingFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'IncompatibleSettingFault')
            kw["aname"] = "_IncompatibleSettingFault"
            if ns0.IncompatibleSetting_Def not in ns0.IncompatibleSettingFault_Dec.__bases__:
                bases = list(ns0.IncompatibleSettingFault_Dec.__bases__)
                bases.insert(0, ns0.IncompatibleSetting_Def)
                ns0.IncompatibleSettingFault_Dec.__bases__ = tuple(bases)

            ns0.IncompatibleSetting_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "IncompatibleSettingFault_Dec_Holder"

    class IncorrectFileTypeFault_Dec(ElementDeclaration):
        literal = "IncorrectFileTypeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'IncorrectFileTypeFault')
            kw["aname"] = "_IncorrectFileTypeFault"
            if ns0.IncorrectFileType_Def not in ns0.IncorrectFileTypeFault_Dec.__bases__:
                bases = list(ns0.IncorrectFileTypeFault_Dec.__bases__)
                bases.insert(0, ns0.IncorrectFileType_Def)
                ns0.IncorrectFileTypeFault_Dec.__bases__ = tuple(bases)

            ns0.IncorrectFileType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "IncorrectFileTypeFault_Dec_Holder"

    class IncorrectHostInformationFault_Dec(ElementDeclaration):
        literal = "IncorrectHostInformationFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'IncorrectHostInformationFault')
            kw["aname"] = "_IncorrectHostInformationFault"
            if ns0.IncorrectHostInformation_Def not in ns0.IncorrectHostInformationFault_Dec.__bases__:
                bases = list(ns0.IncorrectHostInformationFault_Dec.__bases__)
                bases.insert(0, ns0.IncorrectHostInformation_Def)
                ns0.IncorrectHostInformationFault_Dec.__bases__ = tuple(bases)

            ns0.IncorrectHostInformation_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "IncorrectHostInformationFault_Dec_Holder"

    class IndependentDiskVMotionNotSupportedFault_Dec(ElementDeclaration):
        literal = "IndependentDiskVMotionNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'IndependentDiskVMotionNotSupportedFault')
            kw["aname"] = "_IndependentDiskVMotionNotSupportedFault"
            if ns0.IndependentDiskVMotionNotSupported_Def not in ns0.IndependentDiskVMotionNotSupportedFault_Dec.__bases__:
                bases = list(ns0.IndependentDiskVMotionNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.IndependentDiskVMotionNotSupported_Def)
                ns0.IndependentDiskVMotionNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.IndependentDiskVMotionNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "IndependentDiskVMotionNotSupportedFault_Dec_Holder"

    class InsufficientCpuResourcesFaultFault_Dec(ElementDeclaration):
        literal = "InsufficientCpuResourcesFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InsufficientCpuResourcesFaultFault')
            kw["aname"] = "_InsufficientCpuResourcesFaultFault"
            if ns0.InsufficientCpuResourcesFault_Def not in ns0.InsufficientCpuResourcesFaultFault_Dec.__bases__:
                bases = list(ns0.InsufficientCpuResourcesFaultFault_Dec.__bases__)
                bases.insert(0, ns0.InsufficientCpuResourcesFault_Def)
                ns0.InsufficientCpuResourcesFaultFault_Dec.__bases__ = tuple(bases)

            ns0.InsufficientCpuResourcesFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InsufficientCpuResourcesFaultFault_Dec_Holder"

    class InsufficientFailoverResourcesFaultFault_Dec(ElementDeclaration):
        literal = "InsufficientFailoverResourcesFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InsufficientFailoverResourcesFaultFault')
            kw["aname"] = "_InsufficientFailoverResourcesFaultFault"
            if ns0.InsufficientFailoverResourcesFault_Def not in ns0.InsufficientFailoverResourcesFaultFault_Dec.__bases__:
                bases = list(ns0.InsufficientFailoverResourcesFaultFault_Dec.__bases__)
                bases.insert(0, ns0.InsufficientFailoverResourcesFault_Def)
                ns0.InsufficientFailoverResourcesFaultFault_Dec.__bases__ = tuple(bases)

            ns0.InsufficientFailoverResourcesFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InsufficientFailoverResourcesFaultFault_Dec_Holder"

    class InsufficientHostCapacityFaultFault_Dec(ElementDeclaration):
        literal = "InsufficientHostCapacityFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InsufficientHostCapacityFaultFault')
            kw["aname"] = "_InsufficientHostCapacityFaultFault"
            if ns0.InsufficientHostCapacityFault_Def not in ns0.InsufficientHostCapacityFaultFault_Dec.__bases__:
                bases = list(ns0.InsufficientHostCapacityFaultFault_Dec.__bases__)
                bases.insert(0, ns0.InsufficientHostCapacityFault_Def)
                ns0.InsufficientHostCapacityFaultFault_Dec.__bases__ = tuple(bases)

            ns0.InsufficientHostCapacityFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InsufficientHostCapacityFaultFault_Dec_Holder"

    class InsufficientMemoryResourcesFaultFault_Dec(ElementDeclaration):
        literal = "InsufficientMemoryResourcesFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InsufficientMemoryResourcesFaultFault')
            kw["aname"] = "_InsufficientMemoryResourcesFaultFault"
            if ns0.InsufficientMemoryResourcesFault_Def not in ns0.InsufficientMemoryResourcesFaultFault_Dec.__bases__:
                bases = list(ns0.InsufficientMemoryResourcesFaultFault_Dec.__bases__)
                bases.insert(0, ns0.InsufficientMemoryResourcesFault_Def)
                ns0.InsufficientMemoryResourcesFaultFault_Dec.__bases__ = tuple(bases)

            ns0.InsufficientMemoryResourcesFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InsufficientMemoryResourcesFaultFault_Dec_Holder"

    class InsufficientPerCpuCapacityFault_Dec(ElementDeclaration):
        literal = "InsufficientPerCpuCapacityFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InsufficientPerCpuCapacityFault')
            kw["aname"] = "_InsufficientPerCpuCapacityFault"
            if ns0.InsufficientPerCpuCapacity_Def not in ns0.InsufficientPerCpuCapacityFault_Dec.__bases__:
                bases = list(ns0.InsufficientPerCpuCapacityFault_Dec.__bases__)
                bases.insert(0, ns0.InsufficientPerCpuCapacity_Def)
                ns0.InsufficientPerCpuCapacityFault_Dec.__bases__ = tuple(bases)

            ns0.InsufficientPerCpuCapacity_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InsufficientPerCpuCapacityFault_Dec_Holder"

    class InsufficientResourcesFaultFault_Dec(ElementDeclaration):
        literal = "InsufficientResourcesFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InsufficientResourcesFaultFault')
            kw["aname"] = "_InsufficientResourcesFaultFault"
            if ns0.InsufficientResourcesFault_Def not in ns0.InsufficientResourcesFaultFault_Dec.__bases__:
                bases = list(ns0.InsufficientResourcesFaultFault_Dec.__bases__)
                bases.insert(0, ns0.InsufficientResourcesFault_Def)
                ns0.InsufficientResourcesFaultFault_Dec.__bases__ = tuple(bases)

            ns0.InsufficientResourcesFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InsufficientResourcesFaultFault_Dec_Holder"

    class InvalidAffinitySettingFaultFault_Dec(ElementDeclaration):
        literal = "InvalidAffinitySettingFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidAffinitySettingFaultFault')
            kw["aname"] = "_InvalidAffinitySettingFaultFault"
            if ns0.InvalidAffinitySettingFault_Def not in ns0.InvalidAffinitySettingFaultFault_Dec.__bases__:
                bases = list(ns0.InvalidAffinitySettingFaultFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidAffinitySettingFault_Def)
                ns0.InvalidAffinitySettingFaultFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidAffinitySettingFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidAffinitySettingFaultFault_Dec_Holder"

    class InvalidBundleFault_Dec(ElementDeclaration):
        literal = "InvalidBundleFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidBundleFault')
            kw["aname"] = "_InvalidBundleFault"
            if ns0.InvalidBundle_Def not in ns0.InvalidBundleFault_Dec.__bases__:
                bases = list(ns0.InvalidBundleFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidBundle_Def)
                ns0.InvalidBundleFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidBundle_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidBundleFault_Dec_Holder"

    class InvalidControllerFault_Dec(ElementDeclaration):
        literal = "InvalidControllerFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidControllerFault')
            kw["aname"] = "_InvalidControllerFault"
            if ns0.InvalidController_Def not in ns0.InvalidControllerFault_Dec.__bases__:
                bases = list(ns0.InvalidControllerFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidController_Def)
                ns0.InvalidControllerFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidController_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidControllerFault_Dec_Holder"

    class InvalidDatastoreFault_Dec(ElementDeclaration):
        literal = "InvalidDatastoreFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidDatastoreFault')
            kw["aname"] = "_InvalidDatastoreFault"
            if ns0.InvalidDatastore_Def not in ns0.InvalidDatastoreFault_Dec.__bases__:
                bases = list(ns0.InvalidDatastoreFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidDatastore_Def)
                ns0.InvalidDatastoreFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidDatastore_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidDatastoreFault_Dec_Holder"

    class InvalidDatastorePathFault_Dec(ElementDeclaration):
        literal = "InvalidDatastorePathFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidDatastorePathFault')
            kw["aname"] = "_InvalidDatastorePathFault"
            if ns0.InvalidDatastorePath_Def not in ns0.InvalidDatastorePathFault_Dec.__bases__:
                bases = list(ns0.InvalidDatastorePathFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidDatastorePath_Def)
                ns0.InvalidDatastorePathFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidDatastorePath_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidDatastorePathFault_Dec_Holder"

    class InvalidDeviceBackingFault_Dec(ElementDeclaration):
        literal = "InvalidDeviceBackingFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidDeviceBackingFault')
            kw["aname"] = "_InvalidDeviceBackingFault"
            if ns0.InvalidDeviceBacking_Def not in ns0.InvalidDeviceBackingFault_Dec.__bases__:
                bases = list(ns0.InvalidDeviceBackingFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidDeviceBacking_Def)
                ns0.InvalidDeviceBackingFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidDeviceBacking_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidDeviceBackingFault_Dec_Holder"

    class InvalidDeviceOperationFault_Dec(ElementDeclaration):
        literal = "InvalidDeviceOperationFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidDeviceOperationFault')
            kw["aname"] = "_InvalidDeviceOperationFault"
            if ns0.InvalidDeviceOperation_Def not in ns0.InvalidDeviceOperationFault_Dec.__bases__:
                bases = list(ns0.InvalidDeviceOperationFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidDeviceOperation_Def)
                ns0.InvalidDeviceOperationFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidDeviceOperation_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidDeviceOperationFault_Dec_Holder"

    class InvalidDeviceSpecFault_Dec(ElementDeclaration):
        literal = "InvalidDeviceSpecFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidDeviceSpecFault')
            kw["aname"] = "_InvalidDeviceSpecFault"
            if ns0.InvalidDeviceSpec_Def not in ns0.InvalidDeviceSpecFault_Dec.__bases__:
                bases = list(ns0.InvalidDeviceSpecFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidDeviceSpec_Def)
                ns0.InvalidDeviceSpecFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidDeviceSpec_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidDeviceSpecFault_Dec_Holder"

    class InvalidDiskFormatFault_Dec(ElementDeclaration):
        literal = "InvalidDiskFormatFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidDiskFormatFault')
            kw["aname"] = "_InvalidDiskFormatFault"
            if ns0.InvalidDiskFormat_Def not in ns0.InvalidDiskFormatFault_Dec.__bases__:
                bases = list(ns0.InvalidDiskFormatFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidDiskFormat_Def)
                ns0.InvalidDiskFormatFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidDiskFormat_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidDiskFormatFault_Dec_Holder"

    class InvalidEditionLicenseFault_Dec(ElementDeclaration):
        literal = "InvalidEditionLicenseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidEditionLicenseFault')
            kw["aname"] = "_InvalidEditionLicenseFault"
            if ns0.InvalidEditionLicense_Def not in ns0.InvalidEditionLicenseFault_Dec.__bases__:
                bases = list(ns0.InvalidEditionLicenseFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidEditionLicense_Def)
                ns0.InvalidEditionLicenseFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidEditionLicense_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidEditionLicenseFault_Dec_Holder"

    class InvalidEventFault_Dec(ElementDeclaration):
        literal = "InvalidEventFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidEventFault')
            kw["aname"] = "_InvalidEventFault"
            if ns0.InvalidEvent_Def not in ns0.InvalidEventFault_Dec.__bases__:
                bases = list(ns0.InvalidEventFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidEvent_Def)
                ns0.InvalidEventFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidEvent_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidEventFault_Dec_Holder"

    class InvalidFolderFault_Dec(ElementDeclaration):
        literal = "InvalidFolderFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidFolderFault')
            kw["aname"] = "_InvalidFolderFault"
            if ns0.InvalidFolder_Def not in ns0.InvalidFolderFault_Dec.__bases__:
                bases = list(ns0.InvalidFolderFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidFolder_Def)
                ns0.InvalidFolderFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidFolder_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidFolderFault_Dec_Holder"

    class InvalidFormatFault_Dec(ElementDeclaration):
        literal = "InvalidFormatFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidFormatFault')
            kw["aname"] = "_InvalidFormatFault"
            if ns0.InvalidFormat_Def not in ns0.InvalidFormatFault_Dec.__bases__:
                bases = list(ns0.InvalidFormatFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidFormat_Def)
                ns0.InvalidFormatFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidFormat_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidFormatFault_Dec_Holder"

    class InvalidHostStateFault_Dec(ElementDeclaration):
        literal = "InvalidHostStateFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidHostStateFault')
            kw["aname"] = "_InvalidHostStateFault"
            if ns0.InvalidHostState_Def not in ns0.InvalidHostStateFault_Dec.__bases__:
                bases = list(ns0.InvalidHostStateFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidHostState_Def)
                ns0.InvalidHostStateFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidHostState_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidHostStateFault_Dec_Holder"

    class InvalidLicenseFault_Dec(ElementDeclaration):
        literal = "InvalidLicenseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidLicenseFault')
            kw["aname"] = "_InvalidLicenseFault"
            if ns0.InvalidLicense_Def not in ns0.InvalidLicenseFault_Dec.__bases__:
                bases = list(ns0.InvalidLicenseFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidLicense_Def)
                ns0.InvalidLicenseFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidLicense_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidLicenseFault_Dec_Holder"

    class InvalidLocaleFault_Dec(ElementDeclaration):
        literal = "InvalidLocaleFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidLocaleFault')
            kw["aname"] = "_InvalidLocaleFault"
            if ns0.InvalidLocale_Def not in ns0.InvalidLocaleFault_Dec.__bases__:
                bases = list(ns0.InvalidLocaleFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidLocale_Def)
                ns0.InvalidLocaleFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidLocale_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidLocaleFault_Dec_Holder"

    class InvalidLoginFault_Dec(ElementDeclaration):
        literal = "InvalidLoginFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidLoginFault')
            kw["aname"] = "_InvalidLoginFault"
            if ns0.InvalidLogin_Def not in ns0.InvalidLoginFault_Dec.__bases__:
                bases = list(ns0.InvalidLoginFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidLogin_Def)
                ns0.InvalidLoginFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidLogin_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidLoginFault_Dec_Holder"

    class InvalidNameFault_Dec(ElementDeclaration):
        literal = "InvalidNameFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidNameFault')
            kw["aname"] = "_InvalidNameFault"
            if ns0.InvalidName_Def not in ns0.InvalidNameFault_Dec.__bases__:
                bases = list(ns0.InvalidNameFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidName_Def)
                ns0.InvalidNameFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidName_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidNameFault_Dec_Holder"

    class InvalidPowerStateFault_Dec(ElementDeclaration):
        literal = "InvalidPowerStateFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidPowerStateFault')
            kw["aname"] = "_InvalidPowerStateFault"
            if ns0.InvalidPowerState_Def not in ns0.InvalidPowerStateFault_Dec.__bases__:
                bases = list(ns0.InvalidPowerStateFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidPowerState_Def)
                ns0.InvalidPowerStateFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidPowerState_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidPowerStateFault_Dec_Holder"

    class InvalidPrivilegeFault_Dec(ElementDeclaration):
        literal = "InvalidPrivilegeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidPrivilegeFault')
            kw["aname"] = "_InvalidPrivilegeFault"
            if ns0.InvalidPrivilege_Def not in ns0.InvalidPrivilegeFault_Dec.__bases__:
                bases = list(ns0.InvalidPrivilegeFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidPrivilege_Def)
                ns0.InvalidPrivilegeFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidPrivilege_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidPrivilegeFault_Dec_Holder"

    class InvalidResourcePoolStructureFaultFault_Dec(ElementDeclaration):
        literal = "InvalidResourcePoolStructureFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidResourcePoolStructureFaultFault')
            kw["aname"] = "_InvalidResourcePoolStructureFaultFault"
            if ns0.InvalidResourcePoolStructureFault_Def not in ns0.InvalidResourcePoolStructureFaultFault_Dec.__bases__:
                bases = list(ns0.InvalidResourcePoolStructureFaultFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidResourcePoolStructureFault_Def)
                ns0.InvalidResourcePoolStructureFaultFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidResourcePoolStructureFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidResourcePoolStructureFaultFault_Dec_Holder"

    class InvalidSnapshotFormatFault_Dec(ElementDeclaration):
        literal = "InvalidSnapshotFormatFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidSnapshotFormatFault')
            kw["aname"] = "_InvalidSnapshotFormatFault"
            if ns0.InvalidSnapshotFormat_Def not in ns0.InvalidSnapshotFormatFault_Dec.__bases__:
                bases = list(ns0.InvalidSnapshotFormatFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidSnapshotFormat_Def)
                ns0.InvalidSnapshotFormatFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidSnapshotFormat_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidSnapshotFormatFault_Dec_Holder"

    class InvalidStateFault_Dec(ElementDeclaration):
        literal = "InvalidStateFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidStateFault')
            kw["aname"] = "_InvalidStateFault"
            if ns0.InvalidState_Def not in ns0.InvalidStateFault_Dec.__bases__:
                bases = list(ns0.InvalidStateFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidState_Def)
                ns0.InvalidStateFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidState_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidStateFault_Dec_Holder"

    class InvalidVmConfigFault_Dec(ElementDeclaration):
        literal = "InvalidVmConfigFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InvalidVmConfigFault')
            kw["aname"] = "_InvalidVmConfigFault"
            if ns0.InvalidVmConfig_Def not in ns0.InvalidVmConfigFault_Dec.__bases__:
                bases = list(ns0.InvalidVmConfigFault_Dec.__bases__)
                bases.insert(0, ns0.InvalidVmConfig_Def)
                ns0.InvalidVmConfigFault_Dec.__bases__ = tuple(bases)

            ns0.InvalidVmConfig_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InvalidVmConfigFault_Dec_Holder"

    class IpHostnameGeneratorErrorFault_Dec(ElementDeclaration):
        literal = "IpHostnameGeneratorErrorFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'IpHostnameGeneratorErrorFault')
            kw["aname"] = "_IpHostnameGeneratorErrorFault"
            if ns0.IpHostnameGeneratorError_Def not in ns0.IpHostnameGeneratorErrorFault_Dec.__bases__:
                bases = list(ns0.IpHostnameGeneratorErrorFault_Dec.__bases__)
                bases.insert(0, ns0.IpHostnameGeneratorError_Def)
                ns0.IpHostnameGeneratorErrorFault_Dec.__bases__ = tuple(bases)

            ns0.IpHostnameGeneratorError_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "IpHostnameGeneratorErrorFault_Dec_Holder"

    class LegacyNetworkInterfaceInUseFault_Dec(ElementDeclaration):
        literal = "LegacyNetworkInterfaceInUseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LegacyNetworkInterfaceInUseFault')
            kw["aname"] = "_LegacyNetworkInterfaceInUseFault"
            if ns0.LegacyNetworkInterfaceInUse_Def not in ns0.LegacyNetworkInterfaceInUseFault_Dec.__bases__:
                bases = list(ns0.LegacyNetworkInterfaceInUseFault_Dec.__bases__)
                bases.insert(0, ns0.LegacyNetworkInterfaceInUse_Def)
                ns0.LegacyNetworkInterfaceInUseFault_Dec.__bases__ = tuple(bases)

            ns0.LegacyNetworkInterfaceInUse_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LegacyNetworkInterfaceInUseFault_Dec_Holder"

    class LicenseRestrictedFault_Dec(ElementDeclaration):
        literal = "LicenseRestrictedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LicenseRestrictedFault')
            kw["aname"] = "_LicenseRestrictedFault"
            if ns0.LicenseRestricted_Def not in ns0.LicenseRestrictedFault_Dec.__bases__:
                bases = list(ns0.LicenseRestrictedFault_Dec.__bases__)
                bases.insert(0, ns0.LicenseRestricted_Def)
                ns0.LicenseRestrictedFault_Dec.__bases__ = tuple(bases)

            ns0.LicenseRestricted_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LicenseRestrictedFault_Dec_Holder"

    class LicenseServerUnavailableFault_Dec(ElementDeclaration):
        literal = "LicenseServerUnavailableFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LicenseServerUnavailableFault')
            kw["aname"] = "_LicenseServerUnavailableFault"
            if ns0.LicenseServerUnavailable_Def not in ns0.LicenseServerUnavailableFault_Dec.__bases__:
                bases = list(ns0.LicenseServerUnavailableFault_Dec.__bases__)
                bases.insert(0, ns0.LicenseServerUnavailable_Def)
                ns0.LicenseServerUnavailableFault_Dec.__bases__ = tuple(bases)

            ns0.LicenseServerUnavailable_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LicenseServerUnavailableFault_Dec_Holder"

    class LicenseSourceUnavailableFault_Dec(ElementDeclaration):
        literal = "LicenseSourceUnavailableFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LicenseSourceUnavailableFault')
            kw["aname"] = "_LicenseSourceUnavailableFault"
            if ns0.LicenseSourceUnavailable_Def not in ns0.LicenseSourceUnavailableFault_Dec.__bases__:
                bases = list(ns0.LicenseSourceUnavailableFault_Dec.__bases__)
                bases.insert(0, ns0.LicenseSourceUnavailable_Def)
                ns0.LicenseSourceUnavailableFault_Dec.__bases__ = tuple(bases)

            ns0.LicenseSourceUnavailable_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LicenseSourceUnavailableFault_Dec_Holder"

    class LinuxVolumeNotCleanFault_Dec(ElementDeclaration):
        literal = "LinuxVolumeNotCleanFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LinuxVolumeNotCleanFault')
            kw["aname"] = "_LinuxVolumeNotCleanFault"
            if ns0.LinuxVolumeNotClean_Def not in ns0.LinuxVolumeNotCleanFault_Dec.__bases__:
                bases = list(ns0.LinuxVolumeNotCleanFault_Dec.__bases__)
                bases.insert(0, ns0.LinuxVolumeNotClean_Def)
                ns0.LinuxVolumeNotCleanFault_Dec.__bases__ = tuple(bases)

            ns0.LinuxVolumeNotClean_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LinuxVolumeNotCleanFault_Dec_Holder"

    class LogBundlingFailedFault_Dec(ElementDeclaration):
        literal = "LogBundlingFailedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'LogBundlingFailedFault')
            kw["aname"] = "_LogBundlingFailedFault"
            if ns0.LogBundlingFailed_Def not in ns0.LogBundlingFailedFault_Dec.__bases__:
                bases = list(ns0.LogBundlingFailedFault_Dec.__bases__)
                bases.insert(0, ns0.LogBundlingFailed_Def)
                ns0.LogBundlingFailedFault_Dec.__bases__ = tuple(bases)

            ns0.LogBundlingFailed_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "LogBundlingFailedFault_Dec_Holder"

    class MaintenanceModeFileMoveFault_Dec(ElementDeclaration):
        literal = "MaintenanceModeFileMoveFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MaintenanceModeFileMoveFault')
            kw["aname"] = "_MaintenanceModeFileMoveFault"
            if ns0.MaintenanceModeFileMove_Def not in ns0.MaintenanceModeFileMoveFault_Dec.__bases__:
                bases = list(ns0.MaintenanceModeFileMoveFault_Dec.__bases__)
                bases.insert(0, ns0.MaintenanceModeFileMove_Def)
                ns0.MaintenanceModeFileMoveFault_Dec.__bases__ = tuple(bases)

            ns0.MaintenanceModeFileMove_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MaintenanceModeFileMoveFault_Dec_Holder"

    class MemorySizeNotRecommendedFault_Dec(ElementDeclaration):
        literal = "MemorySizeNotRecommendedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MemorySizeNotRecommendedFault')
            kw["aname"] = "_MemorySizeNotRecommendedFault"
            if ns0.MemorySizeNotRecommended_Def not in ns0.MemorySizeNotRecommendedFault_Dec.__bases__:
                bases = list(ns0.MemorySizeNotRecommendedFault_Dec.__bases__)
                bases.insert(0, ns0.MemorySizeNotRecommended_Def)
                ns0.MemorySizeNotRecommendedFault_Dec.__bases__ = tuple(bases)

            ns0.MemorySizeNotRecommended_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MemorySizeNotRecommendedFault_Dec_Holder"

    class MemorySizeNotSupportedFault_Dec(ElementDeclaration):
        literal = "MemorySizeNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MemorySizeNotSupportedFault')
            kw["aname"] = "_MemorySizeNotSupportedFault"
            if ns0.MemorySizeNotSupported_Def not in ns0.MemorySizeNotSupportedFault_Dec.__bases__:
                bases = list(ns0.MemorySizeNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.MemorySizeNotSupported_Def)
                ns0.MemorySizeNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.MemorySizeNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MemorySizeNotSupportedFault_Dec_Holder"

    class MemorySnapshotOnIndependentDiskFault_Dec(ElementDeclaration):
        literal = "MemorySnapshotOnIndependentDiskFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MemorySnapshotOnIndependentDiskFault')
            kw["aname"] = "_MemorySnapshotOnIndependentDiskFault"
            if ns0.MemorySnapshotOnIndependentDisk_Def not in ns0.MemorySnapshotOnIndependentDiskFault_Dec.__bases__:
                bases = list(ns0.MemorySnapshotOnIndependentDiskFault_Dec.__bases__)
                bases.insert(0, ns0.MemorySnapshotOnIndependentDisk_Def)
                ns0.MemorySnapshotOnIndependentDiskFault_Dec.__bases__ = tuple(bases)

            ns0.MemorySnapshotOnIndependentDisk_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MemorySnapshotOnIndependentDiskFault_Dec_Holder"

    class MigrationFaultFault_Dec(ElementDeclaration):
        literal = "MigrationFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MigrationFaultFault')
            kw["aname"] = "_MigrationFaultFault"
            if ns0.MigrationFault_Def not in ns0.MigrationFaultFault_Dec.__bases__:
                bases = list(ns0.MigrationFaultFault_Dec.__bases__)
                bases.insert(0, ns0.MigrationFault_Def)
                ns0.MigrationFaultFault_Dec.__bases__ = tuple(bases)

            ns0.MigrationFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MigrationFaultFault_Dec_Holder"

    class MigrationFeatureNotSupportedFault_Dec(ElementDeclaration):
        literal = "MigrationFeatureNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MigrationFeatureNotSupportedFault')
            kw["aname"] = "_MigrationFeatureNotSupportedFault"
            if ns0.MigrationFeatureNotSupported_Def not in ns0.MigrationFeatureNotSupportedFault_Dec.__bases__:
                bases = list(ns0.MigrationFeatureNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.MigrationFeatureNotSupported_Def)
                ns0.MigrationFeatureNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.MigrationFeatureNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MigrationFeatureNotSupportedFault_Dec_Holder"

    class MismatchedBundleFault_Dec(ElementDeclaration):
        literal = "MismatchedBundleFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MismatchedBundleFault')
            kw["aname"] = "_MismatchedBundleFault"
            if ns0.MismatchedBundle_Def not in ns0.MismatchedBundleFault_Dec.__bases__:
                bases = list(ns0.MismatchedBundleFault_Dec.__bases__)
                bases.insert(0, ns0.MismatchedBundle_Def)
                ns0.MismatchedBundleFault_Dec.__bases__ = tuple(bases)

            ns0.MismatchedBundle_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MismatchedBundleFault_Dec_Holder"

    class MismatchedNetworkPoliciesFault_Dec(ElementDeclaration):
        literal = "MismatchedNetworkPoliciesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MismatchedNetworkPoliciesFault')
            kw["aname"] = "_MismatchedNetworkPoliciesFault"
            if ns0.MismatchedNetworkPolicies_Def not in ns0.MismatchedNetworkPoliciesFault_Dec.__bases__:
                bases = list(ns0.MismatchedNetworkPoliciesFault_Dec.__bases__)
                bases.insert(0, ns0.MismatchedNetworkPolicies_Def)
                ns0.MismatchedNetworkPoliciesFault_Dec.__bases__ = tuple(bases)

            ns0.MismatchedNetworkPolicies_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MismatchedNetworkPoliciesFault_Dec_Holder"

    class MismatchedVMotionNetworkNamesFault_Dec(ElementDeclaration):
        literal = "MismatchedVMotionNetworkNamesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MismatchedVMotionNetworkNamesFault')
            kw["aname"] = "_MismatchedVMotionNetworkNamesFault"
            if ns0.MismatchedVMotionNetworkNames_Def not in ns0.MismatchedVMotionNetworkNamesFault_Dec.__bases__:
                bases = list(ns0.MismatchedVMotionNetworkNamesFault_Dec.__bases__)
                bases.insert(0, ns0.MismatchedVMotionNetworkNames_Def)
                ns0.MismatchedVMotionNetworkNamesFault_Dec.__bases__ = tuple(bases)

            ns0.MismatchedVMotionNetworkNames_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MismatchedVMotionNetworkNamesFault_Dec_Holder"

    class MissingControllerFault_Dec(ElementDeclaration):
        literal = "MissingControllerFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MissingControllerFault')
            kw["aname"] = "_MissingControllerFault"
            if ns0.MissingController_Def not in ns0.MissingControllerFault_Dec.__bases__:
                bases = list(ns0.MissingControllerFault_Dec.__bases__)
                bases.insert(0, ns0.MissingController_Def)
                ns0.MissingControllerFault_Dec.__bases__ = tuple(bases)

            ns0.MissingController_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MissingControllerFault_Dec_Holder"

    class MissingLinuxCustResourcesFault_Dec(ElementDeclaration):
        literal = "MissingLinuxCustResourcesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MissingLinuxCustResourcesFault')
            kw["aname"] = "_MissingLinuxCustResourcesFault"
            if ns0.MissingLinuxCustResources_Def not in ns0.MissingLinuxCustResourcesFault_Dec.__bases__:
                bases = list(ns0.MissingLinuxCustResourcesFault_Dec.__bases__)
                bases.insert(0, ns0.MissingLinuxCustResources_Def)
                ns0.MissingLinuxCustResourcesFault_Dec.__bases__ = tuple(bases)

            ns0.MissingLinuxCustResources_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MissingLinuxCustResourcesFault_Dec_Holder"

    class MissingWindowsCustResourcesFault_Dec(ElementDeclaration):
        literal = "MissingWindowsCustResourcesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MissingWindowsCustResourcesFault')
            kw["aname"] = "_MissingWindowsCustResourcesFault"
            if ns0.MissingWindowsCustResources_Def not in ns0.MissingWindowsCustResourcesFault_Dec.__bases__:
                bases = list(ns0.MissingWindowsCustResourcesFault_Dec.__bases__)
                bases.insert(0, ns0.MissingWindowsCustResources_Def)
                ns0.MissingWindowsCustResourcesFault_Dec.__bases__ = tuple(bases)

            ns0.MissingWindowsCustResources_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MissingWindowsCustResourcesFault_Dec_Holder"

    class MountErrorFault_Dec(ElementDeclaration):
        literal = "MountErrorFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MountErrorFault')
            kw["aname"] = "_MountErrorFault"
            if ns0.MountError_Def not in ns0.MountErrorFault_Dec.__bases__:
                bases = list(ns0.MountErrorFault_Dec.__bases__)
                bases.insert(0, ns0.MountError_Def)
                ns0.MountErrorFault_Dec.__bases__ = tuple(bases)

            ns0.MountError_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MountErrorFault_Dec_Holder"

    class MultipleSnapshotsNotSupportedFault_Dec(ElementDeclaration):
        literal = "MultipleSnapshotsNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'MultipleSnapshotsNotSupportedFault')
            kw["aname"] = "_MultipleSnapshotsNotSupportedFault"
            if ns0.MultipleSnapshotsNotSupported_Def not in ns0.MultipleSnapshotsNotSupportedFault_Dec.__bases__:
                bases = list(ns0.MultipleSnapshotsNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.MultipleSnapshotsNotSupported_Def)
                ns0.MultipleSnapshotsNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.MultipleSnapshotsNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "MultipleSnapshotsNotSupportedFault_Dec_Holder"

    class NetworkCopyFaultFault_Dec(ElementDeclaration):
        literal = "NetworkCopyFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NetworkCopyFaultFault')
            kw["aname"] = "_NetworkCopyFaultFault"
            if ns0.NetworkCopyFault_Def not in ns0.NetworkCopyFaultFault_Dec.__bases__:
                bases = list(ns0.NetworkCopyFaultFault_Dec.__bases__)
                bases.insert(0, ns0.NetworkCopyFault_Def)
                ns0.NetworkCopyFaultFault_Dec.__bases__ = tuple(bases)

            ns0.NetworkCopyFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NetworkCopyFaultFault_Dec_Holder"

    class NetworksMayNotBeTheSameFault_Dec(ElementDeclaration):
        literal = "NetworksMayNotBeTheSameFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NetworksMayNotBeTheSameFault')
            kw["aname"] = "_NetworksMayNotBeTheSameFault"
            if ns0.NetworksMayNotBeTheSame_Def not in ns0.NetworksMayNotBeTheSameFault_Dec.__bases__:
                bases = list(ns0.NetworksMayNotBeTheSameFault_Dec.__bases__)
                bases.insert(0, ns0.NetworksMayNotBeTheSame_Def)
                ns0.NetworksMayNotBeTheSameFault_Dec.__bases__ = tuple(bases)

            ns0.NetworksMayNotBeTheSame_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NetworksMayNotBeTheSameFault_Dec_Holder"

    class NicSettingMismatchFault_Dec(ElementDeclaration):
        literal = "NicSettingMismatchFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NicSettingMismatchFault')
            kw["aname"] = "_NicSettingMismatchFault"
            if ns0.NicSettingMismatch_Def not in ns0.NicSettingMismatchFault_Dec.__bases__:
                bases = list(ns0.NicSettingMismatchFault_Dec.__bases__)
                bases.insert(0, ns0.NicSettingMismatch_Def)
                ns0.NicSettingMismatchFault_Dec.__bases__ = tuple(bases)

            ns0.NicSettingMismatch_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NicSettingMismatchFault_Dec_Holder"

    class NoActiveHostInClusterFault_Dec(ElementDeclaration):
        literal = "NoActiveHostInClusterFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoActiveHostInClusterFault')
            kw["aname"] = "_NoActiveHostInClusterFault"
            if ns0.NoActiveHostInCluster_Def not in ns0.NoActiveHostInClusterFault_Dec.__bases__:
                bases = list(ns0.NoActiveHostInClusterFault_Dec.__bases__)
                bases.insert(0, ns0.NoActiveHostInCluster_Def)
                ns0.NoActiveHostInClusterFault_Dec.__bases__ = tuple(bases)

            ns0.NoActiveHostInCluster_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoActiveHostInClusterFault_Dec_Holder"

    class NoClientCertificateFault_Dec(ElementDeclaration):
        literal = "NoClientCertificateFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoClientCertificateFault')
            kw["aname"] = "_NoClientCertificateFault"
            if ns0.NoClientCertificate_Def not in ns0.NoClientCertificateFault_Dec.__bases__:
                bases = list(ns0.NoClientCertificateFault_Dec.__bases__)
                bases.insert(0, ns0.NoClientCertificate_Def)
                ns0.NoClientCertificateFault_Dec.__bases__ = tuple(bases)

            ns0.NoClientCertificate_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoClientCertificateFault_Dec_Holder"

    class NoDiskFoundFault_Dec(ElementDeclaration):
        literal = "NoDiskFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoDiskFoundFault')
            kw["aname"] = "_NoDiskFoundFault"
            if ns0.NoDiskFound_Def not in ns0.NoDiskFoundFault_Dec.__bases__:
                bases = list(ns0.NoDiskFoundFault_Dec.__bases__)
                bases.insert(0, ns0.NoDiskFound_Def)
                ns0.NoDiskFoundFault_Dec.__bases__ = tuple(bases)

            ns0.NoDiskFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoDiskFoundFault_Dec_Holder"

    class NoDiskSpaceFault_Dec(ElementDeclaration):
        literal = "NoDiskSpaceFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoDiskSpaceFault')
            kw["aname"] = "_NoDiskSpaceFault"
            if ns0.NoDiskSpace_Def not in ns0.NoDiskSpaceFault_Dec.__bases__:
                bases = list(ns0.NoDiskSpaceFault_Dec.__bases__)
                bases.insert(0, ns0.NoDiskSpace_Def)
                ns0.NoDiskSpaceFault_Dec.__bases__ = tuple(bases)

            ns0.NoDiskSpace_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoDiskSpaceFault_Dec_Holder"

    class NoDisksToCustomizeFault_Dec(ElementDeclaration):
        literal = "NoDisksToCustomizeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoDisksToCustomizeFault')
            kw["aname"] = "_NoDisksToCustomizeFault"
            if ns0.NoDisksToCustomize_Def not in ns0.NoDisksToCustomizeFault_Dec.__bases__:
                bases = list(ns0.NoDisksToCustomizeFault_Dec.__bases__)
                bases.insert(0, ns0.NoDisksToCustomize_Def)
                ns0.NoDisksToCustomizeFault_Dec.__bases__ = tuple(bases)

            ns0.NoDisksToCustomize_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoDisksToCustomizeFault_Dec_Holder"

    class NoGatewayFault_Dec(ElementDeclaration):
        literal = "NoGatewayFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoGatewayFault')
            kw["aname"] = "_NoGatewayFault"
            if ns0.NoGateway_Def not in ns0.NoGatewayFault_Dec.__bases__:
                bases = list(ns0.NoGatewayFault_Dec.__bases__)
                bases.insert(0, ns0.NoGateway_Def)
                ns0.NoGatewayFault_Dec.__bases__ = tuple(bases)

            ns0.NoGateway_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoGatewayFault_Dec_Holder"

    class NoGuestHeartbeatFault_Dec(ElementDeclaration):
        literal = "NoGuestHeartbeatFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoGuestHeartbeatFault')
            kw["aname"] = "_NoGuestHeartbeatFault"
            if ns0.NoGuestHeartbeat_Def not in ns0.NoGuestHeartbeatFault_Dec.__bases__:
                bases = list(ns0.NoGuestHeartbeatFault_Dec.__bases__)
                bases.insert(0, ns0.NoGuestHeartbeat_Def)
                ns0.NoGuestHeartbeatFault_Dec.__bases__ = tuple(bases)

            ns0.NoGuestHeartbeat_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoGuestHeartbeatFault_Dec_Holder"

    class NoHostFault_Dec(ElementDeclaration):
        literal = "NoHostFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoHostFault')
            kw["aname"] = "_NoHostFault"
            if ns0.NoHost_Def not in ns0.NoHostFault_Dec.__bases__:
                bases = list(ns0.NoHostFault_Dec.__bases__)
                bases.insert(0, ns0.NoHost_Def)
                ns0.NoHostFault_Dec.__bases__ = tuple(bases)

            ns0.NoHost_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoHostFault_Dec_Holder"

    class NoPeerHostFoundFault_Dec(ElementDeclaration):
        literal = "NoPeerHostFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoPeerHostFoundFault')
            kw["aname"] = "_NoPeerHostFoundFault"
            if ns0.NoPeerHostFound_Def not in ns0.NoPeerHostFoundFault_Dec.__bases__:
                bases = list(ns0.NoPeerHostFoundFault_Dec.__bases__)
                bases.insert(0, ns0.NoPeerHostFound_Def)
                ns0.NoPeerHostFoundFault_Dec.__bases__ = tuple(bases)

            ns0.NoPeerHostFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoPeerHostFoundFault_Dec_Holder"

    class NoPermissionFault_Dec(ElementDeclaration):
        literal = "NoPermissionFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoPermissionFault')
            kw["aname"] = "_NoPermissionFault"
            if ns0.NoPermission_Def not in ns0.NoPermissionFault_Dec.__bases__:
                bases = list(ns0.NoPermissionFault_Dec.__bases__)
                bases.insert(0, ns0.NoPermission_Def)
                ns0.NoPermissionFault_Dec.__bases__ = tuple(bases)

            ns0.NoPermission_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoPermissionFault_Dec_Holder"

    class NoPermissionOnHostFault_Dec(ElementDeclaration):
        literal = "NoPermissionOnHostFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoPermissionOnHostFault')
            kw["aname"] = "_NoPermissionOnHostFault"
            if ns0.NoPermissionOnHost_Def not in ns0.NoPermissionOnHostFault_Dec.__bases__:
                bases = list(ns0.NoPermissionOnHostFault_Dec.__bases__)
                bases.insert(0, ns0.NoPermissionOnHost_Def)
                ns0.NoPermissionOnHostFault_Dec.__bases__ = tuple(bases)

            ns0.NoPermissionOnHost_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoPermissionOnHostFault_Dec_Holder"

    class NoSubjectNameFault_Dec(ElementDeclaration):
        literal = "NoSubjectNameFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoSubjectNameFault')
            kw["aname"] = "_NoSubjectNameFault"
            if ns0.NoSubjectName_Def not in ns0.NoSubjectNameFault_Dec.__bases__:
                bases = list(ns0.NoSubjectNameFault_Dec.__bases__)
                bases.insert(0, ns0.NoSubjectName_Def)
                ns0.NoSubjectNameFault_Dec.__bases__ = tuple(bases)

            ns0.NoSubjectName_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoSubjectNameFault_Dec_Holder"

    class NoVirtualNicFault_Dec(ElementDeclaration):
        literal = "NoVirtualNicFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NoVirtualNicFault')
            kw["aname"] = "_NoVirtualNicFault"
            if ns0.NoVirtualNic_Def not in ns0.NoVirtualNicFault_Dec.__bases__:
                bases = list(ns0.NoVirtualNicFault_Dec.__bases__)
                bases.insert(0, ns0.NoVirtualNic_Def)
                ns0.NoVirtualNicFault_Dec.__bases__ = tuple(bases)

            ns0.NoVirtualNic_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NoVirtualNicFault_Dec_Holder"

    class NonHomeRDMVMotionNotSupportedFault_Dec(ElementDeclaration):
        literal = "NonHomeRDMVMotionNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NonHomeRDMVMotionNotSupportedFault')
            kw["aname"] = "_NonHomeRDMVMotionNotSupportedFault"
            if ns0.NonHomeRDMVMotionNotSupported_Def not in ns0.NonHomeRDMVMotionNotSupportedFault_Dec.__bases__:
                bases = list(ns0.NonHomeRDMVMotionNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.NonHomeRDMVMotionNotSupported_Def)
                ns0.NonHomeRDMVMotionNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.NonHomeRDMVMotionNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NonHomeRDMVMotionNotSupportedFault_Dec_Holder"

    class NonPersistentDisksNotSupportedFault_Dec(ElementDeclaration):
        literal = "NonPersistentDisksNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NonPersistentDisksNotSupportedFault')
            kw["aname"] = "_NonPersistentDisksNotSupportedFault"
            if ns0.NonPersistentDisksNotSupported_Def not in ns0.NonPersistentDisksNotSupportedFault_Dec.__bases__:
                bases = list(ns0.NonPersistentDisksNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.NonPersistentDisksNotSupported_Def)
                ns0.NonPersistentDisksNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.NonPersistentDisksNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NonPersistentDisksNotSupportedFault_Dec_Holder"

    class NotAuthenticatedFault_Dec(ElementDeclaration):
        literal = "NotAuthenticatedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotAuthenticatedFault')
            kw["aname"] = "_NotAuthenticatedFault"
            if ns0.NotAuthenticated_Def not in ns0.NotAuthenticatedFault_Dec.__bases__:
                bases = list(ns0.NotAuthenticatedFault_Dec.__bases__)
                bases.insert(0, ns0.NotAuthenticated_Def)
                ns0.NotAuthenticatedFault_Dec.__bases__ = tuple(bases)

            ns0.NotAuthenticated_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotAuthenticatedFault_Dec_Holder"

    class NotEnoughCpusFault_Dec(ElementDeclaration):
        literal = "NotEnoughCpusFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotEnoughCpusFault')
            kw["aname"] = "_NotEnoughCpusFault"
            if ns0.NotEnoughCpus_Def not in ns0.NotEnoughCpusFault_Dec.__bases__:
                bases = list(ns0.NotEnoughCpusFault_Dec.__bases__)
                bases.insert(0, ns0.NotEnoughCpus_Def)
                ns0.NotEnoughCpusFault_Dec.__bases__ = tuple(bases)

            ns0.NotEnoughCpus_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotEnoughCpusFault_Dec_Holder"

    class NotEnoughLogicalCpusFault_Dec(ElementDeclaration):
        literal = "NotEnoughLogicalCpusFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotEnoughLogicalCpusFault')
            kw["aname"] = "_NotEnoughLogicalCpusFault"
            if ns0.NotEnoughLogicalCpus_Def not in ns0.NotEnoughLogicalCpusFault_Dec.__bases__:
                bases = list(ns0.NotEnoughLogicalCpusFault_Dec.__bases__)
                bases.insert(0, ns0.NotEnoughLogicalCpus_Def)
                ns0.NotEnoughLogicalCpusFault_Dec.__bases__ = tuple(bases)

            ns0.NotEnoughLogicalCpus_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotEnoughLogicalCpusFault_Dec_Holder"

    class NotFoundFault_Dec(ElementDeclaration):
        literal = "NotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotFoundFault')
            kw["aname"] = "_NotFoundFault"
            if ns0.NotFound_Def not in ns0.NotFoundFault_Dec.__bases__:
                bases = list(ns0.NotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.NotFound_Def)
                ns0.NotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.NotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotFoundFault_Dec_Holder"

    class NotSupportedHostFault_Dec(ElementDeclaration):
        literal = "NotSupportedHostFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NotSupportedHostFault')
            kw["aname"] = "_NotSupportedHostFault"
            if ns0.NotSupportedHost_Def not in ns0.NotSupportedHostFault_Dec.__bases__:
                bases = list(ns0.NotSupportedHostFault_Dec.__bases__)
                bases.insert(0, ns0.NotSupportedHost_Def)
                ns0.NotSupportedHostFault_Dec.__bases__ = tuple(bases)

            ns0.NotSupportedHost_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NotSupportedHostFault_Dec_Holder"

    class NumVirtualCpusNotSupportedFault_Dec(ElementDeclaration):
        literal = "NumVirtualCpusNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'NumVirtualCpusNotSupportedFault')
            kw["aname"] = "_NumVirtualCpusNotSupportedFault"
            if ns0.NumVirtualCpusNotSupported_Def not in ns0.NumVirtualCpusNotSupportedFault_Dec.__bases__:
                bases = list(ns0.NumVirtualCpusNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.NumVirtualCpusNotSupported_Def)
                ns0.NumVirtualCpusNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.NumVirtualCpusNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "NumVirtualCpusNotSupportedFault_Dec_Holder"

    class OutOfBoundsFault_Dec(ElementDeclaration):
        literal = "OutOfBoundsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'OutOfBoundsFault')
            kw["aname"] = "_OutOfBoundsFault"
            if ns0.OutOfBounds_Def not in ns0.OutOfBoundsFault_Dec.__bases__:
                bases = list(ns0.OutOfBoundsFault_Dec.__bases__)
                bases.insert(0, ns0.OutOfBounds_Def)
                ns0.OutOfBoundsFault_Dec.__bases__ = tuple(bases)

            ns0.OutOfBounds_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "OutOfBoundsFault_Dec_Holder"

    class PatchAlreadyInstalledFault_Dec(ElementDeclaration):
        literal = "PatchAlreadyInstalledFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchAlreadyInstalledFault')
            kw["aname"] = "_PatchAlreadyInstalledFault"
            if ns0.PatchAlreadyInstalled_Def not in ns0.PatchAlreadyInstalledFault_Dec.__bases__:
                bases = list(ns0.PatchAlreadyInstalledFault_Dec.__bases__)
                bases.insert(0, ns0.PatchAlreadyInstalled_Def)
                ns0.PatchAlreadyInstalledFault_Dec.__bases__ = tuple(bases)

            ns0.PatchAlreadyInstalled_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchAlreadyInstalledFault_Dec_Holder"

    class PatchBinariesNotFoundFault_Dec(ElementDeclaration):
        literal = "PatchBinariesNotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchBinariesNotFoundFault')
            kw["aname"] = "_PatchBinariesNotFoundFault"
            if ns0.PatchBinariesNotFound_Def not in ns0.PatchBinariesNotFoundFault_Dec.__bases__:
                bases = list(ns0.PatchBinariesNotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.PatchBinariesNotFound_Def)
                ns0.PatchBinariesNotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.PatchBinariesNotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchBinariesNotFoundFault_Dec_Holder"

    class PatchInstallFailedFault_Dec(ElementDeclaration):
        literal = "PatchInstallFailedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchInstallFailedFault')
            kw["aname"] = "_PatchInstallFailedFault"
            if ns0.PatchInstallFailed_Def not in ns0.PatchInstallFailedFault_Dec.__bases__:
                bases = list(ns0.PatchInstallFailedFault_Dec.__bases__)
                bases.insert(0, ns0.PatchInstallFailed_Def)
                ns0.PatchInstallFailedFault_Dec.__bases__ = tuple(bases)

            ns0.PatchInstallFailed_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchInstallFailedFault_Dec_Holder"

    class PatchIntegrityErrorFault_Dec(ElementDeclaration):
        literal = "PatchIntegrityErrorFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchIntegrityErrorFault')
            kw["aname"] = "_PatchIntegrityErrorFault"
            if ns0.PatchIntegrityError_Def not in ns0.PatchIntegrityErrorFault_Dec.__bases__:
                bases = list(ns0.PatchIntegrityErrorFault_Dec.__bases__)
                bases.insert(0, ns0.PatchIntegrityError_Def)
                ns0.PatchIntegrityErrorFault_Dec.__bases__ = tuple(bases)

            ns0.PatchIntegrityError_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchIntegrityErrorFault_Dec_Holder"

    class PatchMetadataCorruptedFault_Dec(ElementDeclaration):
        literal = "PatchMetadataCorruptedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchMetadataCorruptedFault')
            kw["aname"] = "_PatchMetadataCorruptedFault"
            if ns0.PatchMetadataCorrupted_Def not in ns0.PatchMetadataCorruptedFault_Dec.__bases__:
                bases = list(ns0.PatchMetadataCorruptedFault_Dec.__bases__)
                bases.insert(0, ns0.PatchMetadataCorrupted_Def)
                ns0.PatchMetadataCorruptedFault_Dec.__bases__ = tuple(bases)

            ns0.PatchMetadataCorrupted_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchMetadataCorruptedFault_Dec_Holder"

    class PatchMetadataInvalidFault_Dec(ElementDeclaration):
        literal = "PatchMetadataInvalidFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchMetadataInvalidFault')
            kw["aname"] = "_PatchMetadataInvalidFault"
            if ns0.PatchMetadataInvalid_Def not in ns0.PatchMetadataInvalidFault_Dec.__bases__:
                bases = list(ns0.PatchMetadataInvalidFault_Dec.__bases__)
                bases.insert(0, ns0.PatchMetadataInvalid_Def)
                ns0.PatchMetadataInvalidFault_Dec.__bases__ = tuple(bases)

            ns0.PatchMetadataInvalid_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchMetadataInvalidFault_Dec_Holder"

    class PatchMetadataNotFoundFault_Dec(ElementDeclaration):
        literal = "PatchMetadataNotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchMetadataNotFoundFault')
            kw["aname"] = "_PatchMetadataNotFoundFault"
            if ns0.PatchMetadataNotFound_Def not in ns0.PatchMetadataNotFoundFault_Dec.__bases__:
                bases = list(ns0.PatchMetadataNotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.PatchMetadataNotFound_Def)
                ns0.PatchMetadataNotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.PatchMetadataNotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchMetadataNotFoundFault_Dec_Holder"

    class PatchMissingDependenciesFault_Dec(ElementDeclaration):
        literal = "PatchMissingDependenciesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchMissingDependenciesFault')
            kw["aname"] = "_PatchMissingDependenciesFault"
            if ns0.PatchMissingDependencies_Def not in ns0.PatchMissingDependenciesFault_Dec.__bases__:
                bases = list(ns0.PatchMissingDependenciesFault_Dec.__bases__)
                bases.insert(0, ns0.PatchMissingDependencies_Def)
                ns0.PatchMissingDependenciesFault_Dec.__bases__ = tuple(bases)

            ns0.PatchMissingDependencies_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchMissingDependenciesFault_Dec_Holder"

    class PatchNotApplicableFault_Dec(ElementDeclaration):
        literal = "PatchNotApplicableFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchNotApplicableFault')
            kw["aname"] = "_PatchNotApplicableFault"
            if ns0.PatchNotApplicable_Def not in ns0.PatchNotApplicableFault_Dec.__bases__:
                bases = list(ns0.PatchNotApplicableFault_Dec.__bases__)
                bases.insert(0, ns0.PatchNotApplicable_Def)
                ns0.PatchNotApplicableFault_Dec.__bases__ = tuple(bases)

            ns0.PatchNotApplicable_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchNotApplicableFault_Dec_Holder"

    class PatchSupersededFault_Dec(ElementDeclaration):
        literal = "PatchSupersededFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PatchSupersededFault')
            kw["aname"] = "_PatchSupersededFault"
            if ns0.PatchSuperseded_Def not in ns0.PatchSupersededFault_Dec.__bases__:
                bases = list(ns0.PatchSupersededFault_Dec.__bases__)
                bases.insert(0, ns0.PatchSuperseded_Def)
                ns0.PatchSupersededFault_Dec.__bases__ = tuple(bases)

            ns0.PatchSuperseded_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PatchSupersededFault_Dec_Holder"

    class PhysCompatRDMNotSupportedFault_Dec(ElementDeclaration):
        literal = "PhysCompatRDMNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PhysCompatRDMNotSupportedFault')
            kw["aname"] = "_PhysCompatRDMNotSupportedFault"
            if ns0.PhysCompatRDMNotSupported_Def not in ns0.PhysCompatRDMNotSupportedFault_Dec.__bases__:
                bases = list(ns0.PhysCompatRDMNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.PhysCompatRDMNotSupported_Def)
                ns0.PhysCompatRDMNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.PhysCompatRDMNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PhysCompatRDMNotSupportedFault_Dec_Holder"

    class PlatformConfigFaultFault_Dec(ElementDeclaration):
        literal = "PlatformConfigFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'PlatformConfigFaultFault')
            kw["aname"] = "_PlatformConfigFaultFault"
            if ns0.PlatformConfigFault_Def not in ns0.PlatformConfigFaultFault_Dec.__bases__:
                bases = list(ns0.PlatformConfigFaultFault_Dec.__bases__)
                bases.insert(0, ns0.PlatformConfigFault_Def)
                ns0.PlatformConfigFaultFault_Dec.__bases__ = tuple(bases)

            ns0.PlatformConfigFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "PlatformConfigFaultFault_Dec_Holder"

    class RDMNotPreservedFault_Dec(ElementDeclaration):
        literal = "RDMNotPreservedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RDMNotPreservedFault')
            kw["aname"] = "_RDMNotPreservedFault"
            if ns0.RDMNotPreserved_Def not in ns0.RDMNotPreservedFault_Dec.__bases__:
                bases = list(ns0.RDMNotPreservedFault_Dec.__bases__)
                bases.insert(0, ns0.RDMNotPreserved_Def)
                ns0.RDMNotPreservedFault_Dec.__bases__ = tuple(bases)

            ns0.RDMNotPreserved_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RDMNotPreservedFault_Dec_Holder"

    class RDMNotSupportedFault_Dec(ElementDeclaration):
        literal = "RDMNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RDMNotSupportedFault')
            kw["aname"] = "_RDMNotSupportedFault"
            if ns0.RDMNotSupported_Def not in ns0.RDMNotSupportedFault_Dec.__bases__:
                bases = list(ns0.RDMNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.RDMNotSupported_Def)
                ns0.RDMNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.RDMNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RDMNotSupportedFault_Dec_Holder"

    class RDMNotSupportedOnDatastoreFault_Dec(ElementDeclaration):
        literal = "RDMNotSupportedOnDatastoreFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RDMNotSupportedOnDatastoreFault')
            kw["aname"] = "_RDMNotSupportedOnDatastoreFault"
            if ns0.RDMNotSupportedOnDatastore_Def not in ns0.RDMNotSupportedOnDatastoreFault_Dec.__bases__:
                bases = list(ns0.RDMNotSupportedOnDatastoreFault_Dec.__bases__)
                bases.insert(0, ns0.RDMNotSupportedOnDatastore_Def)
                ns0.RDMNotSupportedOnDatastoreFault_Dec.__bases__ = tuple(bases)

            ns0.RDMNotSupportedOnDatastore_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RDMNotSupportedOnDatastoreFault_Dec_Holder"

    class RDMPointsToInaccessibleDiskFault_Dec(ElementDeclaration):
        literal = "RDMPointsToInaccessibleDiskFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RDMPointsToInaccessibleDiskFault')
            kw["aname"] = "_RDMPointsToInaccessibleDiskFault"
            if ns0.RDMPointsToInaccessibleDisk_Def not in ns0.RDMPointsToInaccessibleDiskFault_Dec.__bases__:
                bases = list(ns0.RDMPointsToInaccessibleDiskFault_Dec.__bases__)
                bases.insert(0, ns0.RDMPointsToInaccessibleDisk_Def)
                ns0.RDMPointsToInaccessibleDiskFault_Dec.__bases__ = tuple(bases)

            ns0.RDMPointsToInaccessibleDisk_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RDMPointsToInaccessibleDiskFault_Dec_Holder"

    class RawDiskNotSupportedFault_Dec(ElementDeclaration):
        literal = "RawDiskNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RawDiskNotSupportedFault')
            kw["aname"] = "_RawDiskNotSupportedFault"
            if ns0.RawDiskNotSupported_Def not in ns0.RawDiskNotSupportedFault_Dec.__bases__:
                bases = list(ns0.RawDiskNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.RawDiskNotSupported_Def)
                ns0.RawDiskNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.RawDiskNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RawDiskNotSupportedFault_Dec_Holder"

    class ReadOnlyDisksWithLegacyDestinationFault_Dec(ElementDeclaration):
        literal = "ReadOnlyDisksWithLegacyDestinationFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReadOnlyDisksWithLegacyDestinationFault')
            kw["aname"] = "_ReadOnlyDisksWithLegacyDestinationFault"
            if ns0.ReadOnlyDisksWithLegacyDestination_Def not in ns0.ReadOnlyDisksWithLegacyDestinationFault_Dec.__bases__:
                bases = list(ns0.ReadOnlyDisksWithLegacyDestinationFault_Dec.__bases__)
                bases.insert(0, ns0.ReadOnlyDisksWithLegacyDestination_Def)
                ns0.ReadOnlyDisksWithLegacyDestinationFault_Dec.__bases__ = tuple(bases)

            ns0.ReadOnlyDisksWithLegacyDestination_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReadOnlyDisksWithLegacyDestinationFault_Dec_Holder"

    class RebootRequiredFault_Dec(ElementDeclaration):
        literal = "RebootRequiredFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RebootRequiredFault')
            kw["aname"] = "_RebootRequiredFault"
            if ns0.RebootRequired_Def not in ns0.RebootRequiredFault_Dec.__bases__:
                bases = list(ns0.RebootRequiredFault_Dec.__bases__)
                bases.insert(0, ns0.RebootRequired_Def)
                ns0.RebootRequiredFault_Dec.__bases__ = tuple(bases)

            ns0.RebootRequired_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RebootRequiredFault_Dec_Holder"

    class RemoteDeviceNotSupportedFault_Dec(ElementDeclaration):
        literal = "RemoteDeviceNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoteDeviceNotSupportedFault')
            kw["aname"] = "_RemoteDeviceNotSupportedFault"
            if ns0.RemoteDeviceNotSupported_Def not in ns0.RemoteDeviceNotSupportedFault_Dec.__bases__:
                bases = list(ns0.RemoteDeviceNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.RemoteDeviceNotSupported_Def)
                ns0.RemoteDeviceNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.RemoteDeviceNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoteDeviceNotSupportedFault_Dec_Holder"

    class RemoveFailedFault_Dec(ElementDeclaration):
        literal = "RemoveFailedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveFailedFault')
            kw["aname"] = "_RemoveFailedFault"
            if ns0.RemoveFailed_Def not in ns0.RemoveFailedFault_Dec.__bases__:
                bases = list(ns0.RemoveFailedFault_Dec.__bases__)
                bases.insert(0, ns0.RemoveFailed_Def)
                ns0.RemoveFailedFault_Dec.__bases__ = tuple(bases)

            ns0.RemoveFailed_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveFailedFault_Dec_Holder"

    class ResourceInUseFault_Dec(ElementDeclaration):
        literal = "ResourceInUseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResourceInUseFault')
            kw["aname"] = "_ResourceInUseFault"
            if ns0.ResourceInUse_Def not in ns0.ResourceInUseFault_Dec.__bases__:
                bases = list(ns0.ResourceInUseFault_Dec.__bases__)
                bases.insert(0, ns0.ResourceInUse_Def)
                ns0.ResourceInUseFault_Dec.__bases__ = tuple(bases)

            ns0.ResourceInUse_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResourceInUseFault_Dec_Holder"

    class RestrictedVersionFault_Dec(ElementDeclaration):
        literal = "RestrictedVersionFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RestrictedVersionFault')
            kw["aname"] = "_RestrictedVersionFault"
            if ns0.RestrictedVersion_Def not in ns0.RestrictedVersionFault_Dec.__bases__:
                bases = list(ns0.RestrictedVersionFault_Dec.__bases__)
                bases.insert(0, ns0.RestrictedVersion_Def)
                ns0.RestrictedVersionFault_Dec.__bases__ = tuple(bases)

            ns0.RestrictedVersion_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RestrictedVersionFault_Dec_Holder"

    class RuleViolationFault_Dec(ElementDeclaration):
        literal = "RuleViolationFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RuleViolationFault')
            kw["aname"] = "_RuleViolationFault"
            if ns0.RuleViolation_Def not in ns0.RuleViolationFault_Dec.__bases__:
                bases = list(ns0.RuleViolationFault_Dec.__bases__)
                bases.insert(0, ns0.RuleViolation_Def)
                ns0.RuleViolationFault_Dec.__bases__ = tuple(bases)

            ns0.RuleViolation_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RuleViolationFault_Dec_Holder"

    class SSLVerifyFaultFault_Dec(ElementDeclaration):
        literal = "SSLVerifyFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SSLVerifyFaultFault')
            kw["aname"] = "_SSLVerifyFaultFault"
            if ns0.SSLVerifyFault_Def not in ns0.SSLVerifyFaultFault_Dec.__bases__:
                bases = list(ns0.SSLVerifyFaultFault_Dec.__bases__)
                bases.insert(0, ns0.SSLVerifyFault_Def)
                ns0.SSLVerifyFaultFault_Dec.__bases__ = tuple(bases)

            ns0.SSLVerifyFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SSLVerifyFaultFault_Dec_Holder"

    class SSPIChallengeFault_Dec(ElementDeclaration):
        literal = "SSPIChallengeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SSPIChallengeFault')
            kw["aname"] = "_SSPIChallengeFault"
            if ns0.SSPIChallenge_Def not in ns0.SSPIChallengeFault_Dec.__bases__:
                bases = list(ns0.SSPIChallengeFault_Dec.__bases__)
                bases.insert(0, ns0.SSPIChallenge_Def)
                ns0.SSPIChallengeFault_Dec.__bases__ = tuple(bases)

            ns0.SSPIChallenge_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SSPIChallengeFault_Dec_Holder"

    class SharedBusControllerNotSupportedFault_Dec(ElementDeclaration):
        literal = "SharedBusControllerNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SharedBusControllerNotSupportedFault')
            kw["aname"] = "_SharedBusControllerNotSupportedFault"
            if ns0.SharedBusControllerNotSupported_Def not in ns0.SharedBusControllerNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SharedBusControllerNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SharedBusControllerNotSupported_Def)
                ns0.SharedBusControllerNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SharedBusControllerNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SharedBusControllerNotSupportedFault_Dec_Holder"

    class SnapshotCloneNotSupportedFault_Dec(ElementDeclaration):
        literal = "SnapshotCloneNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotCloneNotSupportedFault')
            kw["aname"] = "_SnapshotCloneNotSupportedFault"
            if ns0.SnapshotCloneNotSupported_Def not in ns0.SnapshotCloneNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SnapshotCloneNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotCloneNotSupported_Def)
                ns0.SnapshotCloneNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotCloneNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotCloneNotSupportedFault_Dec_Holder"

    class SnapshotCopyNotSupportedFault_Dec(ElementDeclaration):
        literal = "SnapshotCopyNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotCopyNotSupportedFault')
            kw["aname"] = "_SnapshotCopyNotSupportedFault"
            if ns0.SnapshotCopyNotSupported_Def not in ns0.SnapshotCopyNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SnapshotCopyNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotCopyNotSupported_Def)
                ns0.SnapshotCopyNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotCopyNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotCopyNotSupportedFault_Dec_Holder"

    class SnapshotDisabledFault_Dec(ElementDeclaration):
        literal = "SnapshotDisabledFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotDisabledFault')
            kw["aname"] = "_SnapshotDisabledFault"
            if ns0.SnapshotDisabled_Def not in ns0.SnapshotDisabledFault_Dec.__bases__:
                bases = list(ns0.SnapshotDisabledFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotDisabled_Def)
                ns0.SnapshotDisabledFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotDisabled_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotDisabledFault_Dec_Holder"

    class SnapshotFaultFault_Dec(ElementDeclaration):
        literal = "SnapshotFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotFaultFault')
            kw["aname"] = "_SnapshotFaultFault"
            if ns0.SnapshotFault_Def not in ns0.SnapshotFaultFault_Dec.__bases__:
                bases = list(ns0.SnapshotFaultFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotFault_Def)
                ns0.SnapshotFaultFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotFaultFault_Dec_Holder"

    class SnapshotIncompatibleDeviceInVmFault_Dec(ElementDeclaration):
        literal = "SnapshotIncompatibleDeviceInVmFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotIncompatibleDeviceInVmFault')
            kw["aname"] = "_SnapshotIncompatibleDeviceInVmFault"
            if ns0.SnapshotIncompatibleDeviceInVm_Def not in ns0.SnapshotIncompatibleDeviceInVmFault_Dec.__bases__:
                bases = list(ns0.SnapshotIncompatibleDeviceInVmFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotIncompatibleDeviceInVm_Def)
                ns0.SnapshotIncompatibleDeviceInVmFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotIncompatibleDeviceInVm_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotIncompatibleDeviceInVmFault_Dec_Holder"

    class SnapshotLockedFault_Dec(ElementDeclaration):
        literal = "SnapshotLockedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotLockedFault')
            kw["aname"] = "_SnapshotLockedFault"
            if ns0.SnapshotLocked_Def not in ns0.SnapshotLockedFault_Dec.__bases__:
                bases = list(ns0.SnapshotLockedFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotLocked_Def)
                ns0.SnapshotLockedFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotLocked_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotLockedFault_Dec_Holder"

    class SnapshotMoveFromNonHomeNotSupportedFault_Dec(ElementDeclaration):
        literal = "SnapshotMoveFromNonHomeNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotMoveFromNonHomeNotSupportedFault')
            kw["aname"] = "_SnapshotMoveFromNonHomeNotSupportedFault"
            if ns0.SnapshotMoveFromNonHomeNotSupported_Def not in ns0.SnapshotMoveFromNonHomeNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SnapshotMoveFromNonHomeNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotMoveFromNonHomeNotSupported_Def)
                ns0.SnapshotMoveFromNonHomeNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotMoveFromNonHomeNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotMoveFromNonHomeNotSupportedFault_Dec_Holder"

    class SnapshotMoveNotSupportedFault_Dec(ElementDeclaration):
        literal = "SnapshotMoveNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotMoveNotSupportedFault')
            kw["aname"] = "_SnapshotMoveNotSupportedFault"
            if ns0.SnapshotMoveNotSupported_Def not in ns0.SnapshotMoveNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SnapshotMoveNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotMoveNotSupported_Def)
                ns0.SnapshotMoveNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotMoveNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotMoveNotSupportedFault_Dec_Holder"

    class SnapshotMoveToNonHomeNotSupportedFault_Dec(ElementDeclaration):
        literal = "SnapshotMoveToNonHomeNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotMoveToNonHomeNotSupportedFault')
            kw["aname"] = "_SnapshotMoveToNonHomeNotSupportedFault"
            if ns0.SnapshotMoveToNonHomeNotSupported_Def not in ns0.SnapshotMoveToNonHomeNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SnapshotMoveToNonHomeNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotMoveToNonHomeNotSupported_Def)
                ns0.SnapshotMoveToNonHomeNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotMoveToNonHomeNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotMoveToNonHomeNotSupportedFault_Dec_Holder"

    class SnapshotNoChangeFault_Dec(ElementDeclaration):
        literal = "SnapshotNoChangeFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotNoChangeFault')
            kw["aname"] = "_SnapshotNoChangeFault"
            if ns0.SnapshotNoChange_Def not in ns0.SnapshotNoChangeFault_Dec.__bases__:
                bases = list(ns0.SnapshotNoChangeFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotNoChange_Def)
                ns0.SnapshotNoChangeFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotNoChange_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotNoChangeFault_Dec_Holder"

    class SnapshotRevertIssueFault_Dec(ElementDeclaration):
        literal = "SnapshotRevertIssueFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SnapshotRevertIssueFault')
            kw["aname"] = "_SnapshotRevertIssueFault"
            if ns0.SnapshotRevertIssue_Def not in ns0.SnapshotRevertIssueFault_Dec.__bases__:
                bases = list(ns0.SnapshotRevertIssueFault_Dec.__bases__)
                bases.insert(0, ns0.SnapshotRevertIssue_Def)
                ns0.SnapshotRevertIssueFault_Dec.__bases__ = tuple(bases)

            ns0.SnapshotRevertIssue_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SnapshotRevertIssueFault_Dec_Holder"

    class SuspendedRelocateNotSupportedFault_Dec(ElementDeclaration):
        literal = "SuspendedRelocateNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SuspendedRelocateNotSupportedFault')
            kw["aname"] = "_SuspendedRelocateNotSupportedFault"
            if ns0.SuspendedRelocateNotSupported_Def not in ns0.SuspendedRelocateNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SuspendedRelocateNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SuspendedRelocateNotSupported_Def)
                ns0.SuspendedRelocateNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SuspendedRelocateNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SuspendedRelocateNotSupportedFault_Dec_Holder"

    class SwapDatastoreNotWritableOnHostFault_Dec(ElementDeclaration):
        literal = "SwapDatastoreNotWritableOnHostFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SwapDatastoreNotWritableOnHostFault')
            kw["aname"] = "_SwapDatastoreNotWritableOnHostFault"
            if ns0.SwapDatastoreNotWritableOnHost_Def not in ns0.SwapDatastoreNotWritableOnHostFault_Dec.__bases__:
                bases = list(ns0.SwapDatastoreNotWritableOnHostFault_Dec.__bases__)
                bases.insert(0, ns0.SwapDatastoreNotWritableOnHost_Def)
                ns0.SwapDatastoreNotWritableOnHostFault_Dec.__bases__ = tuple(bases)

            ns0.SwapDatastoreNotWritableOnHost_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SwapDatastoreNotWritableOnHostFault_Dec_Holder"

    class SwapDatastoreUnsetFault_Dec(ElementDeclaration):
        literal = "SwapDatastoreUnsetFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SwapDatastoreUnsetFault')
            kw["aname"] = "_SwapDatastoreUnsetFault"
            if ns0.SwapDatastoreUnset_Def not in ns0.SwapDatastoreUnsetFault_Dec.__bases__:
                bases = list(ns0.SwapDatastoreUnsetFault_Dec.__bases__)
                bases.insert(0, ns0.SwapDatastoreUnset_Def)
                ns0.SwapDatastoreUnsetFault_Dec.__bases__ = tuple(bases)

            ns0.SwapDatastoreUnset_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SwapDatastoreUnsetFault_Dec_Holder"

    class SwapPlacementOverrideNotSupportedFault_Dec(ElementDeclaration):
        literal = "SwapPlacementOverrideNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SwapPlacementOverrideNotSupportedFault')
            kw["aname"] = "_SwapPlacementOverrideNotSupportedFault"
            if ns0.SwapPlacementOverrideNotSupported_Def not in ns0.SwapPlacementOverrideNotSupportedFault_Dec.__bases__:
                bases = list(ns0.SwapPlacementOverrideNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.SwapPlacementOverrideNotSupported_Def)
                ns0.SwapPlacementOverrideNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.SwapPlacementOverrideNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SwapPlacementOverrideNotSupportedFault_Dec_Holder"

    class TaskInProgressFault_Dec(ElementDeclaration):
        literal = "TaskInProgressFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TaskInProgressFault')
            kw["aname"] = "_TaskInProgressFault"
            if ns0.TaskInProgress_Def not in ns0.TaskInProgressFault_Dec.__bases__:
                bases = list(ns0.TaskInProgressFault_Dec.__bases__)
                bases.insert(0, ns0.TaskInProgress_Def)
                ns0.TaskInProgressFault_Dec.__bases__ = tuple(bases)

            ns0.TaskInProgress_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TaskInProgressFault_Dec_Holder"

    class TimedoutFault_Dec(ElementDeclaration):
        literal = "TimedoutFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TimedoutFault')
            kw["aname"] = "_TimedoutFault"
            if ns0.Timedout_Def not in ns0.TimedoutFault_Dec.__bases__:
                bases = list(ns0.TimedoutFault_Dec.__bases__)
                bases.insert(0, ns0.Timedout_Def)
                ns0.TimedoutFault_Dec.__bases__ = tuple(bases)

            ns0.Timedout_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TimedoutFault_Dec_Holder"

    class TooManyConsecutiveOverridesFault_Dec(ElementDeclaration):
        literal = "TooManyConsecutiveOverridesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TooManyConsecutiveOverridesFault')
            kw["aname"] = "_TooManyConsecutiveOverridesFault"
            if ns0.TooManyConsecutiveOverrides_Def not in ns0.TooManyConsecutiveOverridesFault_Dec.__bases__:
                bases = list(ns0.TooManyConsecutiveOverridesFault_Dec.__bases__)
                bases.insert(0, ns0.TooManyConsecutiveOverrides_Def)
                ns0.TooManyConsecutiveOverridesFault_Dec.__bases__ = tuple(bases)

            ns0.TooManyConsecutiveOverrides_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TooManyConsecutiveOverridesFault_Dec_Holder"

    class TooManyDevicesFault_Dec(ElementDeclaration):
        literal = "TooManyDevicesFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TooManyDevicesFault')
            kw["aname"] = "_TooManyDevicesFault"
            if ns0.TooManyDevices_Def not in ns0.TooManyDevicesFault_Dec.__bases__:
                bases = list(ns0.TooManyDevicesFault_Dec.__bases__)
                bases.insert(0, ns0.TooManyDevices_Def)
                ns0.TooManyDevicesFault_Dec.__bases__ = tuple(bases)

            ns0.TooManyDevices_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TooManyDevicesFault_Dec_Holder"

    class TooManyDisksOnLegacyHostFault_Dec(ElementDeclaration):
        literal = "TooManyDisksOnLegacyHostFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TooManyDisksOnLegacyHostFault')
            kw["aname"] = "_TooManyDisksOnLegacyHostFault"
            if ns0.TooManyDisksOnLegacyHost_Def not in ns0.TooManyDisksOnLegacyHostFault_Dec.__bases__:
                bases = list(ns0.TooManyDisksOnLegacyHostFault_Dec.__bases__)
                bases.insert(0, ns0.TooManyDisksOnLegacyHost_Def)
                ns0.TooManyDisksOnLegacyHostFault_Dec.__bases__ = tuple(bases)

            ns0.TooManyDisksOnLegacyHost_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TooManyDisksOnLegacyHostFault_Dec_Holder"

    class TooManyHostsFault_Dec(ElementDeclaration):
        literal = "TooManyHostsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TooManyHostsFault')
            kw["aname"] = "_TooManyHostsFault"
            if ns0.TooManyHosts_Def not in ns0.TooManyHostsFault_Dec.__bases__:
                bases = list(ns0.TooManyHostsFault_Dec.__bases__)
                bases.insert(0, ns0.TooManyHosts_Def)
                ns0.TooManyHostsFault_Dec.__bases__ = tuple(bases)

            ns0.TooManyHosts_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TooManyHostsFault_Dec_Holder"

    class TooManySnapshotLevelsFault_Dec(ElementDeclaration):
        literal = "TooManySnapshotLevelsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'TooManySnapshotLevelsFault')
            kw["aname"] = "_TooManySnapshotLevelsFault"
            if ns0.TooManySnapshotLevels_Def not in ns0.TooManySnapshotLevelsFault_Dec.__bases__:
                bases = list(ns0.TooManySnapshotLevelsFault_Dec.__bases__)
                bases.insert(0, ns0.TooManySnapshotLevels_Def)
                ns0.TooManySnapshotLevelsFault_Dec.__bases__ = tuple(bases)

            ns0.TooManySnapshotLevels_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "TooManySnapshotLevelsFault_Dec_Holder"

    class ToolsUnavailableFault_Dec(ElementDeclaration):
        literal = "ToolsUnavailableFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ToolsUnavailableFault')
            kw["aname"] = "_ToolsUnavailableFault"
            if ns0.ToolsUnavailable_Def not in ns0.ToolsUnavailableFault_Dec.__bases__:
                bases = list(ns0.ToolsUnavailableFault_Dec.__bases__)
                bases.insert(0, ns0.ToolsUnavailable_Def)
                ns0.ToolsUnavailableFault_Dec.__bases__ = tuple(bases)

            ns0.ToolsUnavailable_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ToolsUnavailableFault_Dec_Holder"

    class UncommittedUndoableDiskFault_Dec(ElementDeclaration):
        literal = "UncommittedUndoableDiskFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UncommittedUndoableDiskFault')
            kw["aname"] = "_UncommittedUndoableDiskFault"
            if ns0.UncommittedUndoableDisk_Def not in ns0.UncommittedUndoableDiskFault_Dec.__bases__:
                bases = list(ns0.UncommittedUndoableDiskFault_Dec.__bases__)
                bases.insert(0, ns0.UncommittedUndoableDisk_Def)
                ns0.UncommittedUndoableDiskFault_Dec.__bases__ = tuple(bases)

            ns0.UncommittedUndoableDisk_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UncommittedUndoableDiskFault_Dec_Holder"

    class UncustomizableGuestFault_Dec(ElementDeclaration):
        literal = "UncustomizableGuestFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UncustomizableGuestFault')
            kw["aname"] = "_UncustomizableGuestFault"
            if ns0.UncustomizableGuest_Def not in ns0.UncustomizableGuestFault_Dec.__bases__:
                bases = list(ns0.UncustomizableGuestFault_Dec.__bases__)
                bases.insert(0, ns0.UncustomizableGuest_Def)
                ns0.UncustomizableGuestFault_Dec.__bases__ = tuple(bases)

            ns0.UncustomizableGuest_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UncustomizableGuestFault_Dec_Holder"

    class UnexpectedCustomizationFaultFault_Dec(ElementDeclaration):
        literal = "UnexpectedCustomizationFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnexpectedCustomizationFaultFault')
            kw["aname"] = "_UnexpectedCustomizationFaultFault"
            if ns0.UnexpectedCustomizationFault_Def not in ns0.UnexpectedCustomizationFaultFault_Dec.__bases__:
                bases = list(ns0.UnexpectedCustomizationFaultFault_Dec.__bases__)
                bases.insert(0, ns0.UnexpectedCustomizationFault_Def)
                ns0.UnexpectedCustomizationFaultFault_Dec.__bases__ = tuple(bases)

            ns0.UnexpectedCustomizationFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnexpectedCustomizationFaultFault_Dec_Holder"

    class UnrecognizedHostFault_Dec(ElementDeclaration):
        literal = "UnrecognizedHostFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnrecognizedHostFault')
            kw["aname"] = "_UnrecognizedHostFault"
            if ns0.UnrecognizedHost_Def not in ns0.UnrecognizedHostFault_Dec.__bases__:
                bases = list(ns0.UnrecognizedHostFault_Dec.__bases__)
                bases.insert(0, ns0.UnrecognizedHost_Def)
                ns0.UnrecognizedHostFault_Dec.__bases__ = tuple(bases)

            ns0.UnrecognizedHost_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnrecognizedHostFault_Dec_Holder"

    class UnsharedSwapVMotionNotSupportedFault_Dec(ElementDeclaration):
        literal = "UnsharedSwapVMotionNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnsharedSwapVMotionNotSupportedFault')
            kw["aname"] = "_UnsharedSwapVMotionNotSupportedFault"
            if ns0.UnsharedSwapVMotionNotSupported_Def not in ns0.UnsharedSwapVMotionNotSupportedFault_Dec.__bases__:
                bases = list(ns0.UnsharedSwapVMotionNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.UnsharedSwapVMotionNotSupported_Def)
                ns0.UnsharedSwapVMotionNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.UnsharedSwapVMotionNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnsharedSwapVMotionNotSupportedFault_Dec_Holder"

    class UnsupportedDatastoreFault_Dec(ElementDeclaration):
        literal = "UnsupportedDatastoreFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnsupportedDatastoreFault')
            kw["aname"] = "_UnsupportedDatastoreFault"
            if ns0.UnsupportedDatastore_Def not in ns0.UnsupportedDatastoreFault_Dec.__bases__:
                bases = list(ns0.UnsupportedDatastoreFault_Dec.__bases__)
                bases.insert(0, ns0.UnsupportedDatastore_Def)
                ns0.UnsupportedDatastoreFault_Dec.__bases__ = tuple(bases)

            ns0.UnsupportedDatastore_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnsupportedDatastoreFault_Dec_Holder"

    class UnsupportedGuestFault_Dec(ElementDeclaration):
        literal = "UnsupportedGuestFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnsupportedGuestFault')
            kw["aname"] = "_UnsupportedGuestFault"
            if ns0.UnsupportedGuest_Def not in ns0.UnsupportedGuestFault_Dec.__bases__:
                bases = list(ns0.UnsupportedGuestFault_Dec.__bases__)
                bases.insert(0, ns0.UnsupportedGuest_Def)
                ns0.UnsupportedGuestFault_Dec.__bases__ = tuple(bases)

            ns0.UnsupportedGuest_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnsupportedGuestFault_Dec_Holder"

    class UnsupportedVmxLocationFault_Dec(ElementDeclaration):
        literal = "UnsupportedVmxLocationFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnsupportedVmxLocationFault')
            kw["aname"] = "_UnsupportedVmxLocationFault"
            if ns0.UnsupportedVmxLocation_Def not in ns0.UnsupportedVmxLocationFault_Dec.__bases__:
                bases = list(ns0.UnsupportedVmxLocationFault_Dec.__bases__)
                bases.insert(0, ns0.UnsupportedVmxLocation_Def)
                ns0.UnsupportedVmxLocationFault_Dec.__bases__ = tuple(bases)

            ns0.UnsupportedVmxLocation_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnsupportedVmxLocationFault_Dec_Holder"

    class UserNotFoundFault_Dec(ElementDeclaration):
        literal = "UserNotFoundFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UserNotFoundFault')
            kw["aname"] = "_UserNotFoundFault"
            if ns0.UserNotFound_Def not in ns0.UserNotFoundFault_Dec.__bases__:
                bases = list(ns0.UserNotFoundFault_Dec.__bases__)
                bases.insert(0, ns0.UserNotFound_Def)
                ns0.UserNotFoundFault_Dec.__bases__ = tuple(bases)

            ns0.UserNotFound_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UserNotFoundFault_Dec_Holder"

    class VMINotSupportedFault_Dec(ElementDeclaration):
        literal = "VMINotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMINotSupportedFault')
            kw["aname"] = "_VMINotSupportedFault"
            if ns0.VMINotSupported_Def not in ns0.VMINotSupportedFault_Dec.__bases__:
                bases = list(ns0.VMINotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.VMINotSupported_Def)
                ns0.VMINotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.VMINotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMINotSupportedFault_Dec_Holder"

    class VMOnVirtualIntranetFault_Dec(ElementDeclaration):
        literal = "VMOnVirtualIntranetFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMOnVirtualIntranetFault')
            kw["aname"] = "_VMOnVirtualIntranetFault"
            if ns0.VMOnVirtualIntranet_Def not in ns0.VMOnVirtualIntranetFault_Dec.__bases__:
                bases = list(ns0.VMOnVirtualIntranetFault_Dec.__bases__)
                bases.insert(0, ns0.VMOnVirtualIntranet_Def)
                ns0.VMOnVirtualIntranetFault_Dec.__bases__ = tuple(bases)

            ns0.VMOnVirtualIntranet_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMOnVirtualIntranetFault_Dec_Holder"

    class VMotionInterfaceIssueFault_Dec(ElementDeclaration):
        literal = "VMotionInterfaceIssueFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMotionInterfaceIssueFault')
            kw["aname"] = "_VMotionInterfaceIssueFault"
            if ns0.VMotionInterfaceIssue_Def not in ns0.VMotionInterfaceIssueFault_Dec.__bases__:
                bases = list(ns0.VMotionInterfaceIssueFault_Dec.__bases__)
                bases.insert(0, ns0.VMotionInterfaceIssue_Def)
                ns0.VMotionInterfaceIssueFault_Dec.__bases__ = tuple(bases)

            ns0.VMotionInterfaceIssue_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMotionInterfaceIssueFault_Dec_Holder"

    class VMotionLinkCapacityLowFault_Dec(ElementDeclaration):
        literal = "VMotionLinkCapacityLowFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMotionLinkCapacityLowFault')
            kw["aname"] = "_VMotionLinkCapacityLowFault"
            if ns0.VMotionLinkCapacityLow_Def not in ns0.VMotionLinkCapacityLowFault_Dec.__bases__:
                bases = list(ns0.VMotionLinkCapacityLowFault_Dec.__bases__)
                bases.insert(0, ns0.VMotionLinkCapacityLow_Def)
                ns0.VMotionLinkCapacityLowFault_Dec.__bases__ = tuple(bases)

            ns0.VMotionLinkCapacityLow_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMotionLinkCapacityLowFault_Dec_Holder"

    class VMotionLinkDownFault_Dec(ElementDeclaration):
        literal = "VMotionLinkDownFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMotionLinkDownFault')
            kw["aname"] = "_VMotionLinkDownFault"
            if ns0.VMotionLinkDown_Def not in ns0.VMotionLinkDownFault_Dec.__bases__:
                bases = list(ns0.VMotionLinkDownFault_Dec.__bases__)
                bases.insert(0, ns0.VMotionLinkDown_Def)
                ns0.VMotionLinkDownFault_Dec.__bases__ = tuple(bases)

            ns0.VMotionLinkDown_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMotionLinkDownFault_Dec_Holder"

    class VMotionNotConfiguredFault_Dec(ElementDeclaration):
        literal = "VMotionNotConfiguredFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMotionNotConfiguredFault')
            kw["aname"] = "_VMotionNotConfiguredFault"
            if ns0.VMotionNotConfigured_Def not in ns0.VMotionNotConfiguredFault_Dec.__bases__:
                bases = list(ns0.VMotionNotConfiguredFault_Dec.__bases__)
                bases.insert(0, ns0.VMotionNotConfigured_Def)
                ns0.VMotionNotConfiguredFault_Dec.__bases__ = tuple(bases)

            ns0.VMotionNotConfigured_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMotionNotConfiguredFault_Dec_Holder"

    class VMotionNotLicensedFault_Dec(ElementDeclaration):
        literal = "VMotionNotLicensedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMotionNotLicensedFault')
            kw["aname"] = "_VMotionNotLicensedFault"
            if ns0.VMotionNotLicensed_Def not in ns0.VMotionNotLicensedFault_Dec.__bases__:
                bases = list(ns0.VMotionNotLicensedFault_Dec.__bases__)
                bases.insert(0, ns0.VMotionNotLicensed_Def)
                ns0.VMotionNotLicensedFault_Dec.__bases__ = tuple(bases)

            ns0.VMotionNotLicensed_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMotionNotLicensedFault_Dec_Holder"

    class VMotionNotSupportedFault_Dec(ElementDeclaration):
        literal = "VMotionNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMotionNotSupportedFault')
            kw["aname"] = "_VMotionNotSupportedFault"
            if ns0.VMotionNotSupported_Def not in ns0.VMotionNotSupportedFault_Dec.__bases__:
                bases = list(ns0.VMotionNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.VMotionNotSupported_Def)
                ns0.VMotionNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.VMotionNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMotionNotSupportedFault_Dec_Holder"

    class VMotionProtocolIncompatibleFault_Dec(ElementDeclaration):
        literal = "VMotionProtocolIncompatibleFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VMotionProtocolIncompatibleFault')
            kw["aname"] = "_VMotionProtocolIncompatibleFault"
            if ns0.VMotionProtocolIncompatible_Def not in ns0.VMotionProtocolIncompatibleFault_Dec.__bases__:
                bases = list(ns0.VMotionProtocolIncompatibleFault_Dec.__bases__)
                bases.insert(0, ns0.VMotionProtocolIncompatible_Def)
                ns0.VMotionProtocolIncompatibleFault_Dec.__bases__ = tuple(bases)

            ns0.VMotionProtocolIncompatible_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VMotionProtocolIncompatibleFault_Dec_Holder"

    class VimFaultFault_Dec(ElementDeclaration):
        literal = "VimFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VimFaultFault')
            kw["aname"] = "_VimFaultFault"
            if ns0.VimFault_Def not in ns0.VimFaultFault_Dec.__bases__:
                bases = list(ns0.VimFaultFault_Dec.__bases__)
                bases.insert(0, ns0.VimFault_Def)
                ns0.VimFaultFault_Dec.__bases__ = tuple(bases)

            ns0.VimFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VimFaultFault_Dec_Holder"

    class VirtualEthernetCardNotSupportedFault_Dec(ElementDeclaration):
        literal = "VirtualEthernetCardNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VirtualEthernetCardNotSupportedFault')
            kw["aname"] = "_VirtualEthernetCardNotSupportedFault"
            if ns0.VirtualEthernetCardNotSupported_Def not in ns0.VirtualEthernetCardNotSupportedFault_Dec.__bases__:
                bases = list(ns0.VirtualEthernetCardNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.VirtualEthernetCardNotSupported_Def)
                ns0.VirtualEthernetCardNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.VirtualEthernetCardNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VirtualEthernetCardNotSupportedFault_Dec_Holder"

    class VirtualHardwareCompatibilityIssueFault_Dec(ElementDeclaration):
        literal = "VirtualHardwareCompatibilityIssueFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VirtualHardwareCompatibilityIssueFault')
            kw["aname"] = "_VirtualHardwareCompatibilityIssueFault"
            if ns0.VirtualHardwareCompatibilityIssue_Def not in ns0.VirtualHardwareCompatibilityIssueFault_Dec.__bases__:
                bases = list(ns0.VirtualHardwareCompatibilityIssueFault_Dec.__bases__)
                bases.insert(0, ns0.VirtualHardwareCompatibilityIssue_Def)
                ns0.VirtualHardwareCompatibilityIssueFault_Dec.__bases__ = tuple(bases)

            ns0.VirtualHardwareCompatibilityIssue_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VirtualHardwareCompatibilityIssueFault_Dec_Holder"

    class VirtualHardwareVersionNotSupportedFault_Dec(ElementDeclaration):
        literal = "VirtualHardwareVersionNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VirtualHardwareVersionNotSupportedFault')
            kw["aname"] = "_VirtualHardwareVersionNotSupportedFault"
            if ns0.VirtualHardwareVersionNotSupported_Def not in ns0.VirtualHardwareVersionNotSupportedFault_Dec.__bases__:
                bases = list(ns0.VirtualHardwareVersionNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.VirtualHardwareVersionNotSupported_Def)
                ns0.VirtualHardwareVersionNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.VirtualHardwareVersionNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VirtualHardwareVersionNotSupportedFault_Dec_Holder"

    class VmConfigFaultFault_Dec(ElementDeclaration):
        literal = "VmConfigFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VmConfigFaultFault')
            kw["aname"] = "_VmConfigFaultFault"
            if ns0.VmConfigFault_Def not in ns0.VmConfigFaultFault_Dec.__bases__:
                bases = list(ns0.VmConfigFaultFault_Dec.__bases__)
                bases.insert(0, ns0.VmConfigFault_Def)
                ns0.VmConfigFaultFault_Dec.__bases__ = tuple(bases)

            ns0.VmConfigFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VmConfigFaultFault_Dec_Holder"

    class VmLimitLicenseFault_Dec(ElementDeclaration):
        literal = "VmLimitLicenseFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VmLimitLicenseFault')
            kw["aname"] = "_VmLimitLicenseFault"
            if ns0.VmLimitLicense_Def not in ns0.VmLimitLicenseFault_Dec.__bases__:
                bases = list(ns0.VmLimitLicenseFault_Dec.__bases__)
                bases.insert(0, ns0.VmLimitLicense_Def)
                ns0.VmLimitLicenseFault_Dec.__bases__ = tuple(bases)

            ns0.VmLimitLicense_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VmLimitLicenseFault_Dec_Holder"

    class VmToolsUpgradeFaultFault_Dec(ElementDeclaration):
        literal = "VmToolsUpgradeFaultFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VmToolsUpgradeFaultFault')
            kw["aname"] = "_VmToolsUpgradeFaultFault"
            if ns0.VmToolsUpgradeFault_Def not in ns0.VmToolsUpgradeFaultFault_Dec.__bases__:
                bases = list(ns0.VmToolsUpgradeFaultFault_Dec.__bases__)
                bases.insert(0, ns0.VmToolsUpgradeFault_Def)
                ns0.VmToolsUpgradeFaultFault_Dec.__bases__ = tuple(bases)

            ns0.VmToolsUpgradeFault_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VmToolsUpgradeFaultFault_Dec_Holder"

    class VmWwnConflictFault_Dec(ElementDeclaration):
        literal = "VmWwnConflictFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VmWwnConflictFault')
            kw["aname"] = "_VmWwnConflictFault"
            if ns0.VmWwnConflict_Def not in ns0.VmWwnConflictFault_Dec.__bases__:
                bases = list(ns0.VmWwnConflictFault_Dec.__bases__)
                bases.insert(0, ns0.VmWwnConflict_Def)
                ns0.VmWwnConflictFault_Dec.__bases__ = tuple(bases)

            ns0.VmWwnConflict_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VmWwnConflictFault_Dec_Holder"

    class VmotionInterfaceNotEnabledFault_Dec(ElementDeclaration):
        literal = "VmotionInterfaceNotEnabledFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VmotionInterfaceNotEnabledFault')
            kw["aname"] = "_VmotionInterfaceNotEnabledFault"
            if ns0.VmotionInterfaceNotEnabled_Def not in ns0.VmotionInterfaceNotEnabledFault_Dec.__bases__:
                bases = list(ns0.VmotionInterfaceNotEnabledFault_Dec.__bases__)
                bases.insert(0, ns0.VmotionInterfaceNotEnabled_Def)
                ns0.VmotionInterfaceNotEnabledFault_Dec.__bases__ = tuple(bases)

            ns0.VmotionInterfaceNotEnabled_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VmotionInterfaceNotEnabledFault_Dec_Holder"

    class VolumeEditorErrorFault_Dec(ElementDeclaration):
        literal = "VolumeEditorErrorFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'VolumeEditorErrorFault')
            kw["aname"] = "_VolumeEditorErrorFault"
            if ns0.VolumeEditorError_Def not in ns0.VolumeEditorErrorFault_Dec.__bases__:
                bases = list(ns0.VolumeEditorErrorFault_Dec.__bases__)
                bases.insert(0, ns0.VolumeEditorError_Def)
                ns0.VolumeEditorErrorFault_Dec.__bases__ = tuple(bases)

            ns0.VolumeEditorError_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "VolumeEditorErrorFault_Dec_Holder"

    class WakeOnLanNotSupportedFault_Dec(ElementDeclaration):
        literal = "WakeOnLanNotSupportedFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'WakeOnLanNotSupportedFault')
            kw["aname"] = "_WakeOnLanNotSupportedFault"
            if ns0.WakeOnLanNotSupported_Def not in ns0.WakeOnLanNotSupportedFault_Dec.__bases__:
                bases = list(ns0.WakeOnLanNotSupportedFault_Dec.__bases__)
                bases.insert(0, ns0.WakeOnLanNotSupported_Def)
                ns0.WakeOnLanNotSupportedFault_Dec.__bases__ = tuple(bases)

            ns0.WakeOnLanNotSupported_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "WakeOnLanNotSupportedFault_Dec_Holder"

    class WakeOnLanNotSupportedByVmotionNICFault_Dec(ElementDeclaration):
        literal = "WakeOnLanNotSupportedByVmotionNICFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'WakeOnLanNotSupportedByVmotionNICFault')
            kw["aname"] = "_WakeOnLanNotSupportedByVmotionNICFault"
            if ns0.WakeOnLanNotSupportedByVmotionNIC_Def not in ns0.WakeOnLanNotSupportedByVmotionNICFault_Dec.__bases__:
                bases = list(ns0.WakeOnLanNotSupportedByVmotionNICFault_Dec.__bases__)
                bases.insert(0, ns0.WakeOnLanNotSupportedByVmotionNIC_Def)
                ns0.WakeOnLanNotSupportedByVmotionNICFault_Dec.__bases__ = tuple(bases)

            ns0.WakeOnLanNotSupportedByVmotionNIC_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "WakeOnLanNotSupportedByVmotionNICFault_Dec_Holder"

    class WillModifyConfigCpuRequirementsFault_Dec(ElementDeclaration):
        literal = "WillModifyConfigCpuRequirementsFault"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'WillModifyConfigCpuRequirementsFault')
            kw["aname"] = "_WillModifyConfigCpuRequirementsFault"
            if ns0.WillModifyConfigCpuRequirements_Def not in ns0.WillModifyConfigCpuRequirementsFault_Dec.__bases__:
                bases = list(ns0.WillModifyConfigCpuRequirementsFault_Dec.__bases__)
                bases.insert(0, ns0.WillModifyConfigCpuRequirements_Def)
                ns0.WillModifyConfigCpuRequirementsFault_Dec.__bases__ = tuple(bases)

            ns0.WillModifyConfigCpuRequirements_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "WillModifyConfigCpuRequirementsFault_Dec_Holder"

    class ReconfigureAutostart_Dec(ElementDeclaration):
        literal = "ReconfigureAutostart"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureAutostart')
            kw["aname"] = "_ReconfigureAutostart"
            if ns0.ReconfigureAutostartRequestType_Def not in ns0.ReconfigureAutostart_Dec.__bases__:
                bases = list(ns0.ReconfigureAutostart_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureAutostartRequestType_Def)
                ns0.ReconfigureAutostart_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureAutostartRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureAutostart_Dec_Holder"

    class ReconfigureAutostartResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureAutostartResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureAutostartResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureAutostartResponse')
            kw["aname"] = "_ReconfigureAutostartResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureAutostartResponse_Holder"
            self.pyclass = Holder

    class AutoStartPowerOn_Dec(ElementDeclaration):
        literal = "AutoStartPowerOn"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AutoStartPowerOn')
            kw["aname"] = "_AutoStartPowerOn"
            if ns0.AutoStartPowerOnRequestType_Def not in ns0.AutoStartPowerOn_Dec.__bases__:
                bases = list(ns0.AutoStartPowerOn_Dec.__bases__)
                bases.insert(0, ns0.AutoStartPowerOnRequestType_Def)
                ns0.AutoStartPowerOn_Dec.__bases__ = tuple(bases)

            ns0.AutoStartPowerOnRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AutoStartPowerOn_Dec_Holder"

    class AutoStartPowerOnResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AutoStartPowerOnResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AutoStartPowerOnResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AutoStartPowerOnResponse')
            kw["aname"] = "_AutoStartPowerOnResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AutoStartPowerOnResponse_Holder"
            self.pyclass = Holder

    class AutoStartPowerOff_Dec(ElementDeclaration):
        literal = "AutoStartPowerOff"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AutoStartPowerOff')
            kw["aname"] = "_AutoStartPowerOff"
            if ns0.AutoStartPowerOffRequestType_Def not in ns0.AutoStartPowerOff_Dec.__bases__:
                bases = list(ns0.AutoStartPowerOff_Dec.__bases__)
                bases.insert(0, ns0.AutoStartPowerOffRequestType_Def)
                ns0.AutoStartPowerOff_Dec.__bases__ = tuple(bases)

            ns0.AutoStartPowerOffRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AutoStartPowerOff_Dec_Holder"

    class AutoStartPowerOffResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AutoStartPowerOffResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AutoStartPowerOffResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AutoStartPowerOffResponse')
            kw["aname"] = "_AutoStartPowerOffResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AutoStartPowerOffResponse_Holder"
            self.pyclass = Holder

    class QueryBootDevices_Dec(ElementDeclaration):
        literal = "QueryBootDevices"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryBootDevices')
            kw["aname"] = "_QueryBootDevices"
            if ns0.QueryBootDevicesRequestType_Def not in ns0.QueryBootDevices_Dec.__bases__:
                bases = list(ns0.QueryBootDevices_Dec.__bases__)
                bases.insert(0, ns0.QueryBootDevicesRequestType_Def)
                ns0.QueryBootDevices_Dec.__bases__ = tuple(bases)

            ns0.QueryBootDevicesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryBootDevices_Dec_Holder"

    class QueryBootDevicesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryBootDevicesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryBootDevicesResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostBootDeviceInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryBootDevicesResponse')
            kw["aname"] = "_QueryBootDevicesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryBootDevicesResponse_Holder"
            self.pyclass = Holder

    class UpdateBootDevice_Dec(ElementDeclaration):
        literal = "UpdateBootDevice"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateBootDevice')
            kw["aname"] = "_UpdateBootDevice"
            if ns0.UpdateBootDeviceRequestType_Def not in ns0.UpdateBootDevice_Dec.__bases__:
                bases = list(ns0.UpdateBootDevice_Dec.__bases__)
                bases.insert(0, ns0.UpdateBootDeviceRequestType_Def)
                ns0.UpdateBootDevice_Dec.__bases__ = tuple(bases)

            ns0.UpdateBootDeviceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateBootDevice_Dec_Holder"

    class UpdateBootDeviceResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateBootDeviceResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateBootDeviceResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateBootDeviceResponse')
            kw["aname"] = "_UpdateBootDeviceResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateBootDeviceResponse_Holder"
            self.pyclass = Holder

    class EnableHyperThreading_Dec(ElementDeclaration):
        literal = "EnableHyperThreading"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'EnableHyperThreading')
            kw["aname"] = "_EnableHyperThreading"
            if ns0.EnableHyperThreadingRequestType_Def not in ns0.EnableHyperThreading_Dec.__bases__:
                bases = list(ns0.EnableHyperThreading_Dec.__bases__)
                bases.insert(0, ns0.EnableHyperThreadingRequestType_Def)
                ns0.EnableHyperThreading_Dec.__bases__ = tuple(bases)

            ns0.EnableHyperThreadingRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "EnableHyperThreading_Dec_Holder"

    class EnableHyperThreadingResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "EnableHyperThreadingResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.EnableHyperThreadingResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'EnableHyperThreadingResponse')
            kw["aname"] = "_EnableHyperThreadingResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "EnableHyperThreadingResponse_Holder"
            self.pyclass = Holder

    class DisableHyperThreading_Dec(ElementDeclaration):
        literal = "DisableHyperThreading"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisableHyperThreading')
            kw["aname"] = "_DisableHyperThreading"
            if ns0.DisableHyperThreadingRequestType_Def not in ns0.DisableHyperThreading_Dec.__bases__:
                bases = list(ns0.DisableHyperThreading_Dec.__bases__)
                bases.insert(0, ns0.DisableHyperThreadingRequestType_Def)
                ns0.DisableHyperThreading_Dec.__bases__ = tuple(bases)

            ns0.DisableHyperThreadingRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisableHyperThreading_Dec_Holder"

    class DisableHyperThreadingResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DisableHyperThreadingResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DisableHyperThreadingResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DisableHyperThreadingResponse')
            kw["aname"] = "_DisableHyperThreadingResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DisableHyperThreadingResponse_Holder"
            self.pyclass = Holder

    class SearchDatastore_Dec(ElementDeclaration):
        literal = "SearchDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SearchDatastore')
            kw["aname"] = "_SearchDatastore"
            if ns0.SearchDatastoreRequestType_Def not in ns0.SearchDatastore_Dec.__bases__:
                bases = list(ns0.SearchDatastore_Dec.__bases__)
                bases.insert(0, ns0.SearchDatastoreRequestType_Def)
                ns0.SearchDatastore_Dec.__bases__ = tuple(bases)

            ns0.SearchDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SearchDatastore_Dec_Holder"

    class SearchDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SearchDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SearchDatastoreResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDatastoreBrowserSearchResults",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'SearchDatastoreResponse')
            kw["aname"] = "_SearchDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "SearchDatastoreResponse_Holder"
            self.pyclass = Holder

    class SearchDatastore_Task_Dec(ElementDeclaration):
        literal = "SearchDatastore_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SearchDatastore_Task')
            kw["aname"] = "_SearchDatastore_Task"
            if ns0.SearchDatastoreRequestType_Def not in ns0.SearchDatastore_Task_Dec.__bases__:
                bases = list(ns0.SearchDatastore_Task_Dec.__bases__)
                bases.insert(0, ns0.SearchDatastoreRequestType_Def)
                ns0.SearchDatastore_Task_Dec.__bases__ = tuple(bases)

            ns0.SearchDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SearchDatastore_Task_Dec_Holder"

    class SearchDatastore_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SearchDatastore_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SearchDatastore_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'SearchDatastore_TaskResponse')
            kw["aname"] = "_SearchDatastore_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "SearchDatastore_TaskResponse_Holder"
            self.pyclass = Holder

    class SearchDatastoreSubFolders_Dec(ElementDeclaration):
        literal = "SearchDatastoreSubFolders"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SearchDatastoreSubFolders')
            kw["aname"] = "_SearchDatastoreSubFolders"
            if ns0.SearchDatastoreSubFoldersRequestType_Def not in ns0.SearchDatastoreSubFolders_Dec.__bases__:
                bases = list(ns0.SearchDatastoreSubFolders_Dec.__bases__)
                bases.insert(0, ns0.SearchDatastoreSubFoldersRequestType_Def)
                ns0.SearchDatastoreSubFolders_Dec.__bases__ = tuple(bases)

            ns0.SearchDatastoreSubFoldersRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SearchDatastoreSubFolders_Dec_Holder"

    class SearchDatastoreSubFoldersResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SearchDatastoreSubFoldersResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SearchDatastoreSubFoldersResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDatastoreBrowserSearchResults",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'SearchDatastoreSubFoldersResponse')
            kw["aname"] = "_SearchDatastoreSubFoldersResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "SearchDatastoreSubFoldersResponse_Holder"
            self.pyclass = Holder

    class SearchDatastoreSubFolders_Task_Dec(ElementDeclaration):
        literal = "SearchDatastoreSubFolders_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SearchDatastoreSubFolders_Task')
            kw["aname"] = "_SearchDatastoreSubFolders_Task"
            if ns0.SearchDatastoreSubFoldersRequestType_Def not in ns0.SearchDatastoreSubFolders_Task_Dec.__bases__:
                bases = list(ns0.SearchDatastoreSubFolders_Task_Dec.__bases__)
                bases.insert(0, ns0.SearchDatastoreSubFoldersRequestType_Def)
                ns0.SearchDatastoreSubFolders_Task_Dec.__bases__ = tuple(bases)

            ns0.SearchDatastoreSubFoldersRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SearchDatastoreSubFolders_Task_Dec_Holder"

    class SearchDatastoreSubFolders_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SearchDatastoreSubFolders_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SearchDatastoreSubFolders_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'SearchDatastoreSubFolders_TaskResponse')
            kw["aname"] = "_SearchDatastoreSubFolders_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "SearchDatastoreSubFolders_TaskResponse_Holder"
            self.pyclass = Holder

    class DeleteFile_Dec(ElementDeclaration):
        literal = "DeleteFile"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeleteFile')
            kw["aname"] = "_DeleteFile"
            if ns0.DeleteFileRequestType_Def not in ns0.DeleteFile_Dec.__bases__:
                bases = list(ns0.DeleteFile_Dec.__bases__)
                bases.insert(0, ns0.DeleteFileRequestType_Def)
                ns0.DeleteFile_Dec.__bases__ = tuple(bases)

            ns0.DeleteFileRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeleteFile_Dec_Holder"

    class DeleteFileResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DeleteFileResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DeleteFileResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DeleteFileResponse')
            kw["aname"] = "_DeleteFileResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DeleteFileResponse_Holder"
            self.pyclass = Holder

    class UpdateLocalSwapDatastore_Dec(ElementDeclaration):
        literal = "UpdateLocalSwapDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateLocalSwapDatastore')
            kw["aname"] = "_UpdateLocalSwapDatastore"
            if ns0.UpdateLocalSwapDatastoreRequestType_Def not in ns0.UpdateLocalSwapDatastore_Dec.__bases__:
                bases = list(ns0.UpdateLocalSwapDatastore_Dec.__bases__)
                bases.insert(0, ns0.UpdateLocalSwapDatastoreRequestType_Def)
                ns0.UpdateLocalSwapDatastore_Dec.__bases__ = tuple(bases)

            ns0.UpdateLocalSwapDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateLocalSwapDatastore_Dec_Holder"

    class UpdateLocalSwapDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateLocalSwapDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateLocalSwapDatastoreResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateLocalSwapDatastoreResponse')
            kw["aname"] = "_UpdateLocalSwapDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateLocalSwapDatastoreResponse_Holder"
            self.pyclass = Holder

    class QueryAvailableDisksForVmfs_Dec(ElementDeclaration):
        literal = "QueryAvailableDisksForVmfs"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryAvailableDisksForVmfs')
            kw["aname"] = "_QueryAvailableDisksForVmfs"
            if ns0.QueryAvailableDisksForVmfsRequestType_Def not in ns0.QueryAvailableDisksForVmfs_Dec.__bases__:
                bases = list(ns0.QueryAvailableDisksForVmfs_Dec.__bases__)
                bases.insert(0, ns0.QueryAvailableDisksForVmfsRequestType_Def)
                ns0.QueryAvailableDisksForVmfs_Dec.__bases__ = tuple(bases)

            ns0.QueryAvailableDisksForVmfsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryAvailableDisksForVmfs_Dec_Holder"

    class QueryAvailableDisksForVmfsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryAvailableDisksForVmfsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryAvailableDisksForVmfsResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostScsiDisk",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryAvailableDisksForVmfsResponse')
            kw["aname"] = "_QueryAvailableDisksForVmfsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryAvailableDisksForVmfsResponse_Holder"
            self.pyclass = Holder

    class QueryVmfsDatastoreCreateOptions_Dec(ElementDeclaration):
        literal = "QueryVmfsDatastoreCreateOptions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryVmfsDatastoreCreateOptions')
            kw["aname"] = "_QueryVmfsDatastoreCreateOptions"
            if ns0.QueryVmfsDatastoreCreateOptionsRequestType_Def not in ns0.QueryVmfsDatastoreCreateOptions_Dec.__bases__:
                bases = list(ns0.QueryVmfsDatastoreCreateOptions_Dec.__bases__)
                bases.insert(0, ns0.QueryVmfsDatastoreCreateOptionsRequestType_Def)
                ns0.QueryVmfsDatastoreCreateOptions_Dec.__bases__ = tuple(bases)

            ns0.QueryVmfsDatastoreCreateOptionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryVmfsDatastoreCreateOptions_Dec_Holder"

    class QueryVmfsDatastoreCreateOptionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryVmfsDatastoreCreateOptionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryVmfsDatastoreCreateOptionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","VmfsDatastoreOption",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryVmfsDatastoreCreateOptionsResponse')
            kw["aname"] = "_QueryVmfsDatastoreCreateOptionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryVmfsDatastoreCreateOptionsResponse_Holder"
            self.pyclass = Holder

    class CreateVmfsDatastore_Dec(ElementDeclaration):
        literal = "CreateVmfsDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateVmfsDatastore')
            kw["aname"] = "_CreateVmfsDatastore"
            if ns0.CreateVmfsDatastoreRequestType_Def not in ns0.CreateVmfsDatastore_Dec.__bases__:
                bases = list(ns0.CreateVmfsDatastore_Dec.__bases__)
                bases.insert(0, ns0.CreateVmfsDatastoreRequestType_Def)
                ns0.CreateVmfsDatastore_Dec.__bases__ = tuple(bases)

            ns0.CreateVmfsDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateVmfsDatastore_Dec_Holder"

    class CreateVmfsDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateVmfsDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateVmfsDatastoreResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateVmfsDatastoreResponse')
            kw["aname"] = "_CreateVmfsDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateVmfsDatastoreResponse_Holder"
            self.pyclass = Holder

    class QueryVmfsDatastoreExtendOptions_Dec(ElementDeclaration):
        literal = "QueryVmfsDatastoreExtendOptions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryVmfsDatastoreExtendOptions')
            kw["aname"] = "_QueryVmfsDatastoreExtendOptions"
            if ns0.QueryVmfsDatastoreExtendOptionsRequestType_Def not in ns0.QueryVmfsDatastoreExtendOptions_Dec.__bases__:
                bases = list(ns0.QueryVmfsDatastoreExtendOptions_Dec.__bases__)
                bases.insert(0, ns0.QueryVmfsDatastoreExtendOptionsRequestType_Def)
                ns0.QueryVmfsDatastoreExtendOptions_Dec.__bases__ = tuple(bases)

            ns0.QueryVmfsDatastoreExtendOptionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryVmfsDatastoreExtendOptions_Dec_Holder"

    class QueryVmfsDatastoreExtendOptionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryVmfsDatastoreExtendOptionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryVmfsDatastoreExtendOptionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","VmfsDatastoreOption",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryVmfsDatastoreExtendOptionsResponse')
            kw["aname"] = "_QueryVmfsDatastoreExtendOptionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryVmfsDatastoreExtendOptionsResponse_Holder"
            self.pyclass = Holder

    class ExtendVmfsDatastore_Dec(ElementDeclaration):
        literal = "ExtendVmfsDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ExtendVmfsDatastore')
            kw["aname"] = "_ExtendVmfsDatastore"
            if ns0.ExtendVmfsDatastoreRequestType_Def not in ns0.ExtendVmfsDatastore_Dec.__bases__:
                bases = list(ns0.ExtendVmfsDatastore_Dec.__bases__)
                bases.insert(0, ns0.ExtendVmfsDatastoreRequestType_Def)
                ns0.ExtendVmfsDatastore_Dec.__bases__ = tuple(bases)

            ns0.ExtendVmfsDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ExtendVmfsDatastore_Dec_Holder"

    class ExtendVmfsDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ExtendVmfsDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ExtendVmfsDatastoreResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ExtendVmfsDatastoreResponse')
            kw["aname"] = "_ExtendVmfsDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ExtendVmfsDatastoreResponse_Holder"
            self.pyclass = Holder

    class CreateNasDatastore_Dec(ElementDeclaration):
        literal = "CreateNasDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateNasDatastore')
            kw["aname"] = "_CreateNasDatastore"
            if ns0.CreateNasDatastoreRequestType_Def not in ns0.CreateNasDatastore_Dec.__bases__:
                bases = list(ns0.CreateNasDatastore_Dec.__bases__)
                bases.insert(0, ns0.CreateNasDatastoreRequestType_Def)
                ns0.CreateNasDatastore_Dec.__bases__ = tuple(bases)

            ns0.CreateNasDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateNasDatastore_Dec_Holder"

    class CreateNasDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateNasDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateNasDatastoreResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateNasDatastoreResponse')
            kw["aname"] = "_CreateNasDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateNasDatastoreResponse_Holder"
            self.pyclass = Holder

    class CreateLocalDatastore_Dec(ElementDeclaration):
        literal = "CreateLocalDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateLocalDatastore')
            kw["aname"] = "_CreateLocalDatastore"
            if ns0.CreateLocalDatastoreRequestType_Def not in ns0.CreateLocalDatastore_Dec.__bases__:
                bases = list(ns0.CreateLocalDatastore_Dec.__bases__)
                bases.insert(0, ns0.CreateLocalDatastoreRequestType_Def)
                ns0.CreateLocalDatastore_Dec.__bases__ = tuple(bases)

            ns0.CreateLocalDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateLocalDatastore_Dec_Holder"

    class CreateLocalDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateLocalDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateLocalDatastoreResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateLocalDatastoreResponse')
            kw["aname"] = "_CreateLocalDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateLocalDatastoreResponse_Holder"
            self.pyclass = Holder

    class RemoveDatastore_Dec(ElementDeclaration):
        literal = "RemoveDatastore"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveDatastore')
            kw["aname"] = "_RemoveDatastore"
            if ns0.RemoveDatastoreRequestType_Def not in ns0.RemoveDatastore_Dec.__bases__:
                bases = list(ns0.RemoveDatastore_Dec.__bases__)
                bases.insert(0, ns0.RemoveDatastoreRequestType_Def)
                ns0.RemoveDatastore_Dec.__bases__ = tuple(bases)

            ns0.RemoveDatastoreRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveDatastore_Dec_Holder"

    class RemoveDatastoreResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveDatastoreResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveDatastoreResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveDatastoreResponse')
            kw["aname"] = "_RemoveDatastoreResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveDatastoreResponse_Holder"
            self.pyclass = Holder

    class ConfigureDatastorePrincipal_Dec(ElementDeclaration):
        literal = "ConfigureDatastorePrincipal"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ConfigureDatastorePrincipal')
            kw["aname"] = "_ConfigureDatastorePrincipal"
            if ns0.ConfigureDatastorePrincipalRequestType_Def not in ns0.ConfigureDatastorePrincipal_Dec.__bases__:
                bases = list(ns0.ConfigureDatastorePrincipal_Dec.__bases__)
                bases.insert(0, ns0.ConfigureDatastorePrincipalRequestType_Def)
                ns0.ConfigureDatastorePrincipal_Dec.__bases__ = tuple(bases)

            ns0.ConfigureDatastorePrincipalRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ConfigureDatastorePrincipal_Dec_Holder"

    class ConfigureDatastorePrincipalResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ConfigureDatastorePrincipalResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ConfigureDatastorePrincipalResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ConfigureDatastorePrincipalResponse')
            kw["aname"] = "_ConfigureDatastorePrincipalResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ConfigureDatastorePrincipalResponse_Holder"
            self.pyclass = Holder

    class UpdateDateTimeConfig_Dec(ElementDeclaration):
        literal = "UpdateDateTimeConfig"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateDateTimeConfig')
            kw["aname"] = "_UpdateDateTimeConfig"
            if ns0.UpdateDateTimeConfigRequestType_Def not in ns0.UpdateDateTimeConfig_Dec.__bases__:
                bases = list(ns0.UpdateDateTimeConfig_Dec.__bases__)
                bases.insert(0, ns0.UpdateDateTimeConfigRequestType_Def)
                ns0.UpdateDateTimeConfig_Dec.__bases__ = tuple(bases)

            ns0.UpdateDateTimeConfigRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateDateTimeConfig_Dec_Holder"

    class UpdateDateTimeConfigResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateDateTimeConfigResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateDateTimeConfigResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateDateTimeConfigResponse')
            kw["aname"] = "_UpdateDateTimeConfigResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateDateTimeConfigResponse_Holder"
            self.pyclass = Holder

    class QueryAvailableTimeZones_Dec(ElementDeclaration):
        literal = "QueryAvailableTimeZones"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryAvailableTimeZones')
            kw["aname"] = "_QueryAvailableTimeZones"
            if ns0.QueryAvailableTimeZonesRequestType_Def not in ns0.QueryAvailableTimeZones_Dec.__bases__:
                bases = list(ns0.QueryAvailableTimeZones_Dec.__bases__)
                bases.insert(0, ns0.QueryAvailableTimeZonesRequestType_Def)
                ns0.QueryAvailableTimeZones_Dec.__bases__ = tuple(bases)

            ns0.QueryAvailableTimeZonesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryAvailableTimeZones_Dec_Holder"

    class QueryAvailableTimeZonesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryAvailableTimeZonesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryAvailableTimeZonesResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDateTimeSystemTimeZone",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryAvailableTimeZonesResponse')
            kw["aname"] = "_QueryAvailableTimeZonesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryAvailableTimeZonesResponse_Holder"
            self.pyclass = Holder

    class QueryDateTime_Dec(ElementDeclaration):
        literal = "QueryDateTime"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryDateTime')
            kw["aname"] = "_QueryDateTime"
            if ns0.QueryDateTimeRequestType_Def not in ns0.QueryDateTime_Dec.__bases__:
                bases = list(ns0.QueryDateTime_Dec.__bases__)
                bases.insert(0, ns0.QueryDateTimeRequestType_Def)
                ns0.QueryDateTime_Dec.__bases__ = tuple(bases)

            ns0.QueryDateTimeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryDateTime_Dec_Holder"

    class QueryDateTimeResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryDateTimeResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryDateTimeResponse_Dec.schema
            TClist = [ZSI.TCtimes.gDateTime(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryDateTimeResponse')
            kw["aname"] = "_QueryDateTimeResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryDateTimeResponse_Holder"
            self.pyclass = Holder

    class UpdateDateTime_Dec(ElementDeclaration):
        literal = "UpdateDateTime"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateDateTime')
            kw["aname"] = "_UpdateDateTime"
            if ns0.UpdateDateTimeRequestType_Def not in ns0.UpdateDateTime_Dec.__bases__:
                bases = list(ns0.UpdateDateTime_Dec.__bases__)
                bases.insert(0, ns0.UpdateDateTimeRequestType_Def)
                ns0.UpdateDateTime_Dec.__bases__ = tuple(bases)

            ns0.UpdateDateTimeRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateDateTime_Dec_Holder"

    class UpdateDateTimeResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateDateTimeResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateDateTimeResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateDateTimeResponse')
            kw["aname"] = "_UpdateDateTimeResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateDateTimeResponse_Holder"
            self.pyclass = Holder

    class RefreshDateTimeSystem_Dec(ElementDeclaration):
        literal = "RefreshDateTimeSystem"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshDateTimeSystem')
            kw["aname"] = "_RefreshDateTimeSystem"
            if ns0.RefreshDateTimeSystemRequestType_Def not in ns0.RefreshDateTimeSystem_Dec.__bases__:
                bases = list(ns0.RefreshDateTimeSystem_Dec.__bases__)
                bases.insert(0, ns0.RefreshDateTimeSystemRequestType_Def)
                ns0.RefreshDateTimeSystem_Dec.__bases__ = tuple(bases)

            ns0.RefreshDateTimeSystemRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshDateTimeSystem_Dec_Holder"

    class RefreshDateTimeSystemResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshDateTimeSystemResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshDateTimeSystemResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshDateTimeSystemResponse')
            kw["aname"] = "_RefreshDateTimeSystemResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshDateTimeSystemResponse_Holder"
            self.pyclass = Holder

    class QueryAvailablePartition_Dec(ElementDeclaration):
        literal = "QueryAvailablePartition"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryAvailablePartition')
            kw["aname"] = "_QueryAvailablePartition"
            if ns0.QueryAvailablePartitionRequestType_Def not in ns0.QueryAvailablePartition_Dec.__bases__:
                bases = list(ns0.QueryAvailablePartition_Dec.__bases__)
                bases.insert(0, ns0.QueryAvailablePartitionRequestType_Def)
                ns0.QueryAvailablePartition_Dec.__bases__ = tuple(bases)

            ns0.QueryAvailablePartitionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryAvailablePartition_Dec_Holder"

    class QueryAvailablePartitionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryAvailablePartitionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryAvailablePartitionResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDiagnosticPartition",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryAvailablePartitionResponse')
            kw["aname"] = "_QueryAvailablePartitionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryAvailablePartitionResponse_Holder"
            self.pyclass = Holder

    class SelectActivePartition_Dec(ElementDeclaration):
        literal = "SelectActivePartition"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SelectActivePartition')
            kw["aname"] = "_SelectActivePartition"
            if ns0.SelectActivePartitionRequestType_Def not in ns0.SelectActivePartition_Dec.__bases__:
                bases = list(ns0.SelectActivePartition_Dec.__bases__)
                bases.insert(0, ns0.SelectActivePartitionRequestType_Def)
                ns0.SelectActivePartition_Dec.__bases__ = tuple(bases)

            ns0.SelectActivePartitionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SelectActivePartition_Dec_Holder"

    class SelectActivePartitionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SelectActivePartitionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SelectActivePartitionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SelectActivePartitionResponse')
            kw["aname"] = "_SelectActivePartitionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SelectActivePartitionResponse_Holder"
            self.pyclass = Holder

    class QueryPartitionCreateOptions_Dec(ElementDeclaration):
        literal = "QueryPartitionCreateOptions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryPartitionCreateOptions')
            kw["aname"] = "_QueryPartitionCreateOptions"
            if ns0.QueryPartitionCreateOptionsRequestType_Def not in ns0.QueryPartitionCreateOptions_Dec.__bases__:
                bases = list(ns0.QueryPartitionCreateOptions_Dec.__bases__)
                bases.insert(0, ns0.QueryPartitionCreateOptionsRequestType_Def)
                ns0.QueryPartitionCreateOptions_Dec.__bases__ = tuple(bases)

            ns0.QueryPartitionCreateOptionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryPartitionCreateOptions_Dec_Holder"

    class QueryPartitionCreateOptionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryPartitionCreateOptionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryPartitionCreateOptionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDiagnosticPartitionCreateOption",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryPartitionCreateOptionsResponse')
            kw["aname"] = "_QueryPartitionCreateOptionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryPartitionCreateOptionsResponse_Holder"
            self.pyclass = Holder

    class QueryPartitionCreateDesc_Dec(ElementDeclaration):
        literal = "QueryPartitionCreateDesc"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryPartitionCreateDesc')
            kw["aname"] = "_QueryPartitionCreateDesc"
            if ns0.QueryPartitionCreateDescRequestType_Def not in ns0.QueryPartitionCreateDesc_Dec.__bases__:
                bases = list(ns0.QueryPartitionCreateDesc_Dec.__bases__)
                bases.insert(0, ns0.QueryPartitionCreateDescRequestType_Def)
                ns0.QueryPartitionCreateDesc_Dec.__bases__ = tuple(bases)

            ns0.QueryPartitionCreateDescRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryPartitionCreateDesc_Dec_Holder"

    class QueryPartitionCreateDescResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryPartitionCreateDescResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryPartitionCreateDescResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDiagnosticPartitionCreateDescription",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryPartitionCreateDescResponse')
            kw["aname"] = "_QueryPartitionCreateDescResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryPartitionCreateDescResponse_Holder"
            self.pyclass = Holder

    class CreateDiagnosticPartition_Dec(ElementDeclaration):
        literal = "CreateDiagnosticPartition"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateDiagnosticPartition')
            kw["aname"] = "_CreateDiagnosticPartition"
            if ns0.CreateDiagnosticPartitionRequestType_Def not in ns0.CreateDiagnosticPartition_Dec.__bases__:
                bases = list(ns0.CreateDiagnosticPartition_Dec.__bases__)
                bases.insert(0, ns0.CreateDiagnosticPartitionRequestType_Def)
                ns0.CreateDiagnosticPartition_Dec.__bases__ = tuple(bases)

            ns0.CreateDiagnosticPartitionRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateDiagnosticPartition_Dec_Holder"

    class CreateDiagnosticPartitionResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateDiagnosticPartitionResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateDiagnosticPartitionResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CreateDiagnosticPartitionResponse')
            kw["aname"] = "_CreateDiagnosticPartitionResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CreateDiagnosticPartitionResponse_Holder"
            self.pyclass = Holder

    class UpdateDefaultPolicy_Dec(ElementDeclaration):
        literal = "UpdateDefaultPolicy"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateDefaultPolicy')
            kw["aname"] = "_UpdateDefaultPolicy"
            if ns0.UpdateDefaultPolicyRequestType_Def not in ns0.UpdateDefaultPolicy_Dec.__bases__:
                bases = list(ns0.UpdateDefaultPolicy_Dec.__bases__)
                bases.insert(0, ns0.UpdateDefaultPolicyRequestType_Def)
                ns0.UpdateDefaultPolicy_Dec.__bases__ = tuple(bases)

            ns0.UpdateDefaultPolicyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateDefaultPolicy_Dec_Holder"

    class UpdateDefaultPolicyResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateDefaultPolicyResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateDefaultPolicyResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateDefaultPolicyResponse')
            kw["aname"] = "_UpdateDefaultPolicyResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateDefaultPolicyResponse_Holder"
            self.pyclass = Holder

    class EnableRuleset_Dec(ElementDeclaration):
        literal = "EnableRuleset"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'EnableRuleset')
            kw["aname"] = "_EnableRuleset"
            if ns0.EnableRulesetRequestType_Def not in ns0.EnableRuleset_Dec.__bases__:
                bases = list(ns0.EnableRuleset_Dec.__bases__)
                bases.insert(0, ns0.EnableRulesetRequestType_Def)
                ns0.EnableRuleset_Dec.__bases__ = tuple(bases)

            ns0.EnableRulesetRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "EnableRuleset_Dec_Holder"

    class EnableRulesetResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "EnableRulesetResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.EnableRulesetResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'EnableRulesetResponse')
            kw["aname"] = "_EnableRulesetResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "EnableRulesetResponse_Holder"
            self.pyclass = Holder

    class DisableRuleset_Dec(ElementDeclaration):
        literal = "DisableRuleset"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisableRuleset')
            kw["aname"] = "_DisableRuleset"
            if ns0.DisableRulesetRequestType_Def not in ns0.DisableRuleset_Dec.__bases__:
                bases = list(ns0.DisableRuleset_Dec.__bases__)
                bases.insert(0, ns0.DisableRulesetRequestType_Def)
                ns0.DisableRuleset_Dec.__bases__ = tuple(bases)

            ns0.DisableRulesetRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisableRuleset_Dec_Holder"

    class DisableRulesetResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DisableRulesetResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DisableRulesetResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DisableRulesetResponse')
            kw["aname"] = "_DisableRulesetResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DisableRulesetResponse_Holder"
            self.pyclass = Holder

    class RefreshFirewall_Dec(ElementDeclaration):
        literal = "RefreshFirewall"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshFirewall')
            kw["aname"] = "_RefreshFirewall"
            if ns0.RefreshFirewallRequestType_Def not in ns0.RefreshFirewall_Dec.__bases__:
                bases = list(ns0.RefreshFirewall_Dec.__bases__)
                bases.insert(0, ns0.RefreshFirewallRequestType_Def)
                ns0.RefreshFirewall_Dec.__bases__ = tuple(bases)

            ns0.RefreshFirewallRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshFirewall_Dec_Holder"

    class RefreshFirewallResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshFirewallResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshFirewallResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshFirewallResponse')
            kw["aname"] = "_RefreshFirewallResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshFirewallResponse_Holder"
            self.pyclass = Holder

    class ResetFirmwareToFactoryDefaults_Dec(ElementDeclaration):
        literal = "ResetFirmwareToFactoryDefaults"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetFirmwareToFactoryDefaults')
            kw["aname"] = "_ResetFirmwareToFactoryDefaults"
            if ns0.ResetFirmwareToFactoryDefaultsRequestType_Def not in ns0.ResetFirmwareToFactoryDefaults_Dec.__bases__:
                bases = list(ns0.ResetFirmwareToFactoryDefaults_Dec.__bases__)
                bases.insert(0, ns0.ResetFirmwareToFactoryDefaultsRequestType_Def)
                ns0.ResetFirmwareToFactoryDefaults_Dec.__bases__ = tuple(bases)

            ns0.ResetFirmwareToFactoryDefaultsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetFirmwareToFactoryDefaults_Dec_Holder"

    class ResetFirmwareToFactoryDefaultsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetFirmwareToFactoryDefaultsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetFirmwareToFactoryDefaultsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ResetFirmwareToFactoryDefaultsResponse')
            kw["aname"] = "_ResetFirmwareToFactoryDefaultsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ResetFirmwareToFactoryDefaultsResponse_Holder"
            self.pyclass = Holder

    class BackupFirmwareConfiguration_Dec(ElementDeclaration):
        literal = "BackupFirmwareConfiguration"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'BackupFirmwareConfiguration')
            kw["aname"] = "_BackupFirmwareConfiguration"
            if ns0.BackupFirmwareConfigurationRequestType_Def not in ns0.BackupFirmwareConfiguration_Dec.__bases__:
                bases = list(ns0.BackupFirmwareConfiguration_Dec.__bases__)
                bases.insert(0, ns0.BackupFirmwareConfigurationRequestType_Def)
                ns0.BackupFirmwareConfiguration_Dec.__bases__ = tuple(bases)

            ns0.BackupFirmwareConfigurationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "BackupFirmwareConfiguration_Dec_Holder"

    class BackupFirmwareConfigurationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "BackupFirmwareConfigurationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.BackupFirmwareConfigurationResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'BackupFirmwareConfigurationResponse')
            kw["aname"] = "_BackupFirmwareConfigurationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "BackupFirmwareConfigurationResponse_Holder"
            self.pyclass = Holder

    class QueryFirmwareConfigUploadURL_Dec(ElementDeclaration):
        literal = "QueryFirmwareConfigUploadURL"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryFirmwareConfigUploadURL')
            kw["aname"] = "_QueryFirmwareConfigUploadURL"
            if ns0.QueryFirmwareConfigUploadURLRequestType_Def not in ns0.QueryFirmwareConfigUploadURL_Dec.__bases__:
                bases = list(ns0.QueryFirmwareConfigUploadURL_Dec.__bases__)
                bases.insert(0, ns0.QueryFirmwareConfigUploadURLRequestType_Def)
                ns0.QueryFirmwareConfigUploadURL_Dec.__bases__ = tuple(bases)

            ns0.QueryFirmwareConfigUploadURLRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryFirmwareConfigUploadURL_Dec_Holder"

    class QueryFirmwareConfigUploadURLResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryFirmwareConfigUploadURLResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryFirmwareConfigUploadURLResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryFirmwareConfigUploadURLResponse')
            kw["aname"] = "_QueryFirmwareConfigUploadURLResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "QueryFirmwareConfigUploadURLResponse_Holder"
            self.pyclass = Holder

    class RestoreFirmwareConfiguration_Dec(ElementDeclaration):
        literal = "RestoreFirmwareConfiguration"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RestoreFirmwareConfiguration')
            kw["aname"] = "_RestoreFirmwareConfiguration"
            if ns0.RestoreFirmwareConfigurationRequestType_Def not in ns0.RestoreFirmwareConfiguration_Dec.__bases__:
                bases = list(ns0.RestoreFirmwareConfiguration_Dec.__bases__)
                bases.insert(0, ns0.RestoreFirmwareConfigurationRequestType_Def)
                ns0.RestoreFirmwareConfiguration_Dec.__bases__ = tuple(bases)

            ns0.RestoreFirmwareConfigurationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RestoreFirmwareConfiguration_Dec_Holder"

    class RestoreFirmwareConfigurationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RestoreFirmwareConfigurationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RestoreFirmwareConfigurationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RestoreFirmwareConfigurationResponse')
            kw["aname"] = "_RestoreFirmwareConfigurationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RestoreFirmwareConfigurationResponse_Holder"
            self.pyclass = Holder

    class RefreshHealthStatusSystem_Dec(ElementDeclaration):
        literal = "RefreshHealthStatusSystem"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshHealthStatusSystem')
            kw["aname"] = "_RefreshHealthStatusSystem"
            if ns0.RefreshHealthStatusSystemRequestType_Def not in ns0.RefreshHealthStatusSystem_Dec.__bases__:
                bases = list(ns0.RefreshHealthStatusSystem_Dec.__bases__)
                bases.insert(0, ns0.RefreshHealthStatusSystemRequestType_Def)
                ns0.RefreshHealthStatusSystem_Dec.__bases__ = tuple(bases)

            ns0.RefreshHealthStatusSystemRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshHealthStatusSystem_Dec_Holder"

    class RefreshHealthStatusSystemResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshHealthStatusSystemResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshHealthStatusSystemResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshHealthStatusSystemResponse')
            kw["aname"] = "_RefreshHealthStatusSystemResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshHealthStatusSystemResponse_Holder"
            self.pyclass = Holder

    class ResetSystemHealthInfo_Dec(ElementDeclaration):
        literal = "ResetSystemHealthInfo"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetSystemHealthInfo')
            kw["aname"] = "_ResetSystemHealthInfo"
            if ns0.ResetSystemHealthInfoRequestType_Def not in ns0.ResetSystemHealthInfo_Dec.__bases__:
                bases = list(ns0.ResetSystemHealthInfo_Dec.__bases__)
                bases.insert(0, ns0.ResetSystemHealthInfoRequestType_Def)
                ns0.ResetSystemHealthInfo_Dec.__bases__ = tuple(bases)

            ns0.ResetSystemHealthInfoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetSystemHealthInfo_Dec_Holder"

    class ResetSystemHealthInfoResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetSystemHealthInfoResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetSystemHealthInfoResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ResetSystemHealthInfoResponse')
            kw["aname"] = "_ResetSystemHealthInfoResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ResetSystemHealthInfoResponse_Holder"
            self.pyclass = Holder

    class CreateUser_Dec(ElementDeclaration):
        literal = "CreateUser"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateUser')
            kw["aname"] = "_CreateUser"
            if ns0.CreateUserRequestType_Def not in ns0.CreateUser_Dec.__bases__:
                bases = list(ns0.CreateUser_Dec.__bases__)
                bases.insert(0, ns0.CreateUserRequestType_Def)
                ns0.CreateUser_Dec.__bases__ = tuple(bases)

            ns0.CreateUserRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateUser_Dec_Holder"

    class CreateUserResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateUserResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateUserResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CreateUserResponse')
            kw["aname"] = "_CreateUserResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CreateUserResponse_Holder"
            self.pyclass = Holder

    class UpdateUser_Dec(ElementDeclaration):
        literal = "UpdateUser"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateUser')
            kw["aname"] = "_UpdateUser"
            if ns0.UpdateUserRequestType_Def not in ns0.UpdateUser_Dec.__bases__:
                bases = list(ns0.UpdateUser_Dec.__bases__)
                bases.insert(0, ns0.UpdateUserRequestType_Def)
                ns0.UpdateUser_Dec.__bases__ = tuple(bases)

            ns0.UpdateUserRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateUser_Dec_Holder"

    class UpdateUserResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateUserResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateUserResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateUserResponse')
            kw["aname"] = "_UpdateUserResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateUserResponse_Holder"
            self.pyclass = Holder

    class CreateGroup_Dec(ElementDeclaration):
        literal = "CreateGroup"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateGroup')
            kw["aname"] = "_CreateGroup"
            if ns0.CreateGroupRequestType_Def not in ns0.CreateGroup_Dec.__bases__:
                bases = list(ns0.CreateGroup_Dec.__bases__)
                bases.insert(0, ns0.CreateGroupRequestType_Def)
                ns0.CreateGroup_Dec.__bases__ = tuple(bases)

            ns0.CreateGroupRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateGroup_Dec_Holder"

    class CreateGroupResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateGroupResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateGroupResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'CreateGroupResponse')
            kw["aname"] = "_CreateGroupResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "CreateGroupResponse_Holder"
            self.pyclass = Holder

    class RemoveUser_Dec(ElementDeclaration):
        literal = "RemoveUser"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveUser')
            kw["aname"] = "_RemoveUser"
            if ns0.RemoveUserRequestType_Def not in ns0.RemoveUser_Dec.__bases__:
                bases = list(ns0.RemoveUser_Dec.__bases__)
                bases.insert(0, ns0.RemoveUserRequestType_Def)
                ns0.RemoveUser_Dec.__bases__ = tuple(bases)

            ns0.RemoveUserRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveUser_Dec_Holder"

    class RemoveUserResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveUserResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveUserResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveUserResponse')
            kw["aname"] = "_RemoveUserResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveUserResponse_Holder"
            self.pyclass = Holder

    class RemoveGroup_Dec(ElementDeclaration):
        literal = "RemoveGroup"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveGroup')
            kw["aname"] = "_RemoveGroup"
            if ns0.RemoveGroupRequestType_Def not in ns0.RemoveGroup_Dec.__bases__:
                bases = list(ns0.RemoveGroup_Dec.__bases__)
                bases.insert(0, ns0.RemoveGroupRequestType_Def)
                ns0.RemoveGroup_Dec.__bases__ = tuple(bases)

            ns0.RemoveGroupRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveGroup_Dec_Holder"

    class RemoveGroupResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveGroupResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveGroupResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveGroupResponse')
            kw["aname"] = "_RemoveGroupResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveGroupResponse_Holder"
            self.pyclass = Holder

    class AssignUserToGroup_Dec(ElementDeclaration):
        literal = "AssignUserToGroup"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AssignUserToGroup')
            kw["aname"] = "_AssignUserToGroup"
            if ns0.AssignUserToGroupRequestType_Def not in ns0.AssignUserToGroup_Dec.__bases__:
                bases = list(ns0.AssignUserToGroup_Dec.__bases__)
                bases.insert(0, ns0.AssignUserToGroupRequestType_Def)
                ns0.AssignUserToGroup_Dec.__bases__ = tuple(bases)

            ns0.AssignUserToGroupRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AssignUserToGroup_Dec_Holder"

    class AssignUserToGroupResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AssignUserToGroupResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AssignUserToGroupResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AssignUserToGroupResponse')
            kw["aname"] = "_AssignUserToGroupResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AssignUserToGroupResponse_Holder"
            self.pyclass = Holder

    class UnassignUserFromGroup_Dec(ElementDeclaration):
        literal = "UnassignUserFromGroup"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UnassignUserFromGroup')
            kw["aname"] = "_UnassignUserFromGroup"
            if ns0.UnassignUserFromGroupRequestType_Def not in ns0.UnassignUserFromGroup_Dec.__bases__:
                bases = list(ns0.UnassignUserFromGroup_Dec.__bases__)
                bases.insert(0, ns0.UnassignUserFromGroupRequestType_Def)
                ns0.UnassignUserFromGroup_Dec.__bases__ = tuple(bases)

            ns0.UnassignUserFromGroupRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UnassignUserFromGroup_Dec_Holder"

    class UnassignUserFromGroupResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UnassignUserFromGroupResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UnassignUserFromGroupResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UnassignUserFromGroupResponse')
            kw["aname"] = "_UnassignUserFromGroupResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UnassignUserFromGroupResponse_Holder"
            self.pyclass = Holder

    class ReconfigureServiceConsoleReservation_Dec(ElementDeclaration):
        literal = "ReconfigureServiceConsoleReservation"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureServiceConsoleReservation')
            kw["aname"] = "_ReconfigureServiceConsoleReservation"
            if ns0.ReconfigureServiceConsoleReservationRequestType_Def not in ns0.ReconfigureServiceConsoleReservation_Dec.__bases__:
                bases = list(ns0.ReconfigureServiceConsoleReservation_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureServiceConsoleReservationRequestType_Def)
                ns0.ReconfigureServiceConsoleReservation_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureServiceConsoleReservationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureServiceConsoleReservation_Dec_Holder"

    class ReconfigureServiceConsoleReservationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureServiceConsoleReservationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureServiceConsoleReservationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureServiceConsoleReservationResponse')
            kw["aname"] = "_ReconfigureServiceConsoleReservationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureServiceConsoleReservationResponse_Holder"
            self.pyclass = Holder

    class ReconfigureVirtualMachineReservation_Dec(ElementDeclaration):
        literal = "ReconfigureVirtualMachineReservation"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureVirtualMachineReservation')
            kw["aname"] = "_ReconfigureVirtualMachineReservation"
            if ns0.ReconfigureVirtualMachineReservationRequestType_Def not in ns0.ReconfigureVirtualMachineReservation_Dec.__bases__:
                bases = list(ns0.ReconfigureVirtualMachineReservation_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureVirtualMachineReservationRequestType_Def)
                ns0.ReconfigureVirtualMachineReservation_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureVirtualMachineReservationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureVirtualMachineReservation_Dec_Holder"

    class ReconfigureVirtualMachineReservationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureVirtualMachineReservationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureVirtualMachineReservationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureVirtualMachineReservationResponse')
            kw["aname"] = "_ReconfigureVirtualMachineReservationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureVirtualMachineReservationResponse_Holder"
            self.pyclass = Holder

    class UpdateNetworkConfig_Dec(ElementDeclaration):
        literal = "UpdateNetworkConfig"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateNetworkConfig')
            kw["aname"] = "_UpdateNetworkConfig"
            if ns0.UpdateNetworkConfigRequestType_Def not in ns0.UpdateNetworkConfig_Dec.__bases__:
                bases = list(ns0.UpdateNetworkConfig_Dec.__bases__)
                bases.insert(0, ns0.UpdateNetworkConfigRequestType_Def)
                ns0.UpdateNetworkConfig_Dec.__bases__ = tuple(bases)

            ns0.UpdateNetworkConfigRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateNetworkConfig_Dec_Holder"

    class UpdateNetworkConfigResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateNetworkConfigResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateNetworkConfigResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostNetworkConfigResult",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'UpdateNetworkConfigResponse')
            kw["aname"] = "_UpdateNetworkConfigResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "UpdateNetworkConfigResponse_Holder"
            self.pyclass = Holder

    class UpdateDnsConfig_Dec(ElementDeclaration):
        literal = "UpdateDnsConfig"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateDnsConfig')
            kw["aname"] = "_UpdateDnsConfig"
            if ns0.UpdateDnsConfigRequestType_Def not in ns0.UpdateDnsConfig_Dec.__bases__:
                bases = list(ns0.UpdateDnsConfig_Dec.__bases__)
                bases.insert(0, ns0.UpdateDnsConfigRequestType_Def)
                ns0.UpdateDnsConfig_Dec.__bases__ = tuple(bases)

            ns0.UpdateDnsConfigRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateDnsConfig_Dec_Holder"

    class UpdateDnsConfigResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateDnsConfigResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateDnsConfigResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateDnsConfigResponse')
            kw["aname"] = "_UpdateDnsConfigResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateDnsConfigResponse_Holder"
            self.pyclass = Holder

    class UpdateIpRouteConfig_Dec(ElementDeclaration):
        literal = "UpdateIpRouteConfig"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateIpRouteConfig')
            kw["aname"] = "_UpdateIpRouteConfig"
            if ns0.UpdateIpRouteConfigRequestType_Def not in ns0.UpdateIpRouteConfig_Dec.__bases__:
                bases = list(ns0.UpdateIpRouteConfig_Dec.__bases__)
                bases.insert(0, ns0.UpdateIpRouteConfigRequestType_Def)
                ns0.UpdateIpRouteConfig_Dec.__bases__ = tuple(bases)

            ns0.UpdateIpRouteConfigRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateIpRouteConfig_Dec_Holder"

    class UpdateIpRouteConfigResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateIpRouteConfigResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateIpRouteConfigResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateIpRouteConfigResponse')
            kw["aname"] = "_UpdateIpRouteConfigResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateIpRouteConfigResponse_Holder"
            self.pyclass = Holder

    class UpdateConsoleIpRouteConfig_Dec(ElementDeclaration):
        literal = "UpdateConsoleIpRouteConfig"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateConsoleIpRouteConfig')
            kw["aname"] = "_UpdateConsoleIpRouteConfig"
            if ns0.UpdateConsoleIpRouteConfigRequestType_Def not in ns0.UpdateConsoleIpRouteConfig_Dec.__bases__:
                bases = list(ns0.UpdateConsoleIpRouteConfig_Dec.__bases__)
                bases.insert(0, ns0.UpdateConsoleIpRouteConfigRequestType_Def)
                ns0.UpdateConsoleIpRouteConfig_Dec.__bases__ = tuple(bases)

            ns0.UpdateConsoleIpRouteConfigRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateConsoleIpRouteConfig_Dec_Holder"

    class UpdateConsoleIpRouteConfigResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateConsoleIpRouteConfigResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateConsoleIpRouteConfigResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateConsoleIpRouteConfigResponse')
            kw["aname"] = "_UpdateConsoleIpRouteConfigResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateConsoleIpRouteConfigResponse_Holder"
            self.pyclass = Holder

    class AddVirtualSwitch_Dec(ElementDeclaration):
        literal = "AddVirtualSwitch"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddVirtualSwitch')
            kw["aname"] = "_AddVirtualSwitch"
            if ns0.AddVirtualSwitchRequestType_Def not in ns0.AddVirtualSwitch_Dec.__bases__:
                bases = list(ns0.AddVirtualSwitch_Dec.__bases__)
                bases.insert(0, ns0.AddVirtualSwitchRequestType_Def)
                ns0.AddVirtualSwitch_Dec.__bases__ = tuple(bases)

            ns0.AddVirtualSwitchRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddVirtualSwitch_Dec_Holder"

    class AddVirtualSwitchResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddVirtualSwitchResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddVirtualSwitchResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AddVirtualSwitchResponse')
            kw["aname"] = "_AddVirtualSwitchResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AddVirtualSwitchResponse_Holder"
            self.pyclass = Holder

    class RemoveVirtualSwitch_Dec(ElementDeclaration):
        literal = "RemoveVirtualSwitch"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveVirtualSwitch')
            kw["aname"] = "_RemoveVirtualSwitch"
            if ns0.RemoveVirtualSwitchRequestType_Def not in ns0.RemoveVirtualSwitch_Dec.__bases__:
                bases = list(ns0.RemoveVirtualSwitch_Dec.__bases__)
                bases.insert(0, ns0.RemoveVirtualSwitchRequestType_Def)
                ns0.RemoveVirtualSwitch_Dec.__bases__ = tuple(bases)

            ns0.RemoveVirtualSwitchRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveVirtualSwitch_Dec_Holder"

    class RemoveVirtualSwitchResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveVirtualSwitchResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveVirtualSwitchResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveVirtualSwitchResponse')
            kw["aname"] = "_RemoveVirtualSwitchResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveVirtualSwitchResponse_Holder"
            self.pyclass = Holder

    class UpdateVirtualSwitch_Dec(ElementDeclaration):
        literal = "UpdateVirtualSwitch"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateVirtualSwitch')
            kw["aname"] = "_UpdateVirtualSwitch"
            if ns0.UpdateVirtualSwitchRequestType_Def not in ns0.UpdateVirtualSwitch_Dec.__bases__:
                bases = list(ns0.UpdateVirtualSwitch_Dec.__bases__)
                bases.insert(0, ns0.UpdateVirtualSwitchRequestType_Def)
                ns0.UpdateVirtualSwitch_Dec.__bases__ = tuple(bases)

            ns0.UpdateVirtualSwitchRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateVirtualSwitch_Dec_Holder"

    class UpdateVirtualSwitchResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateVirtualSwitchResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateVirtualSwitchResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateVirtualSwitchResponse')
            kw["aname"] = "_UpdateVirtualSwitchResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateVirtualSwitchResponse_Holder"
            self.pyclass = Holder

    class AddPortGroup_Dec(ElementDeclaration):
        literal = "AddPortGroup"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddPortGroup')
            kw["aname"] = "_AddPortGroup"
            if ns0.AddPortGroupRequestType_Def not in ns0.AddPortGroup_Dec.__bases__:
                bases = list(ns0.AddPortGroup_Dec.__bases__)
                bases.insert(0, ns0.AddPortGroupRequestType_Def)
                ns0.AddPortGroup_Dec.__bases__ = tuple(bases)

            ns0.AddPortGroupRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddPortGroup_Dec_Holder"

    class AddPortGroupResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddPortGroupResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddPortGroupResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AddPortGroupResponse')
            kw["aname"] = "_AddPortGroupResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AddPortGroupResponse_Holder"
            self.pyclass = Holder

    class RemovePortGroup_Dec(ElementDeclaration):
        literal = "RemovePortGroup"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemovePortGroup')
            kw["aname"] = "_RemovePortGroup"
            if ns0.RemovePortGroupRequestType_Def not in ns0.RemovePortGroup_Dec.__bases__:
                bases = list(ns0.RemovePortGroup_Dec.__bases__)
                bases.insert(0, ns0.RemovePortGroupRequestType_Def)
                ns0.RemovePortGroup_Dec.__bases__ = tuple(bases)

            ns0.RemovePortGroupRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemovePortGroup_Dec_Holder"

    class RemovePortGroupResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemovePortGroupResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemovePortGroupResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemovePortGroupResponse')
            kw["aname"] = "_RemovePortGroupResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemovePortGroupResponse_Holder"
            self.pyclass = Holder

    class UpdatePortGroup_Dec(ElementDeclaration):
        literal = "UpdatePortGroup"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdatePortGroup')
            kw["aname"] = "_UpdatePortGroup"
            if ns0.UpdatePortGroupRequestType_Def not in ns0.UpdatePortGroup_Dec.__bases__:
                bases = list(ns0.UpdatePortGroup_Dec.__bases__)
                bases.insert(0, ns0.UpdatePortGroupRequestType_Def)
                ns0.UpdatePortGroup_Dec.__bases__ = tuple(bases)

            ns0.UpdatePortGroupRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdatePortGroup_Dec_Holder"

    class UpdatePortGroupResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdatePortGroupResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdatePortGroupResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdatePortGroupResponse')
            kw["aname"] = "_UpdatePortGroupResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdatePortGroupResponse_Holder"
            self.pyclass = Holder

    class UpdatePhysicalNicLinkSpeed_Dec(ElementDeclaration):
        literal = "UpdatePhysicalNicLinkSpeed"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdatePhysicalNicLinkSpeed')
            kw["aname"] = "_UpdatePhysicalNicLinkSpeed"
            if ns0.UpdatePhysicalNicLinkSpeedRequestType_Def not in ns0.UpdatePhysicalNicLinkSpeed_Dec.__bases__:
                bases = list(ns0.UpdatePhysicalNicLinkSpeed_Dec.__bases__)
                bases.insert(0, ns0.UpdatePhysicalNicLinkSpeedRequestType_Def)
                ns0.UpdatePhysicalNicLinkSpeed_Dec.__bases__ = tuple(bases)

            ns0.UpdatePhysicalNicLinkSpeedRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdatePhysicalNicLinkSpeed_Dec_Holder"

    class UpdatePhysicalNicLinkSpeedResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdatePhysicalNicLinkSpeedResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdatePhysicalNicLinkSpeedResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdatePhysicalNicLinkSpeedResponse')
            kw["aname"] = "_UpdatePhysicalNicLinkSpeedResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdatePhysicalNicLinkSpeedResponse_Holder"
            self.pyclass = Holder

    class QueryNetworkHint_Dec(ElementDeclaration):
        literal = "QueryNetworkHint"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryNetworkHint')
            kw["aname"] = "_QueryNetworkHint"
            if ns0.QueryNetworkHintRequestType_Def not in ns0.QueryNetworkHint_Dec.__bases__:
                bases = list(ns0.QueryNetworkHint_Dec.__bases__)
                bases.insert(0, ns0.QueryNetworkHintRequestType_Def)
                ns0.QueryNetworkHint_Dec.__bases__ = tuple(bases)

            ns0.QueryNetworkHintRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryNetworkHint_Dec_Holder"

    class QueryNetworkHintResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryNetworkHintResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryNetworkHintResponse_Dec.schema
            TClist = [GTD("urn:vim25","PhysicalNicHintInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryNetworkHintResponse')
            kw["aname"] = "_QueryNetworkHintResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryNetworkHintResponse_Holder"
            self.pyclass = Holder

    class AddVirtualNic_Dec(ElementDeclaration):
        literal = "AddVirtualNic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddVirtualNic')
            kw["aname"] = "_AddVirtualNic"
            if ns0.AddVirtualNicRequestType_Def not in ns0.AddVirtualNic_Dec.__bases__:
                bases = list(ns0.AddVirtualNic_Dec.__bases__)
                bases.insert(0, ns0.AddVirtualNicRequestType_Def)
                ns0.AddVirtualNic_Dec.__bases__ = tuple(bases)

            ns0.AddVirtualNicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddVirtualNic_Dec_Holder"

    class AddVirtualNicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddVirtualNicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddVirtualNicResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddVirtualNicResponse')
            kw["aname"] = "_AddVirtualNicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddVirtualNicResponse_Holder"
            self.pyclass = Holder

    class RemoveVirtualNic_Dec(ElementDeclaration):
        literal = "RemoveVirtualNic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveVirtualNic')
            kw["aname"] = "_RemoveVirtualNic"
            if ns0.RemoveVirtualNicRequestType_Def not in ns0.RemoveVirtualNic_Dec.__bases__:
                bases = list(ns0.RemoveVirtualNic_Dec.__bases__)
                bases.insert(0, ns0.RemoveVirtualNicRequestType_Def)
                ns0.RemoveVirtualNic_Dec.__bases__ = tuple(bases)

            ns0.RemoveVirtualNicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveVirtualNic_Dec_Holder"

    class RemoveVirtualNicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveVirtualNicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveVirtualNicResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveVirtualNicResponse')
            kw["aname"] = "_RemoveVirtualNicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveVirtualNicResponse_Holder"
            self.pyclass = Holder

    class UpdateVirtualNic_Dec(ElementDeclaration):
        literal = "UpdateVirtualNic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateVirtualNic')
            kw["aname"] = "_UpdateVirtualNic"
            if ns0.UpdateVirtualNicRequestType_Def not in ns0.UpdateVirtualNic_Dec.__bases__:
                bases = list(ns0.UpdateVirtualNic_Dec.__bases__)
                bases.insert(0, ns0.UpdateVirtualNicRequestType_Def)
                ns0.UpdateVirtualNic_Dec.__bases__ = tuple(bases)

            ns0.UpdateVirtualNicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateVirtualNic_Dec_Holder"

    class UpdateVirtualNicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateVirtualNicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateVirtualNicResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateVirtualNicResponse')
            kw["aname"] = "_UpdateVirtualNicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateVirtualNicResponse_Holder"
            self.pyclass = Holder

    class AddServiceConsoleVirtualNic_Dec(ElementDeclaration):
        literal = "AddServiceConsoleVirtualNic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddServiceConsoleVirtualNic')
            kw["aname"] = "_AddServiceConsoleVirtualNic"
            if ns0.AddServiceConsoleVirtualNicRequestType_Def not in ns0.AddServiceConsoleVirtualNic_Dec.__bases__:
                bases = list(ns0.AddServiceConsoleVirtualNic_Dec.__bases__)
                bases.insert(0, ns0.AddServiceConsoleVirtualNicRequestType_Def)
                ns0.AddServiceConsoleVirtualNic_Dec.__bases__ = tuple(bases)

            ns0.AddServiceConsoleVirtualNicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddServiceConsoleVirtualNic_Dec_Holder"

    class AddServiceConsoleVirtualNicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddServiceConsoleVirtualNicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddServiceConsoleVirtualNicResponse_Dec.schema
            TClist = [ZSI.TC.String(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'AddServiceConsoleVirtualNicResponse')
            kw["aname"] = "_AddServiceConsoleVirtualNicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "AddServiceConsoleVirtualNicResponse_Holder"
            self.pyclass = Holder

    class RemoveServiceConsoleVirtualNic_Dec(ElementDeclaration):
        literal = "RemoveServiceConsoleVirtualNic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveServiceConsoleVirtualNic')
            kw["aname"] = "_RemoveServiceConsoleVirtualNic"
            if ns0.RemoveServiceConsoleVirtualNicRequestType_Def not in ns0.RemoveServiceConsoleVirtualNic_Dec.__bases__:
                bases = list(ns0.RemoveServiceConsoleVirtualNic_Dec.__bases__)
                bases.insert(0, ns0.RemoveServiceConsoleVirtualNicRequestType_Def)
                ns0.RemoveServiceConsoleVirtualNic_Dec.__bases__ = tuple(bases)

            ns0.RemoveServiceConsoleVirtualNicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveServiceConsoleVirtualNic_Dec_Holder"

    class RemoveServiceConsoleVirtualNicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveServiceConsoleVirtualNicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveServiceConsoleVirtualNicResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveServiceConsoleVirtualNicResponse')
            kw["aname"] = "_RemoveServiceConsoleVirtualNicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveServiceConsoleVirtualNicResponse_Holder"
            self.pyclass = Holder

    class UpdateServiceConsoleVirtualNic_Dec(ElementDeclaration):
        literal = "UpdateServiceConsoleVirtualNic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateServiceConsoleVirtualNic')
            kw["aname"] = "_UpdateServiceConsoleVirtualNic"
            if ns0.UpdateServiceConsoleVirtualNicRequestType_Def not in ns0.UpdateServiceConsoleVirtualNic_Dec.__bases__:
                bases = list(ns0.UpdateServiceConsoleVirtualNic_Dec.__bases__)
                bases.insert(0, ns0.UpdateServiceConsoleVirtualNicRequestType_Def)
                ns0.UpdateServiceConsoleVirtualNic_Dec.__bases__ = tuple(bases)

            ns0.UpdateServiceConsoleVirtualNicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateServiceConsoleVirtualNic_Dec_Holder"

    class UpdateServiceConsoleVirtualNicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateServiceConsoleVirtualNicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateServiceConsoleVirtualNicResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateServiceConsoleVirtualNicResponse')
            kw["aname"] = "_UpdateServiceConsoleVirtualNicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateServiceConsoleVirtualNicResponse_Holder"
            self.pyclass = Holder

    class RestartServiceConsoleVirtualNic_Dec(ElementDeclaration):
        literal = "RestartServiceConsoleVirtualNic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RestartServiceConsoleVirtualNic')
            kw["aname"] = "_RestartServiceConsoleVirtualNic"
            if ns0.RestartServiceConsoleVirtualNicRequestType_Def not in ns0.RestartServiceConsoleVirtualNic_Dec.__bases__:
                bases = list(ns0.RestartServiceConsoleVirtualNic_Dec.__bases__)
                bases.insert(0, ns0.RestartServiceConsoleVirtualNicRequestType_Def)
                ns0.RestartServiceConsoleVirtualNic_Dec.__bases__ = tuple(bases)

            ns0.RestartServiceConsoleVirtualNicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RestartServiceConsoleVirtualNic_Dec_Holder"

    class RestartServiceConsoleVirtualNicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RestartServiceConsoleVirtualNicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RestartServiceConsoleVirtualNicResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RestartServiceConsoleVirtualNicResponse')
            kw["aname"] = "_RestartServiceConsoleVirtualNicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RestartServiceConsoleVirtualNicResponse_Holder"
            self.pyclass = Holder

    class RefreshNetworkSystem_Dec(ElementDeclaration):
        literal = "RefreshNetworkSystem"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshNetworkSystem')
            kw["aname"] = "_RefreshNetworkSystem"
            if ns0.RefreshNetworkSystemRequestType_Def not in ns0.RefreshNetworkSystem_Dec.__bases__:
                bases = list(ns0.RefreshNetworkSystem_Dec.__bases__)
                bases.insert(0, ns0.RefreshNetworkSystemRequestType_Def)
                ns0.RefreshNetworkSystem_Dec.__bases__ = tuple(bases)

            ns0.RefreshNetworkSystemRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshNetworkSystem_Dec_Holder"

    class RefreshNetworkSystemResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshNetworkSystemResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshNetworkSystemResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshNetworkSystemResponse')
            kw["aname"] = "_RefreshNetworkSystemResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshNetworkSystemResponse_Holder"
            self.pyclass = Holder

    class ScanHostPatch_Dec(ElementDeclaration):
        literal = "ScanHostPatch"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ScanHostPatch')
            kw["aname"] = "_ScanHostPatch"
            if ns0.ScanHostPatchRequestType_Def not in ns0.ScanHostPatch_Dec.__bases__:
                bases = list(ns0.ScanHostPatch_Dec.__bases__)
                bases.insert(0, ns0.ScanHostPatchRequestType_Def)
                ns0.ScanHostPatch_Dec.__bases__ = tuple(bases)

            ns0.ScanHostPatchRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ScanHostPatch_Dec_Holder"

    class ScanHostPatchResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ScanHostPatchResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ScanHostPatchResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostPatchManagerStatus",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ScanHostPatchResponse')
            kw["aname"] = "_ScanHostPatchResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ScanHostPatchResponse_Holder"
            self.pyclass = Holder

    class ScanHostPatch_Task_Dec(ElementDeclaration):
        literal = "ScanHostPatch_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ScanHostPatch_Task')
            kw["aname"] = "_ScanHostPatch_Task"
            if ns0.ScanHostPatchRequestType_Def not in ns0.ScanHostPatch_Task_Dec.__bases__:
                bases = list(ns0.ScanHostPatch_Task_Dec.__bases__)
                bases.insert(0, ns0.ScanHostPatchRequestType_Def)
                ns0.ScanHostPatch_Task_Dec.__bases__ = tuple(bases)

            ns0.ScanHostPatchRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ScanHostPatch_Task_Dec_Holder"

    class ScanHostPatch_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ScanHostPatch_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ScanHostPatch_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ScanHostPatch_TaskResponse')
            kw["aname"] = "_ScanHostPatch_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ScanHostPatch_TaskResponse_Holder"
            self.pyclass = Holder

    class InstallHostPatch_Dec(ElementDeclaration):
        literal = "InstallHostPatch"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InstallHostPatch')
            kw["aname"] = "_InstallHostPatch"
            if ns0.InstallHostPatchRequestType_Def not in ns0.InstallHostPatch_Dec.__bases__:
                bases = list(ns0.InstallHostPatch_Dec.__bases__)
                bases.insert(0, ns0.InstallHostPatchRequestType_Def)
                ns0.InstallHostPatch_Dec.__bases__ = tuple(bases)

            ns0.InstallHostPatchRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InstallHostPatch_Dec_Holder"

    class InstallHostPatchResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "InstallHostPatchResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.InstallHostPatchResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'InstallHostPatchResponse')
            kw["aname"] = "_InstallHostPatchResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "InstallHostPatchResponse_Holder"
            self.pyclass = Holder

    class InstallHostPatch_Task_Dec(ElementDeclaration):
        literal = "InstallHostPatch_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'InstallHostPatch_Task')
            kw["aname"] = "_InstallHostPatch_Task"
            if ns0.InstallHostPatchRequestType_Def not in ns0.InstallHostPatch_Task_Dec.__bases__:
                bases = list(ns0.InstallHostPatch_Task_Dec.__bases__)
                bases.insert(0, ns0.InstallHostPatchRequestType_Def)
                ns0.InstallHostPatch_Task_Dec.__bases__ = tuple(bases)

            ns0.InstallHostPatchRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "InstallHostPatch_Task_Dec_Holder"

    class InstallHostPatch_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "InstallHostPatch_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.InstallHostPatch_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'InstallHostPatch_TaskResponse')
            kw["aname"] = "_InstallHostPatch_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "InstallHostPatch_TaskResponse_Holder"
            self.pyclass = Holder

    class UpdateServicePolicy_Dec(ElementDeclaration):
        literal = "UpdateServicePolicy"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateServicePolicy')
            kw["aname"] = "_UpdateServicePolicy"
            if ns0.UpdateServicePolicyRequestType_Def not in ns0.UpdateServicePolicy_Dec.__bases__:
                bases = list(ns0.UpdateServicePolicy_Dec.__bases__)
                bases.insert(0, ns0.UpdateServicePolicyRequestType_Def)
                ns0.UpdateServicePolicy_Dec.__bases__ = tuple(bases)

            ns0.UpdateServicePolicyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateServicePolicy_Dec_Holder"

    class UpdateServicePolicyResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateServicePolicyResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateServicePolicyResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateServicePolicyResponse')
            kw["aname"] = "_UpdateServicePolicyResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateServicePolicyResponse_Holder"
            self.pyclass = Holder

    class StartService_Dec(ElementDeclaration):
        literal = "StartService"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'StartService')
            kw["aname"] = "_StartService"
            if ns0.StartServiceRequestType_Def not in ns0.StartService_Dec.__bases__:
                bases = list(ns0.StartService_Dec.__bases__)
                bases.insert(0, ns0.StartServiceRequestType_Def)
                ns0.StartService_Dec.__bases__ = tuple(bases)

            ns0.StartServiceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "StartService_Dec_Holder"

    class StartServiceResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "StartServiceResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.StartServiceResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'StartServiceResponse')
            kw["aname"] = "_StartServiceResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "StartServiceResponse_Holder"
            self.pyclass = Holder

    class StopService_Dec(ElementDeclaration):
        literal = "StopService"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'StopService')
            kw["aname"] = "_StopService"
            if ns0.StopServiceRequestType_Def not in ns0.StopService_Dec.__bases__:
                bases = list(ns0.StopService_Dec.__bases__)
                bases.insert(0, ns0.StopServiceRequestType_Def)
                ns0.StopService_Dec.__bases__ = tuple(bases)

            ns0.StopServiceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "StopService_Dec_Holder"

    class StopServiceResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "StopServiceResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.StopServiceResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'StopServiceResponse')
            kw["aname"] = "_StopServiceResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "StopServiceResponse_Holder"
            self.pyclass = Holder

    class RestartService_Dec(ElementDeclaration):
        literal = "RestartService"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RestartService')
            kw["aname"] = "_RestartService"
            if ns0.RestartServiceRequestType_Def not in ns0.RestartService_Dec.__bases__:
                bases = list(ns0.RestartService_Dec.__bases__)
                bases.insert(0, ns0.RestartServiceRequestType_Def)
                ns0.RestartService_Dec.__bases__ = tuple(bases)

            ns0.RestartServiceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RestartService_Dec_Holder"

    class RestartServiceResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RestartServiceResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RestartServiceResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RestartServiceResponse')
            kw["aname"] = "_RestartServiceResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RestartServiceResponse_Holder"
            self.pyclass = Holder

    class UninstallService_Dec(ElementDeclaration):
        literal = "UninstallService"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UninstallService')
            kw["aname"] = "_UninstallService"
            if ns0.UninstallServiceRequestType_Def not in ns0.UninstallService_Dec.__bases__:
                bases = list(ns0.UninstallService_Dec.__bases__)
                bases.insert(0, ns0.UninstallServiceRequestType_Def)
                ns0.UninstallService_Dec.__bases__ = tuple(bases)

            ns0.UninstallServiceRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UninstallService_Dec_Holder"

    class UninstallServiceResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UninstallServiceResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UninstallServiceResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UninstallServiceResponse')
            kw["aname"] = "_UninstallServiceResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UninstallServiceResponse_Holder"
            self.pyclass = Holder

    class RefreshServices_Dec(ElementDeclaration):
        literal = "RefreshServices"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshServices')
            kw["aname"] = "_RefreshServices"
            if ns0.RefreshServicesRequestType_Def not in ns0.RefreshServices_Dec.__bases__:
                bases = list(ns0.RefreshServices_Dec.__bases__)
                bases.insert(0, ns0.RefreshServicesRequestType_Def)
                ns0.RefreshServices_Dec.__bases__ = tuple(bases)

            ns0.RefreshServicesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshServices_Dec_Holder"

    class RefreshServicesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshServicesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshServicesResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshServicesResponse')
            kw["aname"] = "_RefreshServicesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshServicesResponse_Holder"
            self.pyclass = Holder

    class ReconfigureSnmpAgent_Dec(ElementDeclaration):
        literal = "ReconfigureSnmpAgent"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureSnmpAgent')
            kw["aname"] = "_ReconfigureSnmpAgent"
            if ns0.ReconfigureSnmpAgentRequestType_Def not in ns0.ReconfigureSnmpAgent_Dec.__bases__:
                bases = list(ns0.ReconfigureSnmpAgent_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureSnmpAgentRequestType_Def)
                ns0.ReconfigureSnmpAgent_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureSnmpAgentRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureSnmpAgent_Dec_Holder"

    class ReconfigureSnmpAgentResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureSnmpAgentResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureSnmpAgentResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureSnmpAgentResponse')
            kw["aname"] = "_ReconfigureSnmpAgentResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureSnmpAgentResponse_Holder"
            self.pyclass = Holder

    class SendTestNotification_Dec(ElementDeclaration):
        literal = "SendTestNotification"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SendTestNotification')
            kw["aname"] = "_SendTestNotification"
            if ns0.SendTestNotificationRequestType_Def not in ns0.SendTestNotification_Dec.__bases__:
                bases = list(ns0.SendTestNotification_Dec.__bases__)
                bases.insert(0, ns0.SendTestNotificationRequestType_Def)
                ns0.SendTestNotification_Dec.__bases__ = tuple(bases)

            ns0.SendTestNotificationRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SendTestNotification_Dec_Holder"

    class SendTestNotificationResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SendTestNotificationResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SendTestNotificationResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SendTestNotificationResponse')
            kw["aname"] = "_SendTestNotificationResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SendTestNotificationResponse_Holder"
            self.pyclass = Holder

    class RetrieveDiskPartitionInfo_Dec(ElementDeclaration):
        literal = "RetrieveDiskPartitionInfo"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveDiskPartitionInfo')
            kw["aname"] = "_RetrieveDiskPartitionInfo"
            if ns0.RetrieveDiskPartitionInfoRequestType_Def not in ns0.RetrieveDiskPartitionInfo_Dec.__bases__:
                bases = list(ns0.RetrieveDiskPartitionInfo_Dec.__bases__)
                bases.insert(0, ns0.RetrieveDiskPartitionInfoRequestType_Def)
                ns0.RetrieveDiskPartitionInfo_Dec.__bases__ = tuple(bases)

            ns0.RetrieveDiskPartitionInfoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveDiskPartitionInfo_Dec_Holder"

    class RetrieveDiskPartitionInfoResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveDiskPartitionInfoResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveDiskPartitionInfoResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveDiskPartitionInfoResponse')
            kw["aname"] = "_RetrieveDiskPartitionInfoResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrieveDiskPartitionInfoResponse_Holder"
            self.pyclass = Holder

    class ComputeDiskPartitionInfo_Dec(ElementDeclaration):
        literal = "ComputeDiskPartitionInfo"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ComputeDiskPartitionInfo')
            kw["aname"] = "_ComputeDiskPartitionInfo"
            if ns0.ComputeDiskPartitionInfoRequestType_Def not in ns0.ComputeDiskPartitionInfo_Dec.__bases__:
                bases = list(ns0.ComputeDiskPartitionInfo_Dec.__bases__)
                bases.insert(0, ns0.ComputeDiskPartitionInfoRequestType_Def)
                ns0.ComputeDiskPartitionInfo_Dec.__bases__ = tuple(bases)

            ns0.ComputeDiskPartitionInfoRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ComputeDiskPartitionInfo_Dec_Holder"

    class ComputeDiskPartitionInfoResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ComputeDiskPartitionInfoResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ComputeDiskPartitionInfoResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostDiskPartitionInfo",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ComputeDiskPartitionInfoResponse')
            kw["aname"] = "_ComputeDiskPartitionInfoResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "ComputeDiskPartitionInfoResponse_Holder"
            self.pyclass = Holder

    class UpdateDiskPartitions_Dec(ElementDeclaration):
        literal = "UpdateDiskPartitions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateDiskPartitions')
            kw["aname"] = "_UpdateDiskPartitions"
            if ns0.UpdateDiskPartitionsRequestType_Def not in ns0.UpdateDiskPartitions_Dec.__bases__:
                bases = list(ns0.UpdateDiskPartitions_Dec.__bases__)
                bases.insert(0, ns0.UpdateDiskPartitionsRequestType_Def)
                ns0.UpdateDiskPartitions_Dec.__bases__ = tuple(bases)

            ns0.UpdateDiskPartitionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateDiskPartitions_Dec_Holder"

    class UpdateDiskPartitionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateDiskPartitionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateDiskPartitionsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateDiskPartitionsResponse')
            kw["aname"] = "_UpdateDiskPartitionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateDiskPartitionsResponse_Holder"
            self.pyclass = Holder

    class FormatVmfs_Dec(ElementDeclaration):
        literal = "FormatVmfs"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'FormatVmfs')
            kw["aname"] = "_FormatVmfs"
            if ns0.FormatVmfsRequestType_Def not in ns0.FormatVmfs_Dec.__bases__:
                bases = list(ns0.FormatVmfs_Dec.__bases__)
                bases.insert(0, ns0.FormatVmfsRequestType_Def)
                ns0.FormatVmfs_Dec.__bases__ = tuple(bases)

            ns0.FormatVmfsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "FormatVmfs_Dec_Holder"

    class FormatVmfsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "FormatVmfsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.FormatVmfsResponse_Dec.schema
            TClist = [GTD("urn:vim25","HostVmfsVolume",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'FormatVmfsResponse')
            kw["aname"] = "_FormatVmfsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "FormatVmfsResponse_Holder"
            self.pyclass = Holder

    class RescanVmfs_Dec(ElementDeclaration):
        literal = "RescanVmfs"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RescanVmfs')
            kw["aname"] = "_RescanVmfs"
            if ns0.RescanVmfsRequestType_Def not in ns0.RescanVmfs_Dec.__bases__:
                bases = list(ns0.RescanVmfs_Dec.__bases__)
                bases.insert(0, ns0.RescanVmfsRequestType_Def)
                ns0.RescanVmfs_Dec.__bases__ = tuple(bases)

            ns0.RescanVmfsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RescanVmfs_Dec_Holder"

    class RescanVmfsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RescanVmfsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RescanVmfsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RescanVmfsResponse')
            kw["aname"] = "_RescanVmfsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RescanVmfsResponse_Holder"
            self.pyclass = Holder

    class AttachVmfsExtent_Dec(ElementDeclaration):
        literal = "AttachVmfsExtent"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AttachVmfsExtent')
            kw["aname"] = "_AttachVmfsExtent"
            if ns0.AttachVmfsExtentRequestType_Def not in ns0.AttachVmfsExtent_Dec.__bases__:
                bases = list(ns0.AttachVmfsExtent_Dec.__bases__)
                bases.insert(0, ns0.AttachVmfsExtentRequestType_Def)
                ns0.AttachVmfsExtent_Dec.__bases__ = tuple(bases)

            ns0.AttachVmfsExtentRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AttachVmfsExtent_Dec_Holder"

    class AttachVmfsExtentResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AttachVmfsExtentResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AttachVmfsExtentResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AttachVmfsExtentResponse')
            kw["aname"] = "_AttachVmfsExtentResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AttachVmfsExtentResponse_Holder"
            self.pyclass = Holder

    class UpgradeVmfs_Dec(ElementDeclaration):
        literal = "UpgradeVmfs"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpgradeVmfs')
            kw["aname"] = "_UpgradeVmfs"
            if ns0.UpgradeVmfsRequestType_Def not in ns0.UpgradeVmfs_Dec.__bases__:
                bases = list(ns0.UpgradeVmfs_Dec.__bases__)
                bases.insert(0, ns0.UpgradeVmfsRequestType_Def)
                ns0.UpgradeVmfs_Dec.__bases__ = tuple(bases)

            ns0.UpgradeVmfsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpgradeVmfs_Dec_Holder"

    class UpgradeVmfsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpgradeVmfsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpgradeVmfsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpgradeVmfsResponse')
            kw["aname"] = "_UpgradeVmfsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpgradeVmfsResponse_Holder"
            self.pyclass = Holder

    class UpgradeVmLayout_Dec(ElementDeclaration):
        literal = "UpgradeVmLayout"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpgradeVmLayout')
            kw["aname"] = "_UpgradeVmLayout"
            if ns0.UpgradeVmLayoutRequestType_Def not in ns0.UpgradeVmLayout_Dec.__bases__:
                bases = list(ns0.UpgradeVmLayout_Dec.__bases__)
                bases.insert(0, ns0.UpgradeVmLayoutRequestType_Def)
                ns0.UpgradeVmLayout_Dec.__bases__ = tuple(bases)

            ns0.UpgradeVmLayoutRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpgradeVmLayout_Dec_Holder"

    class UpgradeVmLayoutResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpgradeVmLayoutResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpgradeVmLayoutResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpgradeVmLayoutResponse')
            kw["aname"] = "_UpgradeVmLayoutResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpgradeVmLayoutResponse_Holder"
            self.pyclass = Holder

    class RescanHba_Dec(ElementDeclaration):
        literal = "RescanHba"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RescanHba')
            kw["aname"] = "_RescanHba"
            if ns0.RescanHbaRequestType_Def not in ns0.RescanHba_Dec.__bases__:
                bases = list(ns0.RescanHba_Dec.__bases__)
                bases.insert(0, ns0.RescanHbaRequestType_Def)
                ns0.RescanHba_Dec.__bases__ = tuple(bases)

            ns0.RescanHbaRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RescanHba_Dec_Holder"

    class RescanHbaResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RescanHbaResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RescanHbaResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RescanHbaResponse')
            kw["aname"] = "_RescanHbaResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RescanHbaResponse_Holder"
            self.pyclass = Holder

    class RescanAllHba_Dec(ElementDeclaration):
        literal = "RescanAllHba"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RescanAllHba')
            kw["aname"] = "_RescanAllHba"
            if ns0.RescanAllHbaRequestType_Def not in ns0.RescanAllHba_Dec.__bases__:
                bases = list(ns0.RescanAllHba_Dec.__bases__)
                bases.insert(0, ns0.RescanAllHbaRequestType_Def)
                ns0.RescanAllHba_Dec.__bases__ = tuple(bases)

            ns0.RescanAllHbaRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RescanAllHba_Dec_Holder"

    class RescanAllHbaResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RescanAllHbaResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RescanAllHbaResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RescanAllHbaResponse')
            kw["aname"] = "_RescanAllHbaResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RescanAllHbaResponse_Holder"
            self.pyclass = Holder

    class UpdateSoftwareInternetScsiEnabled_Dec(ElementDeclaration):
        literal = "UpdateSoftwareInternetScsiEnabled"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateSoftwareInternetScsiEnabled')
            kw["aname"] = "_UpdateSoftwareInternetScsiEnabled"
            if ns0.UpdateSoftwareInternetScsiEnabledRequestType_Def not in ns0.UpdateSoftwareInternetScsiEnabled_Dec.__bases__:
                bases = list(ns0.UpdateSoftwareInternetScsiEnabled_Dec.__bases__)
                bases.insert(0, ns0.UpdateSoftwareInternetScsiEnabledRequestType_Def)
                ns0.UpdateSoftwareInternetScsiEnabled_Dec.__bases__ = tuple(bases)

            ns0.UpdateSoftwareInternetScsiEnabledRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateSoftwareInternetScsiEnabled_Dec_Holder"

    class UpdateSoftwareInternetScsiEnabledResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateSoftwareInternetScsiEnabledResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateSoftwareInternetScsiEnabledResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateSoftwareInternetScsiEnabledResponse')
            kw["aname"] = "_UpdateSoftwareInternetScsiEnabledResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateSoftwareInternetScsiEnabledResponse_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiDiscoveryProperties_Dec(ElementDeclaration):
        literal = "UpdateInternetScsiDiscoveryProperties"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiDiscoveryProperties')
            kw["aname"] = "_UpdateInternetScsiDiscoveryProperties"
            if ns0.UpdateInternetScsiDiscoveryPropertiesRequestType_Def not in ns0.UpdateInternetScsiDiscoveryProperties_Dec.__bases__:
                bases = list(ns0.UpdateInternetScsiDiscoveryProperties_Dec.__bases__)
                bases.insert(0, ns0.UpdateInternetScsiDiscoveryPropertiesRequestType_Def)
                ns0.UpdateInternetScsiDiscoveryProperties_Dec.__bases__ = tuple(bases)

            ns0.UpdateInternetScsiDiscoveryPropertiesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateInternetScsiDiscoveryProperties_Dec_Holder"

    class UpdateInternetScsiDiscoveryPropertiesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateInternetScsiDiscoveryPropertiesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateInternetScsiDiscoveryPropertiesResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiDiscoveryPropertiesResponse')
            kw["aname"] = "_UpdateInternetScsiDiscoveryPropertiesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateInternetScsiDiscoveryPropertiesResponse_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiAuthenticationProperties_Dec(ElementDeclaration):
        literal = "UpdateInternetScsiAuthenticationProperties"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiAuthenticationProperties')
            kw["aname"] = "_UpdateInternetScsiAuthenticationProperties"
            if ns0.UpdateInternetScsiAuthenticationPropertiesRequestType_Def not in ns0.UpdateInternetScsiAuthenticationProperties_Dec.__bases__:
                bases = list(ns0.UpdateInternetScsiAuthenticationProperties_Dec.__bases__)
                bases.insert(0, ns0.UpdateInternetScsiAuthenticationPropertiesRequestType_Def)
                ns0.UpdateInternetScsiAuthenticationProperties_Dec.__bases__ = tuple(bases)

            ns0.UpdateInternetScsiAuthenticationPropertiesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateInternetScsiAuthenticationProperties_Dec_Holder"

    class UpdateInternetScsiAuthenticationPropertiesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateInternetScsiAuthenticationPropertiesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateInternetScsiAuthenticationPropertiesResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiAuthenticationPropertiesResponse')
            kw["aname"] = "_UpdateInternetScsiAuthenticationPropertiesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateInternetScsiAuthenticationPropertiesResponse_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiIPProperties_Dec(ElementDeclaration):
        literal = "UpdateInternetScsiIPProperties"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiIPProperties')
            kw["aname"] = "_UpdateInternetScsiIPProperties"
            if ns0.UpdateInternetScsiIPPropertiesRequestType_Def not in ns0.UpdateInternetScsiIPProperties_Dec.__bases__:
                bases = list(ns0.UpdateInternetScsiIPProperties_Dec.__bases__)
                bases.insert(0, ns0.UpdateInternetScsiIPPropertiesRequestType_Def)
                ns0.UpdateInternetScsiIPProperties_Dec.__bases__ = tuple(bases)

            ns0.UpdateInternetScsiIPPropertiesRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateInternetScsiIPProperties_Dec_Holder"

    class UpdateInternetScsiIPPropertiesResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateInternetScsiIPPropertiesResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateInternetScsiIPPropertiesResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiIPPropertiesResponse')
            kw["aname"] = "_UpdateInternetScsiIPPropertiesResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateInternetScsiIPPropertiesResponse_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiName_Dec(ElementDeclaration):
        literal = "UpdateInternetScsiName"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiName')
            kw["aname"] = "_UpdateInternetScsiName"
            if ns0.UpdateInternetScsiNameRequestType_Def not in ns0.UpdateInternetScsiName_Dec.__bases__:
                bases = list(ns0.UpdateInternetScsiName_Dec.__bases__)
                bases.insert(0, ns0.UpdateInternetScsiNameRequestType_Def)
                ns0.UpdateInternetScsiName_Dec.__bases__ = tuple(bases)

            ns0.UpdateInternetScsiNameRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateInternetScsiName_Dec_Holder"

    class UpdateInternetScsiNameResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateInternetScsiNameResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateInternetScsiNameResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiNameResponse')
            kw["aname"] = "_UpdateInternetScsiNameResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateInternetScsiNameResponse_Holder"
            self.pyclass = Holder

    class UpdateInternetScsiAlias_Dec(ElementDeclaration):
        literal = "UpdateInternetScsiAlias"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiAlias')
            kw["aname"] = "_UpdateInternetScsiAlias"
            if ns0.UpdateInternetScsiAliasRequestType_Def not in ns0.UpdateInternetScsiAlias_Dec.__bases__:
                bases = list(ns0.UpdateInternetScsiAlias_Dec.__bases__)
                bases.insert(0, ns0.UpdateInternetScsiAliasRequestType_Def)
                ns0.UpdateInternetScsiAlias_Dec.__bases__ = tuple(bases)

            ns0.UpdateInternetScsiAliasRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateInternetScsiAlias_Dec_Holder"

    class UpdateInternetScsiAliasResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateInternetScsiAliasResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateInternetScsiAliasResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateInternetScsiAliasResponse')
            kw["aname"] = "_UpdateInternetScsiAliasResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateInternetScsiAliasResponse_Holder"
            self.pyclass = Holder

    class AddInternetScsiSendTargets_Dec(ElementDeclaration):
        literal = "AddInternetScsiSendTargets"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddInternetScsiSendTargets')
            kw["aname"] = "_AddInternetScsiSendTargets"
            if ns0.AddInternetScsiSendTargetsRequestType_Def not in ns0.AddInternetScsiSendTargets_Dec.__bases__:
                bases = list(ns0.AddInternetScsiSendTargets_Dec.__bases__)
                bases.insert(0, ns0.AddInternetScsiSendTargetsRequestType_Def)
                ns0.AddInternetScsiSendTargets_Dec.__bases__ = tuple(bases)

            ns0.AddInternetScsiSendTargetsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddInternetScsiSendTargets_Dec_Holder"

    class AddInternetScsiSendTargetsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddInternetScsiSendTargetsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddInternetScsiSendTargetsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AddInternetScsiSendTargetsResponse')
            kw["aname"] = "_AddInternetScsiSendTargetsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AddInternetScsiSendTargetsResponse_Holder"
            self.pyclass = Holder

    class RemoveInternetScsiSendTargets_Dec(ElementDeclaration):
        literal = "RemoveInternetScsiSendTargets"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveInternetScsiSendTargets')
            kw["aname"] = "_RemoveInternetScsiSendTargets"
            if ns0.RemoveInternetScsiSendTargetsRequestType_Def not in ns0.RemoveInternetScsiSendTargets_Dec.__bases__:
                bases = list(ns0.RemoveInternetScsiSendTargets_Dec.__bases__)
                bases.insert(0, ns0.RemoveInternetScsiSendTargetsRequestType_Def)
                ns0.RemoveInternetScsiSendTargets_Dec.__bases__ = tuple(bases)

            ns0.RemoveInternetScsiSendTargetsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveInternetScsiSendTargets_Dec_Holder"

    class RemoveInternetScsiSendTargetsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveInternetScsiSendTargetsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveInternetScsiSendTargetsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveInternetScsiSendTargetsResponse')
            kw["aname"] = "_RemoveInternetScsiSendTargetsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveInternetScsiSendTargetsResponse_Holder"
            self.pyclass = Holder

    class AddInternetScsiStaticTargets_Dec(ElementDeclaration):
        literal = "AddInternetScsiStaticTargets"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'AddInternetScsiStaticTargets')
            kw["aname"] = "_AddInternetScsiStaticTargets"
            if ns0.AddInternetScsiStaticTargetsRequestType_Def not in ns0.AddInternetScsiStaticTargets_Dec.__bases__:
                bases = list(ns0.AddInternetScsiStaticTargets_Dec.__bases__)
                bases.insert(0, ns0.AddInternetScsiStaticTargetsRequestType_Def)
                ns0.AddInternetScsiStaticTargets_Dec.__bases__ = tuple(bases)

            ns0.AddInternetScsiStaticTargetsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "AddInternetScsiStaticTargets_Dec_Holder"

    class AddInternetScsiStaticTargetsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "AddInternetScsiStaticTargetsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.AddInternetScsiStaticTargetsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'AddInternetScsiStaticTargetsResponse')
            kw["aname"] = "_AddInternetScsiStaticTargetsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "AddInternetScsiStaticTargetsResponse_Holder"
            self.pyclass = Holder

    class RemoveInternetScsiStaticTargets_Dec(ElementDeclaration):
        literal = "RemoveInternetScsiStaticTargets"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveInternetScsiStaticTargets')
            kw["aname"] = "_RemoveInternetScsiStaticTargets"
            if ns0.RemoveInternetScsiStaticTargetsRequestType_Def not in ns0.RemoveInternetScsiStaticTargets_Dec.__bases__:
                bases = list(ns0.RemoveInternetScsiStaticTargets_Dec.__bases__)
                bases.insert(0, ns0.RemoveInternetScsiStaticTargetsRequestType_Def)
                ns0.RemoveInternetScsiStaticTargets_Dec.__bases__ = tuple(bases)

            ns0.RemoveInternetScsiStaticTargetsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveInternetScsiStaticTargets_Dec_Holder"

    class RemoveInternetScsiStaticTargetsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveInternetScsiStaticTargetsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveInternetScsiStaticTargetsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveInternetScsiStaticTargetsResponse')
            kw["aname"] = "_RemoveInternetScsiStaticTargetsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveInternetScsiStaticTargetsResponse_Holder"
            self.pyclass = Holder

    class EnableMultipathPath_Dec(ElementDeclaration):
        literal = "EnableMultipathPath"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'EnableMultipathPath')
            kw["aname"] = "_EnableMultipathPath"
            if ns0.EnableMultipathPathRequestType_Def not in ns0.EnableMultipathPath_Dec.__bases__:
                bases = list(ns0.EnableMultipathPath_Dec.__bases__)
                bases.insert(0, ns0.EnableMultipathPathRequestType_Def)
                ns0.EnableMultipathPath_Dec.__bases__ = tuple(bases)

            ns0.EnableMultipathPathRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "EnableMultipathPath_Dec_Holder"

    class EnableMultipathPathResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "EnableMultipathPathResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.EnableMultipathPathResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'EnableMultipathPathResponse')
            kw["aname"] = "_EnableMultipathPathResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "EnableMultipathPathResponse_Holder"
            self.pyclass = Holder

    class DisableMultipathPath_Dec(ElementDeclaration):
        literal = "DisableMultipathPath"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DisableMultipathPath')
            kw["aname"] = "_DisableMultipathPath"
            if ns0.DisableMultipathPathRequestType_Def not in ns0.DisableMultipathPath_Dec.__bases__:
                bases = list(ns0.DisableMultipathPath_Dec.__bases__)
                bases.insert(0, ns0.DisableMultipathPathRequestType_Def)
                ns0.DisableMultipathPath_Dec.__bases__ = tuple(bases)

            ns0.DisableMultipathPathRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DisableMultipathPath_Dec_Holder"

    class DisableMultipathPathResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DisableMultipathPathResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DisableMultipathPathResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DisableMultipathPathResponse')
            kw["aname"] = "_DisableMultipathPathResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DisableMultipathPathResponse_Holder"
            self.pyclass = Holder

    class SetMultipathLunPolicy_Dec(ElementDeclaration):
        literal = "SetMultipathLunPolicy"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SetMultipathLunPolicy')
            kw["aname"] = "_SetMultipathLunPolicy"
            if ns0.SetMultipathLunPolicyRequestType_Def not in ns0.SetMultipathLunPolicy_Dec.__bases__:
                bases = list(ns0.SetMultipathLunPolicy_Dec.__bases__)
                bases.insert(0, ns0.SetMultipathLunPolicyRequestType_Def)
                ns0.SetMultipathLunPolicy_Dec.__bases__ = tuple(bases)

            ns0.SetMultipathLunPolicyRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SetMultipathLunPolicy_Dec_Holder"

    class SetMultipathLunPolicyResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SetMultipathLunPolicyResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SetMultipathLunPolicyResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SetMultipathLunPolicyResponse')
            kw["aname"] = "_SetMultipathLunPolicyResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SetMultipathLunPolicyResponse_Holder"
            self.pyclass = Holder

    class RefreshStorageSystem_Dec(ElementDeclaration):
        literal = "RefreshStorageSystem"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RefreshStorageSystem')
            kw["aname"] = "_RefreshStorageSystem"
            if ns0.RefreshStorageSystemRequestType_Def not in ns0.RefreshStorageSystem_Dec.__bases__:
                bases = list(ns0.RefreshStorageSystem_Dec.__bases__)
                bases.insert(0, ns0.RefreshStorageSystemRequestType_Def)
                ns0.RefreshStorageSystem_Dec.__bases__ = tuple(bases)

            ns0.RefreshStorageSystemRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RefreshStorageSystem_Dec_Holder"

    class RefreshStorageSystemResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RefreshStorageSystemResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RefreshStorageSystemResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RefreshStorageSystemResponse')
            kw["aname"] = "_RefreshStorageSystemResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RefreshStorageSystemResponse_Holder"
            self.pyclass = Holder

    class UpdateIpConfig_Dec(ElementDeclaration):
        literal = "UpdateIpConfig"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateIpConfig')
            kw["aname"] = "_UpdateIpConfig"
            if ns0.UpdateIpConfigRequestType_Def not in ns0.UpdateIpConfig_Dec.__bases__:
                bases = list(ns0.UpdateIpConfig_Dec.__bases__)
                bases.insert(0, ns0.UpdateIpConfigRequestType_Def)
                ns0.UpdateIpConfig_Dec.__bases__ = tuple(bases)

            ns0.UpdateIpConfigRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateIpConfig_Dec_Holder"

    class UpdateIpConfigResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateIpConfigResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateIpConfigResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateIpConfigResponse')
            kw["aname"] = "_UpdateIpConfigResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateIpConfigResponse_Holder"
            self.pyclass = Holder

    class SelectVnic_Dec(ElementDeclaration):
        literal = "SelectVnic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'SelectVnic')
            kw["aname"] = "_SelectVnic"
            if ns0.SelectVnicRequestType_Def not in ns0.SelectVnic_Dec.__bases__:
                bases = list(ns0.SelectVnic_Dec.__bases__)
                bases.insert(0, ns0.SelectVnicRequestType_Def)
                ns0.SelectVnic_Dec.__bases__ = tuple(bases)

            ns0.SelectVnicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "SelectVnic_Dec_Holder"

    class SelectVnicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "SelectVnicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.SelectVnicResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'SelectVnicResponse')
            kw["aname"] = "_SelectVnicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "SelectVnicResponse_Holder"
            self.pyclass = Holder

    class DeselectVnic_Dec(ElementDeclaration):
        literal = "DeselectVnic"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DeselectVnic')
            kw["aname"] = "_DeselectVnic"
            if ns0.DeselectVnicRequestType_Def not in ns0.DeselectVnic_Dec.__bases__:
                bases = list(ns0.DeselectVnic_Dec.__bases__)
                bases.insert(0, ns0.DeselectVnicRequestType_Def)
                ns0.DeselectVnic_Dec.__bases__ = tuple(bases)

            ns0.DeselectVnicRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DeselectVnic_Dec_Holder"

    class DeselectVnicResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DeselectVnicResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DeselectVnicResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DeselectVnicResponse')
            kw["aname"] = "_DeselectVnicResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DeselectVnicResponse_Holder"
            self.pyclass = Holder

    class QueryOptions_Dec(ElementDeclaration):
        literal = "QueryOptions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'QueryOptions')
            kw["aname"] = "_QueryOptions"
            if ns0.QueryOptionsRequestType_Def not in ns0.QueryOptions_Dec.__bases__:
                bases = list(ns0.QueryOptions_Dec.__bases__)
                bases.insert(0, ns0.QueryOptionsRequestType_Def)
                ns0.QueryOptions_Dec.__bases__ = tuple(bases)

            ns0.QueryOptionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "QueryOptions_Dec_Holder"

    class QueryOptionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "QueryOptionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.QueryOptionsResponse_Dec.schema
            TClist = [GTD("urn:vim25","OptionValue",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'QueryOptionsResponse')
            kw["aname"] = "_QueryOptionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "QueryOptionsResponse_Holder"
            self.pyclass = Holder

    class UpdateOptions_Dec(ElementDeclaration):
        literal = "UpdateOptions"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'UpdateOptions')
            kw["aname"] = "_UpdateOptions"
            if ns0.UpdateOptionsRequestType_Def not in ns0.UpdateOptions_Dec.__bases__:
                bases = list(ns0.UpdateOptions_Dec.__bases__)
                bases.insert(0, ns0.UpdateOptionsRequestType_Def)
                ns0.UpdateOptions_Dec.__bases__ = tuple(bases)

            ns0.UpdateOptionsRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "UpdateOptions_Dec_Holder"

    class UpdateOptionsResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "UpdateOptionsResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.UpdateOptionsResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'UpdateOptionsResponse')
            kw["aname"] = "_UpdateOptionsResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "UpdateOptionsResponse_Holder"
            self.pyclass = Holder

    class RemoveScheduledTask_Dec(ElementDeclaration):
        literal = "RemoveScheduledTask"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveScheduledTask')
            kw["aname"] = "_RemoveScheduledTask"
            if ns0.RemoveScheduledTaskRequestType_Def not in ns0.RemoveScheduledTask_Dec.__bases__:
                bases = list(ns0.RemoveScheduledTask_Dec.__bases__)
                bases.insert(0, ns0.RemoveScheduledTaskRequestType_Def)
                ns0.RemoveScheduledTask_Dec.__bases__ = tuple(bases)

            ns0.RemoveScheduledTaskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveScheduledTask_Dec_Holder"

    class RemoveScheduledTaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveScheduledTaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveScheduledTaskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveScheduledTaskResponse')
            kw["aname"] = "_RemoveScheduledTaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveScheduledTaskResponse_Holder"
            self.pyclass = Holder

    class ReconfigureScheduledTask_Dec(ElementDeclaration):
        literal = "ReconfigureScheduledTask"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ReconfigureScheduledTask')
            kw["aname"] = "_ReconfigureScheduledTask"
            if ns0.ReconfigureScheduledTaskRequestType_Def not in ns0.ReconfigureScheduledTask_Dec.__bases__:
                bases = list(ns0.ReconfigureScheduledTask_Dec.__bases__)
                bases.insert(0, ns0.ReconfigureScheduledTaskRequestType_Def)
                ns0.ReconfigureScheduledTask_Dec.__bases__ = tuple(bases)

            ns0.ReconfigureScheduledTaskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ReconfigureScheduledTask_Dec_Holder"

    class ReconfigureScheduledTaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ReconfigureScheduledTaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ReconfigureScheduledTaskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ReconfigureScheduledTaskResponse')
            kw["aname"] = "_ReconfigureScheduledTaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ReconfigureScheduledTaskResponse_Holder"
            self.pyclass = Holder

    class RunScheduledTask_Dec(ElementDeclaration):
        literal = "RunScheduledTask"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RunScheduledTask')
            kw["aname"] = "_RunScheduledTask"
            if ns0.RunScheduledTaskRequestType_Def not in ns0.RunScheduledTask_Dec.__bases__:
                bases = list(ns0.RunScheduledTask_Dec.__bases__)
                bases.insert(0, ns0.RunScheduledTaskRequestType_Def)
                ns0.RunScheduledTask_Dec.__bases__ = tuple(bases)

            ns0.RunScheduledTaskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RunScheduledTask_Dec_Holder"

    class RunScheduledTaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RunScheduledTaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RunScheduledTaskResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RunScheduledTaskResponse')
            kw["aname"] = "_RunScheduledTaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RunScheduledTaskResponse_Holder"
            self.pyclass = Holder

    class CreateScheduledTask_Dec(ElementDeclaration):
        literal = "CreateScheduledTask"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateScheduledTask')
            kw["aname"] = "_CreateScheduledTask"
            if ns0.CreateScheduledTaskRequestType_Def not in ns0.CreateScheduledTask_Dec.__bases__:
                bases = list(ns0.CreateScheduledTask_Dec.__bases__)
                bases.insert(0, ns0.CreateScheduledTaskRequestType_Def)
                ns0.CreateScheduledTask_Dec.__bases__ = tuple(bases)

            ns0.CreateScheduledTaskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateScheduledTask_Dec_Holder"

    class CreateScheduledTaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateScheduledTaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateScheduledTaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateScheduledTaskResponse')
            kw["aname"] = "_CreateScheduledTaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateScheduledTaskResponse_Holder"
            self.pyclass = Holder

    class RetrieveEntityScheduledTask_Dec(ElementDeclaration):
        literal = "RetrieveEntityScheduledTask"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RetrieveEntityScheduledTask')
            kw["aname"] = "_RetrieveEntityScheduledTask"
            if ns0.RetrieveEntityScheduledTaskRequestType_Def not in ns0.RetrieveEntityScheduledTask_Dec.__bases__:
                bases = list(ns0.RetrieveEntityScheduledTask_Dec.__bases__)
                bases.insert(0, ns0.RetrieveEntityScheduledTaskRequestType_Def)
                ns0.RetrieveEntityScheduledTask_Dec.__bases__ = tuple(bases)

            ns0.RetrieveEntityScheduledTaskRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RetrieveEntityScheduledTask_Dec_Holder"

    class RetrieveEntityScheduledTaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RetrieveEntityScheduledTaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RetrieveEntityScheduledTaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RetrieveEntityScheduledTaskResponse')
            kw["aname"] = "_RetrieveEntityScheduledTaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "RetrieveEntityScheduledTaskResponse_Holder"
            self.pyclass = Holder

    class OpenInventoryViewFolder_Dec(ElementDeclaration):
        literal = "OpenInventoryViewFolder"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'OpenInventoryViewFolder')
            kw["aname"] = "_OpenInventoryViewFolder"
            if ns0.OpenInventoryViewFolderRequestType_Def not in ns0.OpenInventoryViewFolder_Dec.__bases__:
                bases = list(ns0.OpenInventoryViewFolder_Dec.__bases__)
                bases.insert(0, ns0.OpenInventoryViewFolderRequestType_Def)
                ns0.OpenInventoryViewFolder_Dec.__bases__ = tuple(bases)

            ns0.OpenInventoryViewFolderRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "OpenInventoryViewFolder_Dec_Holder"

    class OpenInventoryViewFolderResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "OpenInventoryViewFolderResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.OpenInventoryViewFolderResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'OpenInventoryViewFolderResponse')
            kw["aname"] = "_OpenInventoryViewFolderResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "OpenInventoryViewFolderResponse_Holder"
            self.pyclass = Holder

    class CloseInventoryViewFolder_Dec(ElementDeclaration):
        literal = "CloseInventoryViewFolder"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CloseInventoryViewFolder')
            kw["aname"] = "_CloseInventoryViewFolder"
            if ns0.CloseInventoryViewFolderRequestType_Def not in ns0.CloseInventoryViewFolder_Dec.__bases__:
                bases = list(ns0.CloseInventoryViewFolder_Dec.__bases__)
                bases.insert(0, ns0.CloseInventoryViewFolderRequestType_Def)
                ns0.CloseInventoryViewFolder_Dec.__bases__ = tuple(bases)

            ns0.CloseInventoryViewFolderRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CloseInventoryViewFolder_Dec_Holder"

    class CloseInventoryViewFolderResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CloseInventoryViewFolderResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CloseInventoryViewFolderResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CloseInventoryViewFolderResponse')
            kw["aname"] = "_CloseInventoryViewFolderResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "CloseInventoryViewFolderResponse_Holder"
            self.pyclass = Holder

    class ModifyListView_Dec(ElementDeclaration):
        literal = "ModifyListView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ModifyListView')
            kw["aname"] = "_ModifyListView"
            if ns0.ModifyListViewRequestType_Def not in ns0.ModifyListView_Dec.__bases__:
                bases = list(ns0.ModifyListView_Dec.__bases__)
                bases.insert(0, ns0.ModifyListViewRequestType_Def)
                ns0.ModifyListView_Dec.__bases__ = tuple(bases)

            ns0.ModifyListViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ModifyListView_Dec_Holder"

    class ModifyListViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ModifyListViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ModifyListViewResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ModifyListViewResponse')
            kw["aname"] = "_ModifyListViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ModifyListViewResponse_Holder"
            self.pyclass = Holder

    class ResetListView_Dec(ElementDeclaration):
        literal = "ResetListView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetListView')
            kw["aname"] = "_ResetListView"
            if ns0.ResetListViewRequestType_Def not in ns0.ResetListView_Dec.__bases__:
                bases = list(ns0.ResetListView_Dec.__bases__)
                bases.insert(0, ns0.ResetListViewRequestType_Def)
                ns0.ResetListView_Dec.__bases__ = tuple(bases)

            ns0.ResetListViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetListView_Dec_Holder"

    class ResetListViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetListViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetListViewResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=0, maxOccurs="unbounded", nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'ResetListViewResponse')
            kw["aname"] = "_ResetListViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = []
                    return
            Holder.__name__ = "ResetListViewResponse_Holder"
            self.pyclass = Holder

    class ResetListViewFromView_Dec(ElementDeclaration):
        literal = "ResetListViewFromView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'ResetListViewFromView')
            kw["aname"] = "_ResetListViewFromView"
            if ns0.ResetListViewFromViewRequestType_Def not in ns0.ResetListViewFromView_Dec.__bases__:
                bases = list(ns0.ResetListViewFromView_Dec.__bases__)
                bases.insert(0, ns0.ResetListViewFromViewRequestType_Def)
                ns0.ResetListViewFromView_Dec.__bases__ = tuple(bases)

            ns0.ResetListViewFromViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "ResetListViewFromView_Dec_Holder"

    class ResetListViewFromViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "ResetListViewFromViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.ResetListViewFromViewResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'ResetListViewFromViewResponse')
            kw["aname"] = "_ResetListViewFromViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "ResetListViewFromViewResponse_Holder"
            self.pyclass = Holder

    class DestroyView_Dec(ElementDeclaration):
        literal = "DestroyView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'DestroyView')
            kw["aname"] = "_DestroyView"
            if ns0.DestroyViewRequestType_Def not in ns0.DestroyView_Dec.__bases__:
                bases = list(ns0.DestroyView_Dec.__bases__)
                bases.insert(0, ns0.DestroyViewRequestType_Def)
                ns0.DestroyView_Dec.__bases__ = tuple(bases)

            ns0.DestroyViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "DestroyView_Dec_Holder"

    class DestroyViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "DestroyViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.DestroyViewResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'DestroyViewResponse')
            kw["aname"] = "_DestroyViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "DestroyViewResponse_Holder"
            self.pyclass = Holder

    class CreateInventoryView_Dec(ElementDeclaration):
        literal = "CreateInventoryView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateInventoryView')
            kw["aname"] = "_CreateInventoryView"
            if ns0.CreateInventoryViewRequestType_Def not in ns0.CreateInventoryView_Dec.__bases__:
                bases = list(ns0.CreateInventoryView_Dec.__bases__)
                bases.insert(0, ns0.CreateInventoryViewRequestType_Def)
                ns0.CreateInventoryView_Dec.__bases__ = tuple(bases)

            ns0.CreateInventoryViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateInventoryView_Dec_Holder"

    class CreateInventoryViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateInventoryViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateInventoryViewResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateInventoryViewResponse')
            kw["aname"] = "_CreateInventoryViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateInventoryViewResponse_Holder"
            self.pyclass = Holder

    class CreateContainerView_Dec(ElementDeclaration):
        literal = "CreateContainerView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateContainerView')
            kw["aname"] = "_CreateContainerView"
            if ns0.CreateContainerViewRequestType_Def not in ns0.CreateContainerView_Dec.__bases__:
                bases = list(ns0.CreateContainerView_Dec.__bases__)
                bases.insert(0, ns0.CreateContainerViewRequestType_Def)
                ns0.CreateContainerView_Dec.__bases__ = tuple(bases)

            ns0.CreateContainerViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateContainerView_Dec_Holder"

    class CreateContainerViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateContainerViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateContainerViewResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateContainerViewResponse')
            kw["aname"] = "_CreateContainerViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateContainerViewResponse_Holder"
            self.pyclass = Holder

    class CreateListView_Dec(ElementDeclaration):
        literal = "CreateListView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateListView')
            kw["aname"] = "_CreateListView"
            if ns0.CreateListViewRequestType_Def not in ns0.CreateListView_Dec.__bases__:
                bases = list(ns0.CreateListView_Dec.__bases__)
                bases.insert(0, ns0.CreateListViewRequestType_Def)
                ns0.CreateListView_Dec.__bases__ = tuple(bases)

            ns0.CreateListViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateListView_Dec_Holder"

    class CreateListViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateListViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateListViewResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateListViewResponse')
            kw["aname"] = "_CreateListViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateListViewResponse_Holder"
            self.pyclass = Holder

    class CreateListViewFromView_Dec(ElementDeclaration):
        literal = "CreateListViewFromView"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'CreateListViewFromView')
            kw["aname"] = "_CreateListViewFromView"
            if ns0.CreateListViewFromViewRequestType_Def not in ns0.CreateListViewFromView_Dec.__bases__:
                bases = list(ns0.CreateListViewFromView_Dec.__bases__)
                bases.insert(0, ns0.CreateListViewFromViewRequestType_Def)
                ns0.CreateListViewFromView_Dec.__bases__ = tuple(bases)

            ns0.CreateListViewFromViewRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "CreateListViewFromView_Dec_Holder"

    class CreateListViewFromViewResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "CreateListViewFromViewResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.CreateListViewFromViewResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'CreateListViewFromViewResponse')
            kw["aname"] = "_CreateListViewFromViewResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "CreateListViewFromViewResponse_Holder"
            self.pyclass = Holder

    class RevertToSnapshot_Dec(ElementDeclaration):
        literal = "RevertToSnapshot"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RevertToSnapshot')
            kw["aname"] = "_RevertToSnapshot"
            if ns0.RevertToSnapshotRequestType_Def not in ns0.RevertToSnapshot_Dec.__bases__:
                bases = list(ns0.RevertToSnapshot_Dec.__bases__)
                bases.insert(0, ns0.RevertToSnapshotRequestType_Def)
                ns0.RevertToSnapshot_Dec.__bases__ = tuple(bases)

            ns0.RevertToSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RevertToSnapshot_Dec_Holder"

    class RevertToSnapshotResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RevertToSnapshotResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RevertToSnapshotResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RevertToSnapshotResponse')
            kw["aname"] = "_RevertToSnapshotResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RevertToSnapshotResponse_Holder"
            self.pyclass = Holder

    class RevertToSnapshot_Task_Dec(ElementDeclaration):
        literal = "RevertToSnapshot_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RevertToSnapshot_Task')
            kw["aname"] = "_RevertToSnapshot_Task"
            if ns0.RevertToSnapshotRequestType_Def not in ns0.RevertToSnapshot_Task_Dec.__bases__:
                bases = list(ns0.RevertToSnapshot_Task_Dec.__bases__)
                bases.insert(0, ns0.RevertToSnapshotRequestType_Def)
                ns0.RevertToSnapshot_Task_Dec.__bases__ = tuple(bases)

            ns0.RevertToSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RevertToSnapshot_Task_Dec_Holder"

    class RevertToSnapshot_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RevertToSnapshot_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RevertToSnapshot_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RevertToSnapshot_TaskResponse')
            kw["aname"] = "_RevertToSnapshot_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RevertToSnapshot_TaskResponse_Holder"
            self.pyclass = Holder

    class RemoveSnapshot_Dec(ElementDeclaration):
        literal = "RemoveSnapshot"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveSnapshot')
            kw["aname"] = "_RemoveSnapshot"
            if ns0.RemoveSnapshotRequestType_Def not in ns0.RemoveSnapshot_Dec.__bases__:
                bases = list(ns0.RemoveSnapshot_Dec.__bases__)
                bases.insert(0, ns0.RemoveSnapshotRequestType_Def)
                ns0.RemoveSnapshot_Dec.__bases__ = tuple(bases)

            ns0.RemoveSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveSnapshot_Dec_Holder"

    class RemoveSnapshotResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveSnapshotResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveSnapshotResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RemoveSnapshotResponse')
            kw["aname"] = "_RemoveSnapshotResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RemoveSnapshotResponse_Holder"
            self.pyclass = Holder

    class RemoveSnapshot_Task_Dec(ElementDeclaration):
        literal = "RemoveSnapshot_Task"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RemoveSnapshot_Task')
            kw["aname"] = "_RemoveSnapshot_Task"
            if ns0.RemoveSnapshotRequestType_Def not in ns0.RemoveSnapshot_Task_Dec.__bases__:
                bases = list(ns0.RemoveSnapshot_Task_Dec.__bases__)
                bases.insert(0, ns0.RemoveSnapshotRequestType_Def)
                ns0.RemoveSnapshot_Task_Dec.__bases__ = tuple(bases)

            ns0.RemoveSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RemoveSnapshot_Task_Dec_Holder"

    class RemoveSnapshot_TaskResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RemoveSnapshot_TaskResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RemoveSnapshot_TaskResponse_Dec.schema
            TClist = [GTD("urn:vim25","ManagedObjectReference",lazy=True)(pname=(ns,"returnval"), aname="_returnval", minOccurs=1, maxOccurs=1, nillable=False, typed=False, encoded=kw.get("encoded"))]
            kw["pname"] = (u'urn:vim25', u'RemoveSnapshot_TaskResponse')
            kw["aname"] = "_RemoveSnapshot_TaskResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    self._returnval = None
                    return
            Holder.__name__ = "RemoveSnapshot_TaskResponse_Holder"
            self.pyclass = Holder

    class RenameSnapshot_Dec(ElementDeclaration):
        literal = "RenameSnapshot"
        schema = "urn:vim25"
        substitutionGroup = None
        def __init__(self, **kw):
            kw["pname"] = (u'urn:vim25', u'RenameSnapshot')
            kw["aname"] = "_RenameSnapshot"
            if ns0.RenameSnapshotRequestType_Def not in ns0.RenameSnapshot_Dec.__bases__:
                bases = list(ns0.RenameSnapshot_Dec.__bases__)
                bases.insert(0, ns0.RenameSnapshotRequestType_Def)
                ns0.RenameSnapshot_Dec.__bases__ = tuple(bases)

            ns0.RenameSnapshotRequestType_Def.__init__(self, **kw)
            if self.pyclass is not None: self.pyclass.__name__ = "RenameSnapshot_Dec_Holder"

    class RenameSnapshotResponse_Dec(ZSI.TCcompound.ComplexType, ElementDeclaration):
        literal = "RenameSnapshotResponse"
        schema = "urn:vim25"
        def __init__(self, **kw):
            ns = ns0.RenameSnapshotResponse_Dec.schema
            TClist = []
            kw["pname"] = (u'urn:vim25', u'RenameSnapshotResponse')
            kw["aname"] = "_RenameSnapshotResponse"
            self.attribute_typecode_dict = {}
            ZSI.TCcompound.ComplexType.__init__(self,None,TClist,inorder=0,**kw)
            class Holder:
                __metaclass__ = pyclass_type
                typecode = self
                def __init__(self):
                    # pyclass
                    return
            Holder.__name__ = "RenameSnapshotResponse_Holder"
            self.pyclass = Holder

# end class ns0 (tns: urn:vim25)
